# <std-header style='data' orig-src='shore'>
#
#  $Id: logdef.dat,v 1.67 2010/10/27 17:04:23 nhall Exp $
#
#
# (c) Copyright 2014, Hewlett-Packard Development Company, LP
#
#
# SHORE -- Scalable Heterogeneous Object REpository
#
# Copyright (c) 1994-99 Computer Sciences Department, University of
#                       Wisconsin -- Madison
# All Rights Reserved.
#
# Permission to use, copy, modify and distribute this software and its
# documentation is hereby granted, provided that both the copyright
# notice and this permission notice appear in all copies of the
# software, derivative works or modified versions, and any portions
# thereof, and that both notices appear in supporting documentation.
#
# THE AUTHORS AND THE COMPUTER SCIENCES DEPARTMENT OF THE UNIVERSITY
# OF WISCONSIN - MADISON ALLOW FREE USE OF THIS SOFTWARE IN ITS
# "AS IS" CONDITION, AND THEY DISCLAIM ANY LIABILITY OF ANY KIND
# FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
#
# This software was developed with support by the Advanced Research
# Project Agency, ARPA order number 018 (formerly 8230), monitored by
# the U.S. Army Research Laboratory under contract DAAB07-91-C-Q518.
# Further funding for this work was provided by DARPA through
# Rome Research Laboratory Contract No. F30602-97-2-0247.
#
#   -- do not edit anything above this line --   </std-header>

#########################################################################
#                                                                       #
#    WARNING: if you add, delete or change any of the log records,      #
#    or their data members, or their semantics you also need to         #
#    update log_m::_version_major and/or log_m::_version_minor      #
#    in log.cpp.                                                   #
#                                                                       #
#       For every log record type, the perl script generates a class    #
#       class <type>_log {                                              #
#           void fill(const PageID*p, uint16_t tag, int len);           #
#       public:                                                         #
#           <type>_log(<arg>);                                          #
#        // and...                                                      #
#        // iff R bit set:                                              #
#        void redo(fixable_page_h *page);                               #
#        // iff U bit set:                                              #
#        void undo(fixable_page_h *page);                               #
#       }                                                               #
#                                                                       #
#    The format of the file is as follows:                              #
#        type = log record type                                         #
#        X    = transaction log (generated by transactions)             #
#                      If set, logstub_gen.cpp contains a function      #
#                      rc_t log_<type> (<arg>) to generate the log recs #
#                      according to convention.  If not, the code else- #
#                      where in the SM has to be written by hand to gen #
#                      the log record.                                  #
#        S    = Single-System Transaction Log                           #
#               If this is true, begin/commit is fused to one log entry #
#        R    = redoable    (-->t_redo bit set in log record)           #
#                      Includes redo method in class                    #
#        U    = undoable    (-->t_undo)                                 #
#                      Includes undo method in class                    #
#        M    = Multi-page log (-->t_multi)                             #
#                      Log records that modify two pages; destination   #
#                      and source. If it moves content, page/page2 must #
#                      be in this order.                                #
#                      IMPORTANT: first two arguments must be called    #
#                      "page" and "page2", and be of type               #
#                      const btree_page_h&, otherwise stubs are not     #
#                      generated correctly!                             #
#        A    = space-allocation:                                       #
#                      If NOT set, generated code decides if logging    #
#                      should be done, based on :                       #
#                      1) smlevel_0::log, smlevel_0::logging_enabled,   #
#                      2) (if page argument present) page.store_flags   #
#                                            == st_tmp                  #
#                      3) xct() attached and xct()->is_log_on()         #
#                                                                       #
#                      If A bit IS SET, checks #2, #3 are left out      #
#                                                                       #
#        L    = logical undo log record -- don't fix the page           #
#                                        for undo.  Irrelevant if not   #
#                      an undoable log record.                          #
#                      --> t_logical                                    # 
#                                                                       #
#        fudge = observed fudge factor for log space reservations       #
#                                                                       #
#        arg  = arguments to constructor                                #
#                      SPECIAL CASE: first argument is "page":          #
#                      1) store flags checked to turn off logging for   #
#                      st_tmp files.                                    #
#                      2) give_logbuf() call passes page for 2nd arg    #
#                      3) page.set_dirty() if logging is skipped        #
#                                    #
#########################################################################
# type             XSRUMAL  fudge    arg                                #
#########################################################################
comment            1011001 1.0 (const char* msg);
compensate         1000001 0.0 (const lsn_t& rec_lsn);
skip               0000000 0.0 ();
chkpt_begin        0000000 0.0 (const lsn_t &lastMountLSN);
chkpt_bf_tab       0000000 0.0 (int cnt, const PageID* pid, const StoreID* store,
                            const lsn_t* rec_lsn, const lsn_t* page_lsn);
chkpt_xct_tab      0000000 0.0 (const tid_t& youngest, 
                            int cnt, const tid_t* tid, 
                            const smlevel_0::xct_state_t* state,
                            const lsn_t* last_lsn, const lsn_t* first_lsn);               
# per active transaction granted lock log
chkpt_xct_lock      0000000 0.0 (const tid_t& tid, int cnt, const okvl_mode* lock_mode, const uint32_t* lock_hash);
chkpt_restore_tab  0010000 0.0 ();
chkpt_backup_tab   0010000 0.0 (int cnt, const string* paths);
chkpt_end          0000000 0.0 (const lsn_t& master, const lsn_t& min_rec_lsn, const lsn_t& min_xct_lsn);
add_backup         1110000 0.0 (const char* dev_name);
#########################################################################
# type             XSRUMAL  fudge    arg                                #
#########################################################################
xct_abort          1000000 0.0 ();
xct_freeing_space  1000000 0.0 ();
xct_end            1000000 0.0 ();
xct_end_group      1000000 0.0 (const xct_t** l, int llen);
#########################################################################
# type             XSRUMAL  fudge    arg                                #
#########################################################################
# CS TODO -- this should be part of btree empty page allocation
alloc_page       1110000  1.0  (PageID pid);
dealloc_page     1110000  1.0  (PageID pid);
create_store     1110000  1.0  (PageID root_pid, StoreID snum);
append_extent    1110000  1.0  (extent_id_t ext);
# Instant Restore log records
restore_begin      1110000 0.0 ();
restore_segment    1110000 0.0 (uint32_t segment);
restore_end        1110000 0.0 ();
#########################################################################
# type             XSRUMAL  fudge    arg                                #
#########################################################################
# This just sets the status of the page to "to-be-deleted".
# Once the page is actually deleted by bufferpool, we can't UNDO it.
page_set_to_be_deleted   1011000 1.0 (const fixable_page_h& page);

# This is a special way of logging the creation of a new page.
# New page creation is usually a page split, so the new page has many
# records in it. To simplify and to avoid many log entries in that case,
# we log ALL bytes from the beginning to the end of slot vector,
# and from the record_head to the end of page.
# We can assume totally defragmented page image because this is page creation.
# We don't need UNDO (again, this is page creation!), REDO is just two memcpy().
page_img_format   1011000 1.0 (const btree_page_h& page);

# Invoked when a page is evicted from bufferpool. Implemented in log_spr.h/cpp
page_evict        1110000 1.0 (const btree_page_h& page,
                        general_recordid_t child_slot, lsn_t child_lsn);

#########################################################################
# type             XSRUMAL  fudge    arg                                #
#########################################################################
# page is the foster-parent, page2 is the new foster-child
btree_norec_alloc  1110110 1.0 (const btree_page_h& page, const btree_page_h& page2,
    PageID new_page_id, const w_keystr_t& fence, const w_keystr_t& chain_fence_high);

# sys_txn is true if the insert log record was from a page rebalance full logging transaction
btree_insert       1011001 1.42 (const btree_page_h& page,
                            const w_keystr_t& key, const cvec_t& el, const bool sys_txn);
btree_insert_nonghost 1011001 1.42 (const btree_page_h& page,
                            const w_keystr_t& key, const cvec_t& el, const bool sys_txn);

btree_update       1011001 1.42 (const btree_page_h& page, const w_keystr_t& key,
    const char* old_el, int old_elen, const cvec_t& new_el);

btree_overwrite    1011001 1.00 (const btree_page_h& page, const w_keystr_t& key,
    const char* old_el, const char* new_el, size_t offset, size_t elen);

# ghost records. currently only for BTrees as their UNDO/REDO rely on BTree access.
# sys_txn is true if the delete log record was from a page rebalance full logging transaction
btree_ghost_mark    1011001 1.0  (const btree_page_h& page, const vector<slotid_t>& slots, const bool sys_txn);
btree_ghost_reclaim 1110000 1.0  (const btree_page_h& page, const vector<slotid_t>& slots);
# ghost reservation is fused
btree_ghost_reserve 1110000 1.0  (const btree_page_h& page, const w_keystr_t& key, int element_length);

# page is real-parent, page2 is real-child. If needed page is already split before this op.
btree_foster_adopt  1110100 1.0 (const btree_page_h& page, const btree_page_h& page2,
    PageID new_child_pid, lsn_t child_emlsn, const w_keystr_t& new_child_key);

# page is foster-parent (dest), page2 is foster_child (src) which will disappear.
# Self contained log (not minimal logging). So, page=dest, page2=src.
# high - high key of the destination page (foster key if exists)
# chain_high - high fence key of all foster nodes (parent and child nodes)
# foster_pid0 - page id of the foster page in destination page
# foster_emlsn - emlsn of the foster page in destination page
# prefix_len - source page prefix length
# move_count - how many records to move
# record_data - self-contain record data for all the moved records
# record_data_len - size of data in record_data
btree_foster_merge  1110100 1.42 (const btree_page_h& page, const btree_page_h& page2, 
    const w_keystr_t& high, const w_keystr_t& chain_high, PageID foster_pid0, lsn_t foster_emlsn,
    const int16_t prefix_len, const int32_t move_count, const smsize_t record_buffer_len,
    const cvec_t& record_data);
    
# "page" is the foster-child (dest). "page2" is the foster-parent (src).
# Self contained log (not minimal logging). So, page=dest, page2=src.
# fence - low fence key of the destination page, also foster key (high) of the source page
# high - high key of the destination page (foster key if exists)
# chain_high - high fence key of all foster nodes (parent and child nodes)
# prefix_len - source page prefix length, which would be the prefix length for destination page
# move_count - how many records to move
# record_data - self-contain record data for all the moved records
# record_data_len - size of data in record_data
btree_foster_rebalance       1110100 1.42 (const btree_page_h& page, const btree_page_h& page2,
    const w_keystr_t& fence, PageID new_pid0, lsn_t pid0_emlsn, 
    const w_keystr_t& high, const w_keystr_t& chain_high, const int16_t prefix_len,
    const int32_t move_count, const smsize_t record_data_len, const cvec_t& record_data);

btree_foster_rebalance_norec 1110100 1.0 (const btree_page_h& page, const btree_page_h& page2,
    const w_keystr_t& fence);

# "page" is the real-parent. "page2" is the foster-parent.
btree_foster_deadopt         1110100 1.0 (const btree_page_h& page, const btree_page_h& page2,
    PageID deadopted_pid, lsn_t deadopted_emlsn,
    int32_t foster_slot, const w_keystr_t& low, const w_keystr_t& high);

# page == foster parent, page2 == foster child
btree_split            1110100 1.0 (const btree_page_h& page,
    const btree_page_h& page2, uint16_t move_count,
    const w_keystr_t& new_high_fence, const w_keystr_t& new_chain);

btree_compress_page    1110000 1.0 (const btree_page_h& page,
    const w_keystr_t& low, const w_keystr_t& high, const w_keystr_t& chain);

### SYSTEM EVENTS (constructor does not matter)
tick_sec             0000000 0.0 ();
tick_msec            0000000 0.0 ();
benchmark_start      0000000 0.0 ();
page_write           0000000 0.0 ();
page_read            0000000 0.0 ();

#########################################################################
# type             XSRUMAL  fudge    arg                                #
#########################################################################
