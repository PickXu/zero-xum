!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABORTED	plog.h	/^        ABORTED = 0x04$/;"	e	enum:plog_t::state_t
ABSOLUTE_LOCK_TIMEOUT_MICROSEC	lock_lil.cpp	/^const int ABSOLUTE_LOCK_TIMEOUT_MICROSEC = 100000;$/;"	v
ACCESS_ONCE	btree_page.h	/^inline T volatile &ACCESS_ONCE(T &t) {$/;"	f
ACQUIRE	log.h	64;"	d
ACTIVE	lock_raw.h	/^        ACTIVE,$/;"	e	enum:RawLock::LockState
ACTIVE	lock_raw.h	/^        ACTIVE,$/;"	e	enum:RawXct::XctState
ADD_LOG_COMMENT_SIG	xct.h	70;"	d
ADD_LOG_COMMENT_SIG	xct.h	77;"	d
ADD_LOG_COMMENT_USE	xct.h	71;"	d
ADD_LOG_COMMENT_USE	xct.h	78;"	d
ADD_TSTAT	smthread.h	508;"	d
ALLOCATOR_H	allocator.h	2;"	d
ALLOC_CACHE_H	alloc_cache.h	6;"	d
ALLOC_PAGE_H	alloc_page.h	6;"	d
ALL_SLOT_COUNT	log_carray.h	/^        ALL_SLOT_COUNT      = 256,$/;"	e	enum:ConsolidationArray::Constants
AUTO_ROLLBACK_work	xct.h	919;"	d
AddLoadStore	xct.cpp	/^void xct_t::AddLoadStore(const stid_t& stid)$/;"	f	class:xct_t
AddStoreToFree	xct.cpp	/^void xct_t::AddStoreToFree(const stid_t& stid)$/;"	f	class:xct_t
AlignedMemory	backup.cpp	/^AlignedMemory::AlignedMemory(size_t size) : _size(size), _buffer(NULL) {$/;"	f	class:AlignedMemory
AlignedMemory	backup.h	/^class AlignedMemory {$/;"	c
ArchiveDirectory	logarchiver.cpp	/^LogArchiver::ArchiveDirectory::ArchiveDirectory(std::string archdir,$/;"	f	class:LogArchiver::ArchiveDirectory
ArchiveDirectory	logarchiver.h	/^    class ArchiveDirectory {$/;"	c	class:LogArchiver
ArchiveIndex	logarchiver.cpp	/^LogArchiver::ArchiveIndex::ArchiveIndex(size_t blockSize, lsn_t startLSN,$/;"	f	class:LogArchiver::ArchiveIndex
ArchiveIndex	logarchiver.h	/^    class ArchiveIndex {$/;"	c	class:LogArchiver
ArchiveScanner	logarchiver.cpp	/^LogArchiver::ArchiveScanner::ArchiveScanner(ArchiveDirectory* directory)$/;"	f	class:LogArchiver::ArchiveScanner
ArchiveScanner	logarchiver.h	/^    class ArchiveScanner {$/;"	c	class:LogArchiver
ArchiverControl	logarchiver.cpp	/^ArchiverControl::ArchiverControl(bool* shutdownFlag)$/;"	f	class:ArchiverControl
ArchiverControl	logarchiver.h	/^struct ArchiverControl {$/;"	s
ArchiverHeap	logarchiver.cpp	/^LogArchiver::ArchiverHeap::ArchiverHeap(size_t workspaceSize)$/;"	f	class:LogArchiver::ArchiverHeap
ArchiverHeap	logarchiver.h	/^    class ArchiverHeap {$/;"	c	class:LogArchiver
AsyncRingBuffer	ringbuffer.h	/^    AsyncRingBuffer(size_t bsize, size_t bcount)$/;"	f	class:AsyncRingBuffer
AsyncRingBuffer	ringbuffer.h	/^class AsyncRingBuffer {$/;"	c
AutoTurnOffLogging	restart.h	/^        AutoTurnOffLogging()$/;"	f	class:AutoTurnOffLogging
AutoTurnOffLogging	restart.h	/^class AutoTurnOffLogging {$/;"	c
BACKUP_H	backup.h	6;"	d
BACKUP_READER_H	backup_reader.h	2;"	d
BF_FIXED_H	bf_fixed.h	6;"	d
BF_HASHTABLE_CPP	bf_hashtable.cpp	5;"	d	file:
BF_HASHTABLE_H	bf_hashtable.h	6;"	d
BF_HASH_SEED	bf_hashtable.cpp	/^const uint32_t BF_HASH_SEED = 0x35D0B891;$/;"	v
BF_IDX_H	bf_idx.h	6;"	d
BF_TRANSIT_BUCKET_H	bf_transit_bucket.h	64;"	d
BF_TREE_CB_H	bf_tree_cb.h	6;"	d
BF_TREE_CLEANER_H	bf_tree_cleaner.h	6;"	d
BF_TREE_H	bf_tree.h	6;"	d
BF_TREE_VOL_T	bf_tree_vol.h	6;"	d
BLOCK_SIZE	log_storage.h	/^    enum { BLOCK_SIZE=partition_t::XFERSIZE };$/;"	e	enum:log_storage::__anon28
BP_ALTERNATE_CB_LATCH	bf_tree.h	104;"	d
BP_ALTERNATE_CB_LATCH	bf_tree.h	94;"	d
BP_CAN_EVICT_INNER_NODE	bf_tree.h	83;"	d
BP_INITIAL_REFCOUNT	bf_tree.h	/^const uint16_t BP_INITIAL_REFCOUNT = 0;$/;"	v
BP_MAINTAIN_REPLACEMENT_PRIORITY	bf_tree.h	80;"	d
BP_MAX_REFCOUNT	bf_tree.h	/^const uint16_t BP_MAX_REFCOUNT = 16;$/;"	v
BP_TRACK_SWIZZLED_PTR_CNT	bf_tree.h	100;"	d
BTCURSOR_H	btcursor.h	6;"	d
BTREE_C	btcursor.cpp	8;"	d	file:
BTREE_C	btree.cpp	8;"	d	file:
BTREE_C	btree_impl.cpp	13;"	d	file:
BTREE_C	btree_impl_defrag.cpp	13;"	d	file:
BTREE_C	btree_impl_grow.cpp	13;"	d	file:
BTREE_C	btree_impl_lock.cpp	12;"	d	file:
BTREE_C	btree_impl_merge.cpp	12;"	d	file:
BTREE_C	btree_impl_search.cpp	13;"	d	file:
BTREE_C	btree_impl_split.cpp	13;"	d	file:
BTREE_C	btree_impl_verify.cpp	12;"	d	file:
BTREE_C	btree_page_h.cpp	8;"	d	file:
BTREE_H	btree.h	6;"	d
BTREE_H	sm_base.h	857;"	d
BTREE_IMPL_H	btree_impl.h	6;"	d
BTREE_LOGREC_H	btree_logrec.h	11;"	d
BTREE_PAGE_H	btree_page.h	6;"	d
BTREE_PAGE_H_H	btree_page_h.h	6;"	d
BTREE_VERIFY_H	btree_verify.h	6;"	d
BackupFile	backup.h	/^class BackupFile {$/;"	c
BackupFile	backup.h	/^inline BackupFile::BackupFile(vid_t vid, const std::string &path)$/;"	f	class:BackupFile
BackupManager	backup.h	/^class BackupManager {$/;"	c
BackupManager	backup.h	/^inline BackupManager::BackupManager(const std::string &backup_folder)$/;"	f	class:BackupManager
BackupOnDemandReader	backup_reader.cpp	/^BackupOnDemandReader::BackupOnDemandReader(vol_t* volume, size_t segmentSize)$/;"	f	class:BackupOnDemandReader
BackupOnDemandReader	backup_reader.h	/^class BackupOnDemandReader : public BackupReader {$/;"	c
BackupPrefetcher	backup_reader.cpp	/^BackupPrefetcher::BackupPrefetcher(vol_t* volume, size_t numSegments,$/;"	f	class:BackupPrefetcher
BackupPrefetcher	backup_reader.h	/^class BackupPrefetcher : public smthread_t, public BackupReader {$/;"	c
BackupReader	backup_reader.cpp	/^BackupReader::BackupReader(size_t bufferSize)$/;"	f	class:BackupReader
BackupReader	backup_reader.h	/^class BackupReader {$/;"	c
BaseThread	logarchiver.h	/^        BaseThread(AsyncRingBuffer* buf, const char* tname)$/;"	f	class:LogArchiver::BaseThread
BaseThread	logarchiver.h	/^    class BaseThread : public smthread_t {$/;"	c	class:LogArchiver
BlockAssembly	logarchiver.cpp	/^LogArchiver::BlockAssembly::BlockAssembly(ArchiveDirectory* directory)$/;"	f	class:LogArchiver::BlockAssembly
BlockAssembly	logarchiver.h	/^    class BlockAssembly {$/;"	c	class:LogArchiver
BlockEntry	logarchiver.h	/^        struct BlockEntry {$/;"	s	class:LogArchiver::ArchiveIndex
BlockHeader	logarchiver.h	/^        struct BlockHeader {$/;"	s	class:LogArchiver::ArchiveIndex
BlockHeader	logarchiver.h	/^        struct BlockHeader {$/;"	s	class:LogArchiver::BlockAssembly
CARRAY_RELEASE_DELEGATION	log_carray.h	/^const bool CARRAY_RELEASE_DELEGATION = false;$/;"	v
CARRAY_RELEASE_DELEGATION	log_carray.h	/^const bool CARRAY_RELEASE_DELEGATION = true;$/;"	v
CArraySlot	log_carray.h	/^struct CArraySlot {$/;"	s
CHECK_NESTING_VARIABLES	sm_base.h	147;"	d
CHECK_NESTING_VARIABLES	sm_base.h	149;"	d
CHKPT_C	chkpt.cpp	63;"	d	file:
CHKPT_H	chkpt.h	58;"	d
CHKPT_META_BUF	log_core.h	71;"	d
CHKPT_SERIAL_C	chkpt_serial.cpp	62;"	d	file:
CHKPT_SERIAL_H	chkpt_serial.h	58;"	d
CLOCK_FOR_LIL	lock_lil.cpp	/^const clockid_t CLOCK_FOR_LIL = CLOCK_REALTIME; \/\/ CLOCK_MONOTONIC;$/;"	v
COMMITTED	plog.h	/^        COMMITTED = 0x02,$/;"	e	enum:plog_t::state_t
CRASH_H	crash.h	35;"	d
CURR_MERGE_FILE	logarchiver.cpp	/^const char* LogArchiver::CURR_MERGE_FILE = "current_merge";$/;"	m	class:LogArchiver	file:
CURR_MERGE_FILE	logarchiver.h	/^    const static char* CURR_MERGE_FILE;$/;"	m	class:LogArchiver
CURR_RUN_FILE	logarchiver.cpp	/^const char* LogArchiver::CURR_RUN_FILE = "current_run";$/;"	m	class:LogArchiver	file:
CURR_RUN_FILE	logarchiver.h	/^    const static char* CURR_RUN_FILE;$/;"	m	class:LogArchiver
Clear	sm_du_stats.h	/^inline void SmFileMetaStats::Clear()$/;"	f	class:SmFileMetaStats
Clear	sm_du_stats.h	/^inline void SmStoreMetaStats::Clear()$/;"	f	class:SmStoreMetaStats
Clear	sm_du_stats.h	/^inline void SmVolumeMetaStats::Clear()$/;"	f	class:SmVolumeMetaStats
ClearAllLoadStores	xct.cpp	/^xct_t::ClearAllLoadStores()$/;"	f	class:xct_t
ClearAllStoresToFree	xct.cpp	/^xct_t::ClearAllStoresToFree()$/;"	f	class:xct_t
Cmp	logarchiver.h	/^        struct Cmp {$/;"	s	class:LogArchiver::ArchiverHeap
CmpMountLsns	restart.h	/^class CmpMountLsns$/;"	c
CmpXctLockTids	restart.h	/^class CmpXctLockTids$/;"	c
CmpXctUndoLsns	restart.h	/^class CmpXctUndoLsns$/;"	c
Compatibility	lock_raw.h	/^        Compatibility(bool grant, bool deadlock, RawXct* block)$/;"	f	struct:RawLockQueue::Compatibility
Compatibility	lock_raw.h	/^    struct Compatibility {$/;"	s	struct:RawLockQueue
ConsolidationArray	log_carray.cpp	/^ConsolidationArray::ConsolidationArray(int active_slot_count)$/;"	f	class:ConsolidationArray
ConsolidationArray	log_carray.h	/^class ConsolidationArray {$/;"	c
ConstantValue	backup.h	/^    enum ConstantValue {$/;"	g	class:AlignedMemory
Constants	log_carray.h	/^    enum Constants {$/;"	g	class:ConsolidationArray
ConvertAllLoadStoresToRegularStores	xct.cpp	/^xct_t::ConvertAllLoadStoresToRegularStores()$/;"	f	class:xct_t
DBGTHRD	smthread.h	704;"	d
DBGTHRD	smthread.h	706;"	d
DBGX	xct.cpp	53;"	d	file:
DEBUG_FINGERPRINTS	smthread.cpp	190;"	d	file:
DEBUG_GNATS_77	sm_du_stats.cpp	53;"	d	file:
DEBUG_MSG	logbuf_core.h	/^const char DEBUG_MSG[]="DEBUG";$/;"	v
DEFAULT_ACTIVE_SLOT_COUNT	log_carray.h	/^        DEFAULT_ACTIVE_SLOT_COUNT   = 3,$/;"	e	enum:ConsolidationArray::Constants
DEFINE_SM_ALLOC	allocator.h	42;"	d
DFT_BLOCK_SIZE	logarchiver.h	/^    const static int DFT_BLOCK_SIZE = 1024 * 1024; \/\/ 1MB = 128 pages$/;"	m	class:LogArchiver
DFT_EAGER	logarchiver.h	/^    const static bool DFT_EAGER = false;$/;"	m	class:LogArchiver
DFT_GRACE_PERIOD	logarchiver.h	/^    const static int DFT_GRACE_PERIOD = 1000000; \/\/ 1 sec$/;"	m	class:LogArchiver
DFT_LOGBUFSIZE	log_core.cpp	/^const uint64_t log_common::DFT_LOGBUFSIZE = 128 << 10;$/;"	m	class:log_common	file:
DFT_LOGBUFSIZE	log_core.h	/^    static const uint64_t DFT_LOGBUFSIZE;$/;"	m	class:log_common
DFT_READ_WHOLE_BLOCKS	logarchiver.h	/^    const static bool DFT_READ_WHOLE_BLOCKS = true;$/;"	m	class:LogArchiver
DFT_WSPACE_SIZE	logarchiver.h	/^    const static int DFT_WSPACE_SIZE= 10240 * 10240; \/\/ 100MB$/;"	m	class:LogArchiver
Decrement	xct.cpp	/^        int Decrement(int vol)$/;"	f	class:VolidCnt
DummyBackupReader	backup_reader.h	/^    DummyBackupReader(size_t segmentSize)$/;"	f	class:DummyBackupReader
DummyBackupReader	backup_reader.h	/^class DummyBackupReader : public BackupReader {$/;"	c
DumpBlockedThreads	smthread.cpp	/^DumpBlockedThreads(ostream& o)$/;"	f
DumpStoresToFree	xct.cpp	/^xct_t::DumpStoresToFree()$/;"	f	class:xct_t
ELR_READONLY_WAIT_MAX_COUNT	xct.h	/^const int ELR_READONLY_WAIT_MAX_COUNT = 10;$/;"	v
ELR_READONLY_WAIT_USEC	xct.h	/^const int ELR_READONLY_WAIT_USEC = 2000;$/;"	v
EVENTLOG_H	eventlog.h	2;"	d
EVICT_BATCH_RATIO	bf_tree.h	/^const float EVICT_BATCH_RATIO = 0.01;$/;"	v
EVICT_COMPLETE	bf_tree.h	/^    EVICT_COMPLETE,$/;"	e	enum:evict_urgency_t
EVICT_EAGER	bf_tree.h	/^    EVICT_EAGER,$/;"	e	enum:evict_urgency_t
EVICT_MAX_ROUNDS	bf_tree.h	/^const uint16_t EVICT_MAX_ROUNDS = 20;$/;"	v
EVICT_NORMAL	bf_tree.h	/^    EVICT_NORMAL = 0,$/;"	e	enum:evict_urgency_t
EVICT_URGENT	bf_tree.h	/^    EVICT_URGENT,$/;"	e	enum:evict_urgency_t
FILE_LOG_COMMENT_ON	smfile.cpp	72;"	d	file:
FILE_LOG_COMMENT_ON	smfile.cpp	74;"	d	file:
FINGER_BITS	smthread.h	/^enum { FINGER_BITS=SM_DREADLOCK_FINGERS };$/;"	e	enum:__anon40
FIXABLE_PAGE_H_H	fixable_page_h.h	6;"	d
FORCE_SLEEP_MS_MAX	bf_tree_cleaner.cpp	/^const uint32_t FORCE_SLEEP_MS_MAX = 1000;$/;"	v
FORCE_SLEEP_MS_MIN	bf_tree_cleaner.cpp	/^const uint32_t FORCE_SLEEP_MS_MIN = 10;$/;"	v
FORMAT_VERSION	vol.h	/^    static const uint32_t FORMAT_VERSION = 20;$/;"	m	class:volhdr_t
FREELIST_HEAD	bf_tree.h	917;"	d
FUNC	smthread.h	737;"	d
FUNC	smthread.h	738;"	d
FreeAllStoresToFree	xct.cpp	/^xct_t::FreeAllStoresToFree()$/;"	f	class:xct_t
GAC_HASH_BITS	btree_impl.h	/^        GAC_HASH_BITS = 16, \/\/ 64K$/;"	e	enum:btree_impl::__anon2
GAC_HASH_MOD	btree_impl.h	/^        GAC_HASH_MOD = 65521 \/\/ some prime number smaller than 2^GAC_HASH_BITS$/;"	e	enum:btree_impl::__anon2
GENERIC_PAGE_H	generic_page.h	6;"	d
GET_TSTAT	smthread.h	495;"	d
HASHBUCKET_INITIAL_CHUNK_SIZE	bf_hashtable.cpp	/^const size_t HASHBUCKET_INITIAL_CHUNK_SIZE = 4;$/;"	v
HASHBUCKET_INITIAL_CHUNK_SIZE	logbuf_hashtable.cpp	/^const size_t HASHBUCKET_INITIAL_CHUNK_SIZE = 4;$/;"	v
HASHBUCKET_INITIAL_EXPANSION	bf_hashtable.cpp	/^const uint32_t HASHBUCKET_INITIAL_EXPANSION = 16;$/;"	v
HASHBUCKET_INITIAL_EXPANSION	logbuf_hashtable.cpp	/^const uint32_t HASHBUCKET_INITIAL_EXPANSION = 16;$/;"	v
HASHBUCKET_SUBSEQUENT_EXPANSION	bf_hashtable.cpp	/^const uint32_t HASHBUCKET_SUBSEQUENT_EXPANSION = 4;$/;"	v
HASHBUCKET_SUBSEQUENT_EXPANSION	logbuf_hashtable.cpp	/^const uint32_t HASHBUCKET_SUBSEQUENT_EXPANSION = 4;$/;"	v
HAS_LOSER_COUNT	lock_raw.cpp	/^const int HAS_LOSER_COUNT = 999;                     \/\/ Has loser transaction in transaction table$/;"	v
HeapEntry	logarchiver.h	/^            HeapEntry()$/;"	f	struct:LogArchiver::ArchiverHeap::HeapEntry
HeapEntry	logarchiver.h	/^            HeapEntry(uint8_t run, lpid_t pid, lsn_t lsn,$/;"	f	struct:LogArchiver::ArchiverHeap::HeapEntry
HeapEntry	logarchiver.h	/^        struct HeapEntry {$/;"	s	class:LogArchiver::ArchiverHeap
IMPL_NAME	backup_reader.cpp	/^const std::string BackupOnDemandReader::IMPL_NAME = "ondemand";$/;"	m	class:BackupOnDemandReader	file:
IMPL_NAME	backup_reader.cpp	/^const std::string BackupPrefetcher::IMPL_NAME = "prefetcher";$/;"	m	class:BackupPrefetcher	file:
IMPL_NAME	backup_reader.cpp	/^const std::string DummyBackupReader::IMPL_NAME = "dummy";$/;"	m	class:DummyBackupReader	file:
IMPL_NAME	backup_reader.h	/^    static const std::string IMPL_NAME;$/;"	m	class:BackupOnDemandReader
IMPL_NAME	backup_reader.h	/^    static const std::string IMPL_NAME;$/;"	m	class:BackupPrefetcher
IMPL_NAME	backup_reader.h	/^    static const std::string IMPL_NAME;$/;"	m	class:DummyBackupReader
IMPL_NAME	log_core.cpp	/^const std::string log_core::IMPL_NAME = "traditional";$/;"	m	class:log_core	file:
IMPL_NAME	log_core.h	/^    static const std::string IMPL_NAME;$/;"	m	class:log_core
IMPL_NAME	logbuf_core.cpp	/^const std::string logbuf_core::IMPL_NAME = "logbuf";$/;"	m	class:logbuf_core	file:
IMPL_NAME	logbuf_core.h	/^    static const std::string IMPL_NAME;$/;"	m	class:logbuf_core
IMPL_NAME	plog_xct.cpp	/^const std::string plog_xct_t::IMPL_NAME = "plog";$/;"	m	class:plog_xct_t	file:
IMPL_NAME	plog_xct.h	/^    static const std::string IMPL_NAME;$/;"	m	class:plog_xct_t
IMPL_NAME	xct.cpp	/^const std::string xct_t::IMPL_NAME = "traditional";$/;"	m	class:xct_t	file:
IMPL_NAME	xct.h	/^    static const std::string IMPL_NAME;$/;"	m	class:xct_t
INC_TSTAT	smthread.h	503;"	d
INITIAL_SIZE	plog.h	/^        INITIAL_SIZE = 49152 \/\/ 48KB$/;"	e	enum:plog_t::__anon34
INITIAL_SORT_BUFFER_SIZE	bf_tree_cleaner.cpp	/^const int INITIAL_SORT_BUFFER_SIZE = 64;$/;"	v
INIT_SCAN_PROLOGUE_RC	prologue.h	88;"	d
INTENT_LOCK_TIMEOUT_MICROSEC	lock_lil.cpp	/^const int INTENT_LOCK_TIMEOUT_MICROSEC = 10000;$/;"	v
IO_ALIGN	backup_reader.cpp	/^const size_t IO_ALIGN = LogArchiver::IO_ALIGN;$/;"	v
IO_ALIGN	logarchiver.cpp	/^const size_t LogArchiver::IO_ALIGN = 512;$/;"	m	class:LogArchiver	file:
IO_ALIGN	logarchiver.h	/^    const static size_t IO_ALIGN;$/;"	m	class:LogArchiver
IO_BLOCK_COUNT	logarchiver.h	/^    const static int IO_BLOCK_COUNT = 8; \/\/ total buffer = 8MB$/;"	m	class:LogArchiver
Increment	xct.cpp	/^        int Increment(int vol)$/;"	f	class:VolidCnt
IncrementPages	sm_du_stats.h	/^inline void SmStoreMetaStats::IncrementPages(int numReserved, int numAlloc)$/;"	f	class:SmStoreMetaStats
IncrementPages	sm_du_stats.h	/^inline void SmVolumeMetaStats::IncrementPages(int numReserved, int numAlloc)$/;"	f	class:SmVolumeMetaStats
Iterator	lock_raw.cpp	/^RawLockQueue::Iterator::Iterator(const RawLockQueue* enclosure_arg, RawLock* start_from)$/;"	f	class:RawLockQueue::Iterator
Iterator	lock_raw.h	/^    struct Iterator {$/;"	s	struct:RawLockQueue
LIL_IS	lock_lil.h	/^    LIL_IS = 0,$/;"	e	enum:lil_lock_modes_t
LIL_IX	lock_lil.h	/^    LIL_IX = 1,$/;"	e	enum:lil_lock_modes_t
LIL_MODES	lock_lil.h	/^    LIL_MODES = 4$/;"	e	enum:lil_lock_modes_t
LIL_S	lock_lil.h	/^    LIL_S = 2,$/;"	e	enum:lil_lock_modes_t
LIL_X	lock_lil.h	/^    LIL_X = 3,$/;"	e	enum:lil_lock_modes_t
LOCATING_SSMTEST_CALL	crash.cpp	262;"	d	file:
LOCKID_T_HASH_MULT	lock_s.h	/^const uint32_t LOCKID_T_HASH_MULT = 0x35D0B891;$/;"	v
LOCKID_T_HASH_SEED	lock_s.h	/^const uint32_t LOCKID_T_HASH_SEED = 0xEE5C61DD;$/;"	v
LOCK_BUCKET_H	lock_bucket.h	6;"	d
LOCK_C	lock.cpp	8;"	d	file:
LOCK_COMPT_H	lock_compt.h	6;"	d
LOCK_CORE_C	lock_core.cpp	7;"	d	file:
LOCK_CORE_C	lock_dump.cpp	7;"	d	file:
LOCK_CORE_C	lock_vtable.cpp	7;"	d	file:
LOCK_CORE_H	lock_core.h	6;"	d
LOCK_H	lock.h	6;"	d
LOCK_LIL_H	lock_lil.h	6;"	d
LOCK_RAW_H	lock_raw.h	5;"	d
LOCK_S_H	lock_s.h	6;"	d
LOCK_X_H	lock_x.h	6;"	d
LOGARCHIVER_C	logarchiver.cpp	4;"	d	file:
LOGARCHIVER_H	logarchiver.h	4;"	d
LOGBUF_BLOCK_SIZE	logbuf_common.h	/^const uint32_t LOGBUF_BLOCK_SIZE = 8192;$/;"	v
LOGBUF_COMMON_H	logbuf_common.h	6;"	d
LOGBUF_CORE_H	logbuf_core.h	6;"	d
LOGBUF_FLUSH_TRIGGER	logbuf_common.h	/^const uint32_t LOGBUF_FLUSH_TRIGGER = LOGBUF_SEG_COUNT - 2;$/;"	v
LOGBUF_HASHTABLE_H	logbuf_hashtable.h	6;"	d
LOGBUF_HASH_SEED	logbuf_hashtable.cpp	/^const uint32_t LOGBUF_HASH_SEED = 0x35D0B891;$/;"	v
LOGBUF_PART_SIZE	logbuf_common.h	/^const uint32_t LOGBUF_PART_SIZE = 128 * LOGBUF_SEG_SIZE;$/;"	v
LOGBUF_SEG_COUNT	logbuf_common.h	/^const uint32_t LOGBUF_SEG_COUNT = 10;  \/\/ max number of segments in the log buffer$/;"	v
LOGBUF_SEG_H	logbuf_seg.h	5;"	d
LOGBUF_SEG_SIZE	logbuf_common.h	/^const uint32_t LOGBUF_SEG_SIZE = 128 * LOGBUF_BLOCK_SIZE;$/;"	v
LOGREC_ACCOUNT	logrec.h	886;"	d
LOGREC_ACCOUNT	logrec.h	896;"	d
LOGREC_ACCOUNTING	logrec.h	877;"	d
LOGREC_ACCOUNTING_PRINT	logrec.h	885;"	d
LOGREC_ACCOUNTING_PRINT	logrec.h	895;"	d
LOGREC_ACCOUNT_END_XCT	logrec.h	890;"	d
LOGREC_ACCOUNT_END_XCT	logrec.h	897;"	d
LOGREC_C	btree_logrec.h	16;"	d
LOGREC_C	common_templates.cpp	62;"	d	file:
LOGREC_C	logrec.cpp	10;"	d	file:
LOGREC_H	logrec.h	58;"	d
LOGSTUB_C	logstub.cpp	39;"	d	file:
LOGTRACE	crash.h	45;"	d
LOGTRACE	crash.h	76;"	d
LOGTRACE1	crash.h	62;"	d
LOGTRACE1	crash.h	77;"	d
LOGTRACE2	crash.h	73;"	d
LOGTRACE2	crash.h	78;"	d
LOG_ARCHIVED_CALLBACK_FUNC	sm.h	/^    typedef smlevel_0::LOG_ARCHIVED_CALLBACK_FUNC LOG_ARCHIVED_CALLBACK_FUNC;$/;"	t	class:ss_m
LOG_ARCHIVED_CALLBACK_FUNC	sm_base.h	/^    typedef w_rc_t (*LOG_ARCHIVED_CALLBACK_FUNC) ($/;"	t	class:smlevel_0
LOG_C	crash.cpp	44;"	d	file:
LOG_C	log.cpp	62;"	d	file:
LOG_CARRAY_H	log_carray.h	27;"	d
LOG_CORE_C	log_core.cpp	62;"	d	file:
LOG_CORE_H	log_core.h	59;"	d
LOG_DIO_ALIGN	logbuf_common.h	28;"	d
LOG_H	log.h	58;"	d
LOG_INSERT	chkpt.cpp	560;"	d	file:
LOG_LSN_TRACKER_H	log_lsn_tracker.h	5;"	d
LOG_RESV_C	log_resv.cpp	62;"	d	file:
LOG_RESV_H	log_resv.h	58;"	d
LOG_STORAGE_C	log_storage.cpp	8;"	d	file:
LOG_STORAGE_H	log_storage.h	58;"	d
LOG_WARN_CALLBACK_FUNC	sm.h	/^    typedef smlevel_0::LOG_WARN_CALLBACK_FUNC LOG_WARN_CALLBACK_FUNC;$/;"	t	class:ss_m
LOG_WARN_CALLBACK_FUNC	sm_base.h	/^    typedef w_rc_t (*LOG_WARN_CALLBACK_FUNC) ($/;"	t	class:smlevel_0
LockState	lock_raw.h	/^    enum LockState {$/;"	g	struct:RawLock
LogArchiver	logarchiver.cpp	/^LogArchiver::LogArchiver($/;"	f	class:LogArchiver
LogArchiver	logarchiver.cpp	/^LogArchiver::LogArchiver(const sm_options& options)$/;"	f	class:LogArchiver
LogArchiver	logarchiver.h	/^class LogArchiver : public smthread_t {$/;"	c
LogConsumer	logarchiver.cpp	/^LogArchiver::LogConsumer::LogConsumer(lsn_t startLSN, size_t blockSize)$/;"	f	class:LogArchiver::LogConsumer
LogConsumer	logarchiver.h	/^    class LogConsumer {$/;"	c	class:LogArchiver
LogScanner	logarchiver.h	/^    LogScanner(size_t blockSize)$/;"	f	class:LogScanner
LogScanner	logarchiver.h	/^class LogScanner {$/;"	c
Lookup	xct.cpp	/^        int Lookup(int vol)$/;"	f	class:VolidCnt
MAX_IN_TRANSIT	bf_transit_bucket.h	/^    enum { MAX_IN_TRANSIT=1 };$/;"	e	enum:transit_bucket_t::__anon1
MAX_LOGREC_SIZE	logarchiver.cpp	/^const size_t LogArchiver::MAX_LOGREC_SIZE = 3 * log_storage::BLOCK_SIZE;$/;"	m	class:LogArchiver	file:
MAX_LOGREC_SIZE	logarchiver.h	/^    const static size_t MAX_LOGREC_SIZE;$/;"	m	class:LogArchiver
MAX_STORE_PER_VOL_XCT	lock_lil.h	/^const uint16_t MAX_STORE_PER_VOL_XCT = 16;$/;"	v
MAX_VOLS	vol.cpp	/^const int vol_m::MAX_VOLS;$/;"	m	class:vol_m	file:
MAX_VOLS	vol.h	/^    static const int MAX_VOLS = 32;$/;"	m	class:vol_m
MAX_VOL_GLOBAL	lock_lil.h	/^const uint16_t MAX_VOL_GLOBAL = vol_m::MAX_VOLS;$/;"	v
MAX_VOL_PER_XCT	lock_lil.h	/^const uint16_t MAX_VOL_PER_XCT = 4;$/;"	v
MEM_MGMT_H	mem_mgmt.h	2;"	d
MM_TEST	mem_mgmt.h	7;"	d
MM_VERIFY	mem_mgmt.cpp	11;"	d	file:
MM_VERIFY	mem_mgmt.cpp	13;"	d	file:
MSEC_IN_DAY	eventlog.h	/^    static const unsigned long MSEC_IN_DAY = 86400000;$/;"	m	class:sysevent_timer
MergeHeapCmp	logarchiver.h	/^        struct MergeHeapCmp {$/;"	s	class:LogArchiver::ArchiveScanner
MergeHeapEntry	logarchiver.cpp	/^LogArchiver::ArchiveScanner::MergeHeapEntry::MergeHeapEntry(RunScanner* runScan)$/;"	f	class:LogArchiver::ArchiveScanner::MergeHeapEntry
MergeHeapEntry	logarchiver.h	/^            MergeHeapEntry() : runScan(NULL) {}$/;"	f	struct:LogArchiver::ArchiveScanner::MergeHeapEntry
MergeHeapEntry	logarchiver.h	/^        struct MergeHeapEntry {$/;"	s	class:LogArchiver::ArchiveScanner
MergerDaemon	logarchiver.cpp	/^LogArchiver::MergerDaemon::MergerDaemon(ArchiveDirectory* in,$/;"	f	class:LogArchiver::MergerDaemon
MergerDaemon	logarchiver.h	/^    class MergerDaemon {$/;"	c	class:LogArchiver
MountPtrHeap	restart.h	/^typedef class Heap<comp_mount_log_t*, CmpMountLsns> MountPtrHeap;$/;"	t	typeref:class:Heap
NDEBUG	mem_mgmt.cpp	6;"	d	file:
NEW_EXT_THRESHOLD	plog_xct.h	/^    enum { NEW_EXT_THRESHOLD = sizeof(logrec_t) };$/;"	e	enum:plog_xct_t::__anon35
NOCHECK_ROOT_LEVEL	btree_impl_verify.cpp	/^const int16_t NOCHECK_ROOT_LEVEL = -1;$/;"	v
NO_LOSER_COUNT	lock_raw.cpp	/^const int NO_LOSER_COUNT = 0;                        \/\/ No more loser transaction in transaction table$/;"	v
NULL_RAW_LOCK	lock_raw.h	/^const MarkablePointer<RawLock> NULL_RAW_LOCK;$/;"	v
NUM_TRANSIT_BUCKETS	bf_transit_bucket.h	/^    static int const          NUM_TRANSIT_BUCKETS = 128;$/;"	m	class:transit_bucket_t
OBSOLETE	lock_raw.h	/^        OBSOLETE,$/;"	e	enum:RawLock::LockState
OFF	sm_base.h	/^        OFF = 0$/;"	e	enum:smlevel_0::switch_t
OKVL_EXPERIMENT	lock_core.cpp	/^bool OKVL_EXPERIMENT = false;$/;"	v
OKVL_INIT_STR_PREFIX_LEN	lock_core.cpp	/^uint32_t OKVL_INIT_STR_PREFIX_LEN = 0;$/;"	v
OKVL_INIT_STR_UNIQUEFIER_LEN	lock_core.cpp	/^uint32_t OKVL_INIT_STR_UNIQUEFIER_LEN = 0;$/;"	v
ON	sm_base.h	/^        ON = 1,$/;"	e	enum:smlevel_0::switch_t
PAGE_ALIAS	page_alias.h	50;"	d
PAGE_ALIAS	page_alias.h	52;"	d
PAGE_ALIAS_FILE	page_alias.h	55;"	d
PAGE_ALIAS_H	page_alias.h	35;"	d
PAGE_ALIAS_LGDATA	page_alias.h	56;"	d
PARTITION_C	partition.cpp	62;"	d	file:
PARTITION_COUNT	log_storage.h	/^enum       { PARTITION_COUNT= smlevel_0::max_openlog };$/;"	e	enum:__anon27
PARTITION_H	partition.h	59;"	d
PLOG_H	plog.h	2;"	d
PLOG_XCT_C	plog_xct.cpp	4;"	d	file:
PLOG_XCT_H	plog_xct.h	2;"	d
PMAP_C	pmap.cpp	39;"	d	file:
PMAP_H	pmap.h	35;"	d
POSIX_MEM_ALIGNMENT	backup.h	/^        POSIX_MEM_ALIGNMENT = 4096,$/;"	e	enum:AlignedMemory::ConstantValue
PROLOGUE_H	prologue.h	58;"	d
PURE_SPIN_RAWLOCK	lock_raw.h	105;"	d
Pmap	pmap.h	/^    inline    Pmap() {$/;"	f	struct:Pmap
Pmap	pmap.h	/^struct Pmap $/;"	s
Pmap_Align4	pmap.h	/^class Pmap_Align4 : public Pmap {$/;"	c
Pmap_Align4	pmap.h	/^typedef    Pmap    Pmap_Align4;$/;"	t
PoorMansOldestLsnTracker	log_lsn_tracker.cpp	/^PoorMansOldestLsnTracker::PoorMansOldestLsnTracker(uint32_t buckets) {$/;"	f	class:PoorMansOldestLsnTracker
PoorMansOldestLsnTracker	log_lsn_tracker.h	/^class PoorMansOldestLsnTracker {$/;"	c
PrintBlockedThread	smthread.cpp	/^                        PrintBlockedThread(ostream& o) : out(o) {};$/;"	f	class:PrintBlockedThread
PrintBlockedThread	smthread.cpp	/^class PrintBlockedThread : public ThreadFunc$/;"	c	file:
PrintSmthreadById	xct.cpp	/^        PrintSmthreadById(ostream& out, int i ) : o(out), _i(0) {$/;"	f	class:PrintSmthreadById
PrintSmthreadById	xct.cpp	/^class PrintSmthreadById : public SmthreadFunc$/;"	c	file:
ProbeResult	logarchiver.cpp	/^typedef LogArchiver::ArchiveIndex::ProbeResult ProbeResult;$/;"	t	file:
ProbeResult	logarchiver.h	/^        struct ProbeResult {$/;"	s	class:LogArchiver::ArchiveIndex
RAW_XCT_LOCK_HASHMAP_SIZE	lock_raw.h	/^const int RAW_XCT_LOCK_HASHMAP_SIZE = 1023;$/;"	v
RELOCATE_RECORD_CALLBACK_FUNC	sm_base.h	/^    typedef w_rc_t (*RELOCATE_RECORD_CALLBACK_FUNC) ($/;"	t	class:smlevel_0
RESTART_C	restart.cpp	60;"	d	file:
RESTART_H	restart.h	35;"	d
RESTORE_H	restore.h	4;"	d
RID_T	sm_s.h	139;"	d
RINGBUFFER_H	ringbuffer.h	2;"	d
RUN_PREFIX	logarchiver.cpp	/^const char* LogArchiver::RUN_PREFIX = "archive_";$/;"	m	class:LogArchiver	file:
RUN_PREFIX	logarchiver.h	/^    const static char* RUN_PREFIX;$/;"	m	class:LogArchiver
RawLock	lock_raw.h	/^struct RawLock : public GcPoolEntry {$/;"	s
RawLockBackgroundThread	lock_raw.cpp	/^RawLockBackgroundThread::RawLockBackgroundThread(const sm_options& options,$/;"	f	class:RawLockBackgroundThread
RawLockBackgroundThread	lock_raw.h	/^class RawLockBackgroundThread {$/;"	c
RawLockCleanerFunctor	lock_core.cpp	/^    RawLockCleanerFunctor(RawLockBackgroundThread* cleaner_arg) : cleaner(cleaner_arg) {}$/;"	f	struct:RawLockCleanerFunctor
RawLockCleanerFunctor	lock_core.cpp	/^struct RawLockCleanerFunctor : public GcWakeupFunctor {$/;"	s	file:
RawLockQueue	lock_raw.h	/^struct RawLockQueue {$/;"	s
RawXct	lock_raw.h	/^struct RawXct : GcPoolEntry {$/;"	s
RawXctLockHashMap	lock_raw.cpp	/^RawXctLockHashMap::RawXctLockHashMap() {$/;"	f	class:RawXctLockHashMap
RawXctLockHashMap	lock_raw.h	/^class RawXctLockHashMap {$/;"	c
ReaderThread	logarchiver.cpp	/^LogArchiver::ReaderThread::ReaderThread(AsyncRingBuffer* readbuf,$/;"	f	class:LogArchiver::ReaderThread
ReaderThread	logarchiver.h	/^    class ReaderThread : public BaseThread {$/;"	c	class:LogArchiver
Request	restore.cpp	/^        Request(char* w, unsigned s, size_t c)$/;"	f	struct:SegmentWriter::Request
Request	restore.cpp	/^    struct Request {$/;"	s	class:SegmentWriter	file:
RestoreBitmap	restore.cpp	/^RestoreBitmap::RestoreBitmap(size_t size)$/;"	f	class:RestoreBitmap
RestoreBitmap	restore.h	/^class RestoreBitmap {$/;"	c
RestoreMgr	restore.cpp	/^RestoreMgr::RestoreMgr(const sm_options& options,$/;"	f	class:RestoreMgr
RestoreMgr	restore.h	/^class RestoreMgr : public smthread_t {$/;"	c
RestoreScheduler	restore.cpp	/^RestoreScheduler::RestoreScheduler(const sm_options& options,$/;"	f	class:RestoreScheduler
RestoreScheduler	restore.h	/^class RestoreScheduler {$/;"	c
RunFileStats	logarchiver.cpp	/^typedef LogArchiver::ArchiveDirectory::RunFileStats RunFileStats;$/;"	t	file:
RunFileStats	logarchiver.h	/^        struct RunFileStats {$/;"	s	class:LogArchiver::ArchiveDirectory
RunInfo	logarchiver.h	/^        struct RunInfo {$/;"	s	class:LogArchiver::ArchiveIndex
RunMerger	logarchiver.h	/^            RunMerger()$/;"	f	struct:LogArchiver::ArchiveScanner::RunMerger
RunMerger	logarchiver.h	/^        struct RunMerger {$/;"	s	class:LogArchiver::ArchiveScanner
RunScanner	logarchiver.cpp	/^LogArchiver::ArchiveScanner::RunScanner::RunScanner(lsn_t b, lsn_t e,$/;"	f	class:LogArchiver::ArchiveScanner::RunScanner
RunScanner	logarchiver.h	/^        struct RunScanner {$/;"	s	class:LogArchiver::ArchiveScanner
SCAN_METHOD_PROLOGUE	prologue.h	97;"	d
SEGMENT_SIZE	log_core.h	/^    enum { SEGMENT_SIZE= 128 * log_storage::BLOCK_SIZE };$/;"	e	enum:log_common::__anon16
SEGMENT_SIZE	log_core.h	/^    enum { SEGMENT_SIZE= 256 * log_storage::BLOCK_SIZE };$/;"	e	enum:log_common::__anon15
SET_TSTAT	smthread.h	513;"	d
SIZEOF_TOGGLE	prologue.h	/^    enum        { SIZEOF_TOGGLE=32 };$/;"	e	enum:prologue_rc_t::__anon38
SKIP_LOGREC	logarchiver.cpp	/^baseLogHeader SKIP_LOGREC;$/;"	v
SLOT_AVAILABLE	log_carray.h	/^        SLOT_AVAILABLE      = 0,$/;"	e	enum:ConsolidationArray::Constants
SLOT_FINISHED	log_carray.h	/^        SLOT_FINISHED       = -4,$/;"	e	enum:ConsolidationArray::Constants
SLOT_FIXED	backup_reader.h	/^    static const int SLOT_FIXED = 3;$/;"	m	class:BackupPrefetcher
SLOT_FREE	backup_reader.h	/^    static const int SLOT_FREE = 0;$/;"	m	class:BackupPrefetcher
SLOT_PENDING	log_carray.h	/^        SLOT_PENDING        = -2,$/;"	e	enum:ConsolidationArray::Constants
SLOT_READING	backup_reader.h	/^    static const int SLOT_READING = 1;$/;"	m	class:BackupPrefetcher
SLOT_UNFIXED	backup_reader.h	/^    static const int SLOT_UNFIXED = 2;$/;"	m	class:BackupPrefetcher
SLOT_UNUSED	log_carray.h	/^        SLOT_UNUSED         = -1,$/;"	e	enum:ConsolidationArray::Constants
SMFILE_C	smfile.cpp	62;"	d	file:
SMINDEX_C	smindex.cpp	8;"	d	file:
SMSTATS_H	smstats.h	35;"	d
SMTHREAD_C	smthread.cpp	10;"	d	file:
SMTHREAD_C	vtable_smthread.cpp	38;"	d	file:
SMTHREAD_H	smthread.h	58;"	d
SM_BASE_H	sm_base.h	58;"	d
SM_C	sm.cpp	62;"	d	file:
SM_DU_STATS_C	sm_du_stats.cpp	38;"	d	file:
SM_DU_STATS_H	sm_du_stats.h	35;"	d
SM_EXTENTSIZE	sm_base.h	115;"	d
SM_EXTENTSIZE_IN_BYTES	pmap.h	108;"	d
SM_EXTERNAL_H	sm_external.h	6;"	d
SM_H	sm.h	58;"	d
SM_LOG_PARTITIONS	sm_base.h	118;"	d
SM_LOG_SPR_H	log_spr.h	2;"	d
SM_LOG_WARN_EXCEED_PERCENT	sm.cpp	131;"	d	file:
SM_OPTIONS_H	sm_options.h	6;"	d
SM_PROLOGUE_RC	prologue.h	77;"	d
SM_SOURCE	alloc_cache.cpp	6;"	d	file:
SM_SOURCE	bf_fixed.cpp	6;"	d	file:
SM_SOURCE	btcursor.cpp	7;"	d	file:
SM_SOURCE	btree.cpp	7;"	d	file:
SM_SOURCE	btree_impl.cpp	12;"	d	file:
SM_SOURCE	btree_impl_defrag.cpp	12;"	d	file:
SM_SOURCE	btree_impl_grow.cpp	12;"	d	file:
SM_SOURCE	btree_impl_lock.cpp	11;"	d	file:
SM_SOURCE	btree_impl_merge.cpp	11;"	d	file:
SM_SOURCE	btree_impl_search.cpp	12;"	d	file:
SM_SOURCE	btree_impl_split.cpp	12;"	d	file:
SM_SOURCE	btree_impl_verify.cpp	11;"	d	file:
SM_SOURCE	btree_logrec.h	15;"	d
SM_SOURCE	btree_page_h.cpp	7;"	d	file:
SM_SOURCE	chkpt.cpp	62;"	d	file:
SM_SOURCE	chkpt_serial.cpp	61;"	d	file:
SM_SOURCE	common_templates.cpp	61;"	d	file:
SM_SOURCE	crash.cpp	43;"	d	file:
SM_SOURCE	eventlog.h	7;"	d
SM_SOURCE	fixable_page_h.cpp	7;"	d	file:
SM_SOURCE	lock.cpp	7;"	d	file:
SM_SOURCE	lock_core.cpp	8;"	d	file:
SM_SOURCE	lock_dump.cpp	8;"	d	file:
SM_SOURCE	lock_lil.cpp	5;"	d	file:
SM_SOURCE	lock_vtable.cpp	8;"	d	file:
SM_SOURCE	lock_x.cpp	6;"	d	file:
SM_SOURCE	log.cpp	61;"	d	file:
SM_SOURCE	log_core.cpp	61;"	d	file:
SM_SOURCE	log_resv.cpp	61;"	d	file:
SM_SOURCE	log_spr.cpp	7;"	d	file:
SM_SOURCE	log_storage.cpp	7;"	d	file:
SM_SOURCE	logarchiver.cpp	3;"	d	file:
SM_SOURCE	logarchiver.h	6;"	d
SM_SOURCE	logbuf_core.cpp	17;"	d	file:
SM_SOURCE	logrec.cpp	9;"	d	file:
SM_SOURCE	logstub.cpp	38;"	d	file:
SM_SOURCE	partition.cpp	61;"	d	file:
SM_SOURCE	plog_xct.cpp	3;"	d	file:
SM_SOURCE	pmap.cpp	38;"	d	file:
SM_SOURCE	restart.cpp	59;"	d	file:
SM_SOURCE	restore.cpp	3;"	d	file:
SM_SOURCE	sm.cpp	61;"	d	file:
SM_SOURCE	sm_du_stats.cpp	46;"	d	file:
SM_SOURCE	sm_s.cpp	61;"	d	file:
SM_SOURCE	smfile.cpp	61;"	d	file:
SM_SOURCE	smindex.cpp	7;"	d	file:
SM_SOURCE	smthread.cpp	9;"	d	file:
SM_SOURCE	stnode_page.cpp	5;"	d	file:
SM_SOURCE	vol.cpp	9;"	d	file:
SM_SOURCE	vtable_sm.cpp	38;"	d	file:
SM_SOURCE	vtable_smthread.cpp	37;"	d	file:
SM_SOURCE	vtable_xct.cpp	38;"	d	file:
SM_SOURCE	xct.cpp	7;"	d	file:
SM_S_H	sm_s.h	58;"	d
SM_VTABLE_ENUM_H	sm_vtable_enum.h	35;"	d
SSM	sm.cpp	/^ss_m* smlevel_top::SSM = 0;$/;"	m	class:smlevel_top	file:
SSM	sm_base.h	/^    static ss_m*    SSM;    \/\/ we will change to lower case later$/;"	m	class:smlevel_0
SSMTEST	crash.h	94;"	d
SSMTEST	crash.h	99;"	d
STATIC_LESS_THAN	btree_page.h	485;"	d
STNODE_PAGE_H	stnode_page.h	6;"	d
SWITCH_DEADLOCK_IMPL	lock_core.h	75;"	d
SWIZZLED_LRU_UPDATE_INTERVAL	bf_tree.cpp	/^const uint32_t SWIZZLED_LRU_UPDATE_INTERVAL = 1000;$/;"	v
SWIZZLED_PID_BIT	bf_tree.h	/^const uint32_t SWIZZLED_PID_BIT = 0x80000000;$/;"	v
SYSDEFS_H	sysdefs.h	35;"	d
SegmentWriter	restore.cpp	/^SegmentWriter::SegmentWriter(RestoreMgr* restore)$/;"	f	class:SegmentWriter
SegmentWriter	restore.cpp	/^class SegmentWriter : public smthread_t {$/;"	c	file:
SelectSmthreadsFunc	smthread.cpp	/^    SelectSmthreadsFunc(SmthreadFunc& func) : f(func) {};$/;"	f	class:SelectSmthreadsFunc
SelectSmthreadsFunc	smthread.cpp	/^class SelectSmthreadsFunc : public ThreadFunc$/;"	c	file:
SmFileMetaStats	sm_du_stats.h	/^class SmFileMetaStats$/;"	c
SmFileMetaStats	sm_du_stats.h	/^inline SmFileMetaStats::SmFileMetaStats()$/;"	f	class:SmFileMetaStats
SmStoreMetaStats	sm_du_stats.h	/^class SmStoreMetaStats$/;"	c
SmStoreMetaStats	sm_du_stats.h	/^inline SmStoreMetaStats::SmStoreMetaStats()$/;"	f	class:SmStoreMetaStats
SmThreadTypes	smthread.h	/^    enum SmThreadTypes     {smThreadType = 1, smLastThreadType};$/;"	g	class:smthread_t
SmVolumeMetaStats	sm_du_stats.h	/^class SmVolumeMetaStats$/;"	c
SmVolumeMetaStats	sm_du_stats.h	/^inline SmVolumeMetaStats::SmVolumeMetaStats()$/;"	f	class:SmVolumeMetaStats
SmthreadFunc	smthread.h	/^class SmthreadFunc {$/;"	c
SprScratchSpace	btree_logrec.h	/^    SprScratchSpace(vid_t vol, snum_t store, shpid_t pid) {$/;"	f	struct:SprScratchSpace
SprScratchSpace	btree_logrec.h	/^struct SprScratchSpace {$/;"	s
TL_stats	smthread.h	/^        inline sm_stats_info_t& TL_stats() { return *_TL_stats;}$/;"	f	struct:smthread_t::tcb_t
TL_stats	smthread.h	/^    inline sm_stats_info_t& TL_stats() { $/;"	f	class:smthread_t
TL_stats_const	smthread.h	/^        inline const sm_stats_info_t& TL_stats_const() const { $/;"	f	struct:smthread_t::tcb_t
UNCOMMITTED	plog.h	/^        UNCOMMITTED = 0x01,$/;"	e	enum:plog_t::state_t
UNDO_FUDGE_FACTOR	xct.cpp	59;"	d	file:
UNSWIZZLE_BATCH_SIZE	bf_tree.h	/^const uint32_t UNSWIZZLE_BATCH_SIZE = 1000;$/;"	v
UNUSED	lock_raw.h	/^        UNUSED = 0,$/;"	e	enum:RawLock::LockState
UNUSED	lock_raw.h	/^        UNUSED = 0,$/;"	e	enum:RawXct::XctState
USE_TLS_ALLOCATOR	sm_base.h	592;"	d
VOIDSSMTEST	crash.h	100;"	d
VOIDSSMTEST	crash.h	95;"	d
VOL_C	vol.cpp	10;"	d	file:
VOL_H	vol.h	6;"	d
VTABLE_SM_C	vtable_sm.cpp	39;"	d	file:
VolidCnt	xct.cpp	/^        VolidCnt() : unique_vols(0) {};$/;"	f	class:VolidCnt
VolidCnt	xct.cpp	/^class VolidCnt {$/;"	c	file:
WAITING	lock_raw.h	/^        WAITING,$/;"	e	enum:RawLock::LockState
WAITING	lock_raw.h	/^        WAITING,$/;"	e	enum:RawXct::XctState
WAIT_FOREVER	smthread.h	/^    WAIT_FOREVER = sthread_t::WAIT_FOREVER,$/;"	e	enum:special_timeout_in_ms_t
WAIT_IMMEDIATE	smthread.h	/^    WAIT_IMMEDIATE = sthread_t::WAIT_IMMEDIATE,$/;"	e	enum:special_timeout_in_ms_t
WAIT_SPECIFIED_BY_THREAD	smthread.h	/^    WAIT_SPECIFIED_BY_THREAD = sthread_t::WAIT_SPECIFIED_BY_THREAD$/;"	e	enum:special_timeout_in_ms_t
WAIT_SPECIFIED_BY_XCT	smthread.h	/^    WAIT_SPECIFIED_BY_XCT = sthread_t::WAIT_SPECIFIED_BY_XCT,$/;"	e	enum:special_timeout_in_ms_t
WAIT_TIME	backup_reader.cpp	/^const unsigned WAIT_TIME = 500;$/;"	v
WarmupThread	bf_tree.h	/^    WarmupThread() {};$/;"	f	class:WarmupThread
WarmupThread	bf_tree.h	/^class WarmupThread : public smthread_t {$/;"	c
WriterThread	logarchiver.h	/^        WriterThread(AsyncRingBuffer* writebuf, ArchiveDirectory* directory)$/;"	f	class:LogArchiver::WriterThread
WriterThread	logarchiver.h	/^    class WriterThread : public BaseThread {$/;"	c	class:LogArchiver
XCT_C	vtable_xct.cpp	39;"	d	file:
XCT_C	xct.cpp	8;"	d	file:
XCT_DEPENDENT_H	xct_dependent.h	35;"	d
XCT_H	xct.h	58;"	d
XCT_LOCK_HASHMAP_SIZE	lock_x.h	/^const int XCT_LOCK_HASHMAP_SIZE = 1023;$/;"	v
XCT_PLOG	sm_base.h	/^        XCT_PLOG = 1$/;"	e	enum:smlevel_0::xct_impl_t
XCT_TRADITIONAL	sm_base.h	/^        XCT_TRADITIONAL = 0,$/;"	e	enum:smlevel_0::xct_impl_t
XFERSIZE	partition.h	/^    enum { XFERSIZE = 8192 };$/;"	e	enum:partition_t::__anon30
XFERSIZE	partition.h	/^    enum { XFERSIZE = 8192 };$/;"	e	enum:partition_t::__anon31
X_DO	xct.h	967;"	d
X_DO	xct.h	971;"	d
X_DO1	xct.h	956;"	d
X_LOG_COMMENT_ON	xct.h	69;"	d
X_LOG_COMMENT_ON	xct.h	76;"	d
X_LOG_COMMENT_USE	xct.h	72;"	d
X_LOG_COMMENT_USE	xct.h	79;"	d
X_to_string	xct.h	966;"	d
XctLockHashMap	lock_x.cpp	/^XctLockHashMap::XctLockHashMap() {$/;"	f	class:XctLockHashMap
XctLockHashMap	lock_x.h	/^class XctLockHashMap {$/;"	c
XctLockHeap	chkpt.h	/^typedef class Heap<comp_lock_info_t*, CmpXctLockTids> XctLockHeap;$/;"	t	typeref:class:Heap
XctLockHeap	restart.h	/^typedef class Heap<comp_lock_info_t*, CmpXctLockTids> XctLockHeap;$/;"	t	typeref:class:Heap
XctPtrHeap	restart.h	/^typedef class Heap<xct_t*, CmpXctUndoLsns> XctPtrHeap;$/;"	t	typeref:class:Heap
XctState	lock_raw.h	/^    enum XctState {$/;"	g	struct:RawXct
_1thread_log	xct.h	/^    mutable queue_based_lock_t   _1thread_log;$/;"	m	class:xct_t
_1thread_xct	xct.h	/^        queue_based_lock_t     _1thread_xct;$/;"	m	struct:xct_t::xct_core
_1thread_xct_me	smthread.h	/^        queue_based_lock_t::ext_qnode _1thread_xct_me;$/;"	m	struct:smthread_t::tcb_t
_IS_count	lock_lil.h	/^    uint16_t  _IS_count;  \/\/ +2 -> 2$/;"	m	class:lil_global_table_base
_IX_count	lock_lil.h	/^    uint16_t  _IX_count;  \/\/ +2 -> 4$/;"	m	class:lil_global_table_base
_KEY_RANGES_MAP_H	key_ranges_map.h	44;"	d
_Q_ticket	fixable_page_h.h	/^    q_ticket_t    _Q_ticket;$/;"	m	class:fixable_page_h
_SLASH	log_storage.cpp	/^const char log_storage::_SLASH = '\/';$/;"	m	class:log_storage	file:
_SLASH	log_storage.h	/^    static const char    _SLASH;$/;"	m	class:log_storage
_S_count	lock_lil.h	/^    uint16_t  _S_count;   \/\/ +2 -> 6$/;"	m	class:lil_global_table_base
_TL_stats	smthread.h	/^        sm_stats_info_t*  _TL_stats; \/\/ thread-local stats$/;"	m	struct:smthread_t::tcb_t
_X_taken	lock_lil.h	/^    bool      _X_taken;   \/\/ +1 -> 7$/;"	m	class:lil_global_table_base
__saved_lockid_t	xct.h	/^    lockid_t*                    __saved_lockid_t;$/;"	m	class:xct_t
__saved_xct_log_t	xct.h	/^    xct_log_t*                   __saved_xct_log_t;$/;"	m	class:xct_t
__stats	xct.h	/^    sm_stats_info_t*             __stats; \/\/ allocated by user$/;"	m	class:xct_t
__toggle_data	prologue.h	/^    long        __toggle_data[SIZEOF_TOGGLE\/sizeof(long)];$/;"	m	class:prologue_rc_t
_abort	plog_xct.cpp	/^rc_t plog_xct_t::_abort()$/;"	f	class:plog_xct_t
_abort	xct.cpp	/^xct_t::_abort()$/;"	f	class:xct_t
_abort_xct	sm.cpp	/^ss_m::_abort_xct(sm_stats_info_t*&             _stats)$/;"	f	class:ss_m
_acquire_buffer_space	log_core.cpp	/^void log_core::_acquire_buffer_space(CArraySlot* info, long recsize)$/;"	f	class:log_core
_acquire_buffer_space	logbuf_core.cpp	/^void logbuf_core::_acquire_buffer_space(CArraySlot* info, long recsize) {$/;"	f	class:logbuf_core
_active_slot_count	log_carray.h	/^    const int32_t       _active_slot_count;$/;"	m	class:ConsolidationArray
_active_slots	log_carray.h	/^    CArraySlot**        _active_slots;$/;"	m	class:ConsolidationArray
_actual_segsize	logbuf_core.h	/^    uint32_t _actual_segsize;  \/\/ in-memory segment size (with tails)$/;"	m	class:logbuf_core
_add_free_block	bf_tree_evict.cpp	/^void bf_tree_m::_add_free_block(bf_idx idx)$/;"	f	class:bf_tree_m
_advance_one_slot	btcursor.cpp	/^rc_t bt_cursor_t::_advance_one_slot(btree_page_h &p, bool &eof)$/;"	f	class:bt_cursor_t
_all_slots	log_carray.h	/^    CArraySlot          _all_slots[ALL_SLOT_COUNT];$/;"	m	class:ConsolidationArray
_alloc	mem_mgmt.h	/^    size_t _alloc;$/;"	m	class:fixed_lists_mem_t
_alloc_cache	vol.h	/^    alloc_cache_t*   _alloc_cache;$/;"	m	class:vol_t
_alloc_size	plog.h	/^    uint32_t    _alloc_size;$/;"	m	class:plog_t
_analysis_acquire_ckpt_lock_log	restart.cpp	/^void restart_m::_analysis_acquire_ckpt_lock_log(logrec_t& r,            \/\/ In: log record$/;"	f	class:restart_m
_analysis_acquire_lock_log	restart.cpp	/^void restart_m::_analysis_acquire_lock_log(logrec_t& r,            \/\/ In: log record$/;"	f	class:restart_m
_analysis_ckpt_bf_log	restart.cpp	/^void restart_m::_analysis_ckpt_bf_log(logrec_t& r,              \/\/ In: Log record to process$/;"	f	class:restart_m
_analysis_ckpt_xct_log	restart.cpp	/^void restart_m::_analysis_ckpt_xct_log(logrec_t& r,          \/\/ In: Current log record$/;"	f	class:restart_m
_analysis_other_log	restart.cpp	/^void restart_m::_analysis_other_log(logrec_t& r,               \/\/ In: log record$/;"	f	class:restart_m
_analysis_process_compensation_map	restart.cpp	/^void restart_m::_analysis_process_compensation_map($/;"	f	class:restart_m
_analysis_process_lock	restart.cpp	/^void restart_m::_analysis_process_lock(logrec_t& r,            \/\/ In: Current log record$/;"	f	class:restart_m
_analysis_process_txn_table	restart.cpp	/^void restart_m::_analysis_process_txn_table(XctPtrHeap& heap,  \/\/ Out: heap to store all in-flight transactions$/;"	f	class:restart_m
_analysis_system_log	restart.cpp	/^bool restart_m::_analysis_system_log(logrec_t& r,             \/\/ In: Log record to process$/;"	f	class:restart_m
_anchor	xct.h	/^    lsn_t                       _anchor; \/\/ the anchor for the outermost compensated op$/;"	m	class:xct_t
_apply_fake_disk_latency	vol.h	/^    bool             _apply_fake_disk_latency;$/;"	m	class:vol_t
_apply_spr_logs	log_spr.cpp	/^rc_t restart_m::_apply_spr_logs(fixable_page_h &p, char* buffer, size_t bufsize)$/;"	f	class:restart_m
_are_there_many_swizzled_pages	bf_tree.cpp	/^bool bf_tree_m::_are_there_many_swizzled_pages() const {$/;"	f	class:bf_tree_m
_arg	smthread.h	/^    void* const        _arg;$/;"	m	class:smthread_t
_artificial_flush_delay	partition.cpp	/^int partition_t::_artificial_flush_delay = 0;$/;"	m	class:partition_t	file:
_artificial_flush_delay	partition.h	/^    static int            _artificial_flush_delay;  \/\/ in microseconds$/;"	m	class:partition_t
_backup_fd	vol.h	/^    int _backup_fd;$/;"	m	class:vol_t
_backup_folder	backup.h	/^    std::string _backup_folder;$/;"	m	class:BackupManager
_backup_lsns	vol.h	/^    std::vector<lsn_t> _backup_lsns;$/;"	m	class:vol_t
_backup_write_fd	vol.h	/^    int _backup_write_fd;$/;"	m	class:vol_t
_backup_write_path	vol.h	/^    string _backup_write_path;$/;"	m	class:vol_t
_backups	vol.h	/^    std::vector<string> _backups;$/;"	m	class:vol_t
_begin_xct	sm.cpp	/^ss_m::_begin_xct(sm_stats_info_t *_stats, tid_t& tid, timeout_in_ms timeout, bool sys_xct,$/;"	f	class:ss_m
_begin_xct_mutex	sm.cpp	/^static srwlock_t          _begin_xct_mutex;$/;"	v	file:
_bf_pause_swizzling	bf_tree.cpp	/^bool bf_tree_m::_bf_pause_swizzling = true;$/;"	m	class:bf_tree_m	file:
_bf_pause_swizzling	bf_tree.h	/^    static bool _bf_pause_swizzling; \/\/ this can be turned on\/off from any place. ugly, but it's just for an experiment.$/;"	m	class:bf_tree_m
_bf_pause_swizzling	bf_tree.h	/^const bool _bf_pause_swizzling = false; \/\/ compiler will strip this out from if clauses. so, no overhead.$/;"	v
_bf_swizzle_ex	bf_tree.cpp	/^uint64_t bf_tree_m::_bf_swizzle_ex = 0;$/;"	m	class:bf_tree_m	file:
_bf_swizzle_ex	bf_tree.h	/^    static uint64_t _bf_swizzle_ex; \/\/ approximate statistics. how many times ex-latch were taken on page swizzling$/;"	m	class:bf_tree_m
_bf_swizzle_ex_fails	bf_tree.cpp	/^uint64_t bf_tree_m::_bf_swizzle_ex_fails = 0;$/;"	m	class:bf_tree_m	file:
_bf_swizzle_ex_fails	bf_tree.h	/^    static uint64_t _bf_swizzle_ex_fails; \/\/ approximate statistics. how many times ex-latch upgrade failed on page swizzling$/;"	m	class:bf_tree_m
_bitmap	btree_verify.h	/^    char *_bitmap;$/;"	m	class:verification_context
_bitmap_size	btree_verify.h	/^    int _bitmap_size;$/;"	m	class:verification_context
_block	partition.cpp	/^    char _block[log_storage::BLOCK_SIZE];$/;"	m	class:block_of_zeroes	file:
_block_cnt	bf_tree.h	/^    bf_idx               _block_cnt;$/;"	m	class:bf_tree_m
_block_size	logbuf_core.h	/^    uint32_t _block_size;  \/\/ log block size$/;"	m	class:logbuf_core
_bool_options	sm_options.h	/^    std::map<std::string, bool> _bool_options;$/;"	m	class:sm_options
_btree_level	btree_logrec.h	/^    int16_t     _btree_level;                 \/\/ +2   => 22$/;"	m	struct:btree_norec_alloc_t
_bucket_id	lock_raw.h	/^    static uint32_t _bucket_id(uint32_t lock_id) { return lock_id % RAW_XCT_LOCK_HASHMAP_SIZE; }$/;"	f	class:RawXctLockHashMap
_bucket_id	lock_x.h	/^    static uint32_t _bucket_id(uint32_t lock_id) { return lock_id % XCT_LOCK_HASHMAP_SIZE; }$/;"	f	class:XctLockHashMap
_buckets	lock_raw.h	/^    RawLock*                    _buckets[RAW_XCT_LOCK_HASHMAP_SIZE];$/;"	m	class:RawXctLockHashMap
_buckets	lock_x.h	/^    xct_lock_entry_t*           _buckets[XCT_LOCK_HASHMAP_SIZE];$/;"	m	class:XctLockHashMap
_buckets	log_lsn_tracker.h	/^    uint32_t            _buckets;$/;"	m	class:PoorMansOldestLsnTracker
_buf	log_core.h	/^    char*                _buf; \/\/ log buffer: _segsize buffer into which$/;"	m	class:log_core
_buf	mem_mgmt.h	/^    char * _buf;$/;"	m	class:fixed_lists_mem_t
_buf_epoch	log_core.h	/^    epoch                _buf_epoch;$/;"	m	class:log_common
_buffer	backup.h	/^    char*   _buffer;$/;"	m	class:AlignedMemory
_buffer	bf_tree.h	/^    generic_page*              _buffer;$/;"	m	class:bf_tree_m
_bufferpool	bf_tree_cleaner.h	/^    bf_tree_m*                  _bufferpool;$/;"	m	class:bf_tree_cleaner
_bufferpool_managed	fixable_page_h.h	/^    bool          _bufferpool_managed; \/\/\/< is our associated page managed by the buffer pool?$/;"	m	class:fixable_page_h
_bufsize	mem_mgmt.h	/^    size_t _bufsize;$/;"	m	class:fixed_lists_mem_t
_cache	log_lsn_tracker.h	/^    lsn_t               _cache;$/;"	m	class:PoorMansOldestLsnTracker
_candidates_buffer	bf_tree_cleaner.h	/^    std::vector<std::vector<bf_idx> >         _candidates_buffer;$/;"	m	class:bf_tree_cleaner_slave_thread_t
_carray	log_core.h	/^    ConsolidationArray*  _carray;$/;"	m	class:log_common
_cat	logrec.h	/^    u_char             _cat;  \/\/ category_t$/;"	m	struct:baseLogHeader
_ceil	log_storage.h	/^    static long         _ceil(long offset, long block_size)$/;"	f	class:log_storage
_ceil	logbuf_core.h	/^    static long         _ceil(long offset, long block_size) $/;"	f	class:logbuf_core
_chain_high_len	btree_logrec.h	/^    uint16_t        _chain_high_len;     \/\/ +2 => 16, chain_high key length$/;"	m	struct:btree_foster_merge_t
_chain_high_len	btree_logrec.h	/^    uint16_t        _chain_high_len;     \/\/ +2 => 22, chain_high key length$/;"	m	struct:btree_foster_rebalance_t
_chain_high_len	btree_logrec.h	/^    uint16_t    _fence_len, _chain_high_len;  \/\/ +2+2 => 20$/;"	m	struct:btree_norec_alloc_t
_chain_xct	sm.cpp	/^ss_m::_chain_xct($/;"	f	class:ss_m
_check	xct.h	/^    void _check(bool b) const  {$/;"	f	class:xct_i
_check_compatible	lock_bucket.h	/^inline bool lock_queue_t::_check_compatible(const okvl_mode& granted_mode,$/;"	f	class:lock_queue_t
_check_page_update	btcursor.cpp	/^rc_t bt_cursor_t::_check_page_update(btree_page_h &p)$/;"	f	class:bt_cursor_t
_check_read_page	bf_tree.cpp	/^w_rc_t bf_tree_m::_check_read_page(generic_page* parent, generic_page* page,$/;"	f	class:bf_tree_m
_check_space_for_insert	btree_page_h.cpp	/^bool btree_page_h::_check_space_for_insert(size_t data_length) {$/;"	f	class:btree_page_h
_check_version	log_storage.cpp	/^rc_t log_storage::_check_version(uint32_t major, uint32_t minor)$/;"	f	class:log_storage
_checkpoint_lock	bf_fixed.h	/^    srwlock_t   _checkpoint_lock;$/;"	m	class:bf_fixed_m
_child	btree_page_h.h	/^    shpid_t         _child;  \/\/ opaque pointer$/;"	m	class:btrec_t
_child_emlsn	btree_page_h.h	/^    lsn_t           _child_emlsn;$/;"	m	class:btrec_t
_child_lsn	log_spr.h	/^    lsn_t                   _child_lsn;$/;"	m	struct:page_evict_t
_child_slot	log_spr.h	/^    general_recordid_t      _child_slot;$/;"	m	struct:page_evict_t
_chkpt_count	chkpt.h	/^    long             _chkpt_count;$/;"	m	class:chkpt_m
_chkpt_current	chkpt.h	/^    chkpt_t*         _chkpt_current;$/;"	m	class:chkpt_m
_chkpt_mutex	chkpt_serial.cpp	/^static occ_rwlock _chkpt_mutex;$/;"	v	file:
_chkpt_thread	chkpt.h	/^    chkpt_thread_t*  _chkpt_thread;$/;"	m	class:chkpt_m
_chunk	bf_hashtable.cpp	/^    bf_hashbucket_chunk<T>         _chunk;$/;"	m	class:bf_hashbucket	file:
_chunk	logbuf_hashtable.cpp	/^    logbuf_hashbucket_chunk         _chunk;$/;"	m	class:logbuf_hashbucket	file:
_clean_volume	bf_tree_cleaner.cpp	/^w_rc_t bf_tree_cleaner_slave_thread_t::_clean_volume($/;"	f	class:bf_tree_cleaner_slave_thread_t
_cleaner	bf_tree.h	/^    bf_tree_cleaner*     _cleaner;$/;"	m	class:bf_tree_m
_cleaner_interval_millisec_max	bf_tree_cleaner.h	/^    const uint32_t _cleaner_interval_millisec_max;$/;"	m	class:bf_tree_cleaner
_cleaner_interval_millisec_min	bf_tree_cleaner.h	/^    const uint32_t _cleaner_interval_millisec_min;$/;"	m	class:bf_tree_cleaner
_cleaner_write_buffer_pages	bf_tree_cleaner.h	/^    const uint32_t _cleaner_write_buffer_pages;$/;"	m	class:bf_tree_cleaner
_close_min	log_storage.cpp	/^log_storage::_close_min(partition_number_t n)$/;"	f	class:log_storage
_clr_state	partition.h	/^    void               _clr_state(uint32_t m) { _mask &= ~m ; }$/;"	f	class:partition_t
_collect_spr_logs	log_spr.cpp	/^rc_t restart_m::_collect_spr_logs($/;"	f	class:restart_m
_commit	plog_xct.h	/^    virtual rc_t _commit(uint32_t flags, lsn_t* plastlsn=NULL)$/;"	f	class:plog_xct_t
_commit	xct.cpp	/^xct_t::_commit(uint32_t flags, lsn_t* plastlsn \/* default NULL*\/)$/;"	f	class:xct_t
_commit_lsn	lock_x.h	/^    lsn_t     _commit_lsn;$/;"	m	class:xct_lock_info_t
_commit_nochains	plog_xct.cpp	/^rc_t plog_xct_t::_commit_nochains(uint32_t flags, lsn_t* \/* plastlsn *\/)$/;"	f	class:plog_xct_t
_commit_read_only	xct.cpp	/^xct_t::_commit_read_only(uint32_t flags, lsn_t& inherited_read_watermark)$/;"	f	class:xct_t
_commit_xct	sm.cpp	/^ss_m::_commit_xct(sm_stats_info_t*& _stats, bool lazy,$/;"	f	class:ss_m
_commit_xct_group	sm.cpp	/^ss_m::_commit_xct_group(xct_t *list[], int listlen)$/;"	f	class:ss_m
_comp_lock	log_core.h	/^    tatas_lock           _comp_lock;$/;"	m	class:log_common
_compare_key_noprefix	btree_page_h.h	/^inline int btree_page_h::_compare_key_noprefix(slotid_t slot, const void *key_noprefix,$/;"	f	class:btree_page_h
_compare_lock_entries	restart.cpp	/^void restart_m::_compare_lock_entries($/;"	f	class:restart_m
_compare_slot_with_key	btree_page_h.cpp	/^inline int btree_page_h::_compare_slot_with_key(int slot, const void* key_noprefix, size_t key_len, poor_man_key key_poor) const {$/;"	f	class:btree_page_h
_compensate	xct.cpp	/^xct_t::_compensate(const lsn_t& lsn, bool undoable)$/;"	f	class:xct_t
_compensate	xct.h	/^    bool _compensate;$/;"	m	class:auto_release_anchor_t
_completed_lsn	bf_tree_cleaner.h	/^    lsndata_t _completed_lsn;$/;"	m	class:bf_tree_cleaner_slave_thread_t
_concurrent_swizzling	bf_tree_cb.h	/^    bool                        _concurrent_swizzling;      \/\/ +1 -> 30$/;"	m	struct:bf_tree_cb_t
_cond_timedwait	bf_tree_cleaner.cpp	/^bool bf_tree_cleaner_slave_thread_t::_cond_timedwait (uint64_t timeout_microsec) {$/;"	f	class:bf_tree_cleaner_slave_thread_t
_cond_timedwait	lock_lil.cpp	/^bool lil_global_table_base::_cond_timedwait (uint32_t base_version, uint32_t timeout_microsec) {$/;"	f	class:lil_global_table_base
_constraint	prologue.h	/^    xct_constraint_t  _constraint;$/;"	m	class:prologue_rc_t
_construct_once	sm.cpp	/^ss_m::_construct_once()$/;"	f	class:ss_m
_contiguous_free_pages_begin	alloc_cache.h	/^    shpid_t _contiguous_free_pages_begin;$/;"	m	class:alloc_cache_t
_contiguous_free_pages_end	alloc_cache.h	/^    shpid_t _contiguous_free_pages_end;$/;"	m	class:alloc_cache_t
_control_blocks	bf_tree.h	/^    bf_tree_cb_t*        _control_blocks;$/;"	m	class:bf_tree_m
_convert_timeout	lock.cpp	/^timeout_in_ms lock_m::_convert_timeout(timeout_in_ms timeout) {$/;"	f	class:lock_m
_convert_timeout	lock.cpp	/^timeout_in_ms lock_m::_convert_timeout(timeout_in_ms timeout, xct_t* xd) {$/;"	f	class:lock_m
_convert_to_disk_page	bf_tree.cpp	/^void bf_tree_m::_convert_to_disk_page(generic_page* page) const {$/;"	f	class:bf_tree_m
_convert_to_pageid	bf_tree.cpp	/^void bf_tree_m::_convert_to_pageid (shpid_t* shpid) const {$/;"	f	class:bf_tree_m
_copy_raw	log_core.cpp	/^void log_core::_copy_raw(CArraySlot* info, long& pos, const char* data,$/;"	f	class:log_core
_copy_to_buffer	log_core.cpp	/^lsn_t log_core::_copy_to_buffer(logrec_t &rec, long pos, long recsize, CArraySlot* info)$/;"	f	class:log_core
_copy_to_buffer	logbuf_core.cpp	/^lsn_t logbuf_core::_copy_to_buffer($/;"	f	class:logbuf_core
_core	lock.h	/^    lock_core_m*                _core;$/;"	m	class:lock_m
_core	xct.h	/^    xct_core* _core;$/;"	m	class:xct_t
_count	pmap.h	/^    enum    { _count = smlevel_0::ext_sz };$/;"	e	enum:Pmap::__anon36
_count	xct.cpp	/^int auto_rollback_t::_count = 0;$/;"	m	class:auto_rollback_t	file:
_count	xct.h	/^    static int _count;$/;"	m	class:auto_rollback_t
_counter_approximate	bf_tree_cb.h	/^    uint16_t                    _counter_approximate;\/\/ +2  -> 16$/;"	m	struct:bf_tree_cb_t
_create_master_chkpt_contents	log_storage.cpp	/^void log_storage::_create_master_chkpt_contents($/;"	f	class:log_storage
_create_master_chkpt_string	log_storage.cpp	/^void log_storage::_create_master_chkpt_string($/;"	f	class:log_storage
_cur_epoch	log_core.h	/^    epoch                _cur_epoch;$/;"	m	class:log_common
_curr_index	log_storage.h	/^    partition_index_t   _curr_index; \/\/ index of partition$/;"	m	class:log_storage
_curr_lsn	log_core.h	/^    lsn_t           _curr_lsn;$/;"	m	class:log_common
_curr_num	log_storage.h	/^    partition_number_t  _curr_num;   \/\/ partition number$/;"	m	class:log_storage
_current_backup_lsn	vol.h	/^    lsn_t _current_backup_lsn;$/;"	m	class:vol_t
_data	btree_logrec.h	/^    char            _data[logrec_t::max_data_sz - sizeof(multi_page_log_t) - 24];$/;"	m	struct:btree_foster_merge_t
_data	btree_logrec.h	/^    char            _data[logrec_t::max_data_sz - sizeof(multi_page_log_t) - 26];$/;"	m	struct:btree_foster_rebalance_t
_data	btree_logrec.h	/^    char          _data[logrec_t::max_data_sz - sizeof(multi_page_log_t) - 2];$/;"	m	struct:btree_foster_rebalance_norec_t
_data	btree_logrec.h	/^    char        _data[logrec_t::max_data_sz - sizeof(multi_page_log_t) + 20];$/;"	m	struct:btree_foster_deadopt_t
_data	btree_logrec.h	/^    char        _data[logrec_t::max_data_sz - sizeof(multi_page_log_t) - 22];$/;"	m	struct:btree_norec_alloc_t
_data	btree_logrec.h	/^    char        _data[logrec_t::max_data_sz - sizeof(shpid_t) - 3*sizeof(int16_t)];$/;"	m	struct:btree_overwrite_t
_data	btree_logrec.h	/^    char        _data[logrec_t::max_data_sz - sizeof(shpid_t) - 3*sizeof(int16_t)];$/;"	m	struct:btree_update_t
_data	btree_logrec.h	/^    char    _data[logrec_t::max_data_sz - sizeof(multi_page_log_t) - 14];$/;"	m	struct:btree_foster_adopt_t
_data	btree_logrec.h	/^    char _data[logrec_t::max_data_sz - fields_sz];$/;"	m	struct:btree_bulk_delete_t
_data	logrec.h	/^    char            _data[max_sz - sizeof(baseLogHeader) - sizeof(xidChainLogHeader)];$/;"	m	class:logrec_t
_deadopted_emlsn	btree_logrec.h	/^    lsn_t       _deadopted_emlsn;       \/\/ +8$/;"	m	struct:btree_foster_deadopt_t
_deadopted_pid	btree_logrec.h	/^    shpid_t     _deadopted_pid;         \/\/ +4$/;"	m	struct:btree_foster_deadopt_t
_debuginfo	crash.cpp	/^struct debuginfo _debuginfo = {$/;"	v	typeref:struct:debuginfo	file:
_deferred_ssx	xct.h	/^    bool                         _deferred_ssx;$/;"	m	class:xct_t
_delete_block	bf_tree.cpp	/^void bf_tree_m::_delete_block(bf_idx idx) {$/;"	f	class:bf_tree_m
_dependency_idx	bf_tree_cb.h	/^    bf_idx _dependency_idx;\/\/ +4 -> 36$/;"	m	struct:bf_tree_cb_t
_dependency_lsn	bf_tree_cb.h	/^    lsndata_t _dependency_lsn;\/\/ +8 -> 48$/;"	m	struct:bf_tree_cb_t
_dependency_shpid	bf_tree_cb.h	/^    shpid_t _dependency_shpid;\/\/ +4 -> 40$/;"	m	struct:bf_tree_cb_t
_dependent_list	xct.h	/^    w_list_t<xct_dependent_t,queue_based_lock_t>    _dependent_list;$/;"	m	class:xct_t
_depth	sm_base.h	/^    int _depth;$/;"	m	struct:check_compensated_op_nesting
_depth	smthread.h	/^        int16_t  _depth; \/\/ how many "outer" this has$/;"	m	struct:smthread_t::tcb_t
_destruct_once	sm.cpp	/^ss_m::_destruct_once()$/;"	f	class:ss_m
_devname	vol.h	/^    char             _devname[smlevel_0::max_devname];$/;"	m	class:vol_t
_dirty	bf_tree_cb.h	/^    bool _dirty;         \/\/ +1  -> 1$/;"	m	struct:bf_tree_cb_t
_dirty_flags	bf_fixed.h	/^    bool*       _dirty_flags;$/;"	m	class:bf_fixed_m
_dirty_page_count_approximate	bf_tree.h	/^    int32_t              _dirty_page_count_approximate;$/;"	m	class:bf_tree_m
_dirty_shutdown_happening	bf_tree_cleaner.cpp	/^bool _dirty_shutdown_happening() {$/;"	f
_do_restart	sm.cpp	/^void ss_m::_do_restart()$/;"	f	class:ss_m
_do_work	bf_tree_cleaner.cpp	/^w_rc_t bf_tree_cleaner_slave_thread_t::_do_work()$/;"	f	class:bf_tree_cleaner_slave_thread_t
_dont_move_next	btcursor.h	/^    bool        _dont_move_next;$/;"	m	class:bt_cursor_t
_dummy1	lock_lil.h	/^    bool      _dummy1;    \/\/ +1 -> 8$/;"	m	class:lil_global_table_base
_dummy_lsn_lock	lock_raw.h	/^    int             _dummy_lsn_lock;$/;"	m	class:RawLockBackgroundThread
_dummy_lsn_xct	lock_raw.h	/^    int             _dummy_lsn_xct;$/;"	m	class:RawLockBackgroundThread
_dump	smthread.cpp	/^smthread_t::_dump(ostream &o) const$/;"	f	class:smthread_t
_durable_lsn	log_core.h	/^    lsn_t           _durable_lsn;$/;"	m	class:log_common
_elbuf	btcursor.h	/^    char        _elbuf [SM_PAGESIZE];$/;"	m	class:bt_cursor_t
_elem	btree_page_h.h	/^    cvec_t          _elem;$/;"	m	class:btrec_t
_element_offset	btree_page_h.h	/^inline size_t btree_page_h::_element_offset(int slot) const {$/;"	f	class:btree_page_h
_elen	btcursor.h	/^    smsize_t    _elen;$/;"	m	class:bt_cursor_t
_elen	btree_logrec.h	/^    uint16_t    _elen;$/;"	m	struct:btree_overwrite_t
_elr_mode	xct.h	/^    elr_mode_t                   _elr_mode;$/;"	m	class:xct_t
_enable_swizzling	bf_tree.h	/^    bool                 _enable_swizzling;$/;"	m	class:bf_tree_m
_end	log_core.h	/^    long _end; \/\/ byte number of insertion point$/;"	m	class:log_common
_eof	btcursor.h	/^    bool        _eof;$/;"	m	class:bt_cursor_t
_eop	partition.h	/^    fileoff_t             _eop; $/;"	m	class:partition_t
_error_happened	bf_tree_cleaner.h	/^    bool                        _error_happened;$/;"	m	class:bf_tree_cleaner
_error_on_start	xct.h	/^    rc_t   _error_on_start;$/;"	m	class:sys_xct_section_t
_eviction_current_frame	bf_tree.h	/^    bf_idx _eviction_current_frame;$/;"	m	class:bf_tree_m
_eviction_lock	bf_tree.h	/^    pthread_mutex_t _eviction_lock;$/;"	m	class:bf_tree_m
_ex_lock	btcursor.h	/^    bool        _ex_lock;$/;"	m	class:bt_cursor_t
_exists_requested_work	bf_tree_cleaner.cpp	/^bool bf_tree_cleaner_slave_thread_t::_exists_requested_work()$/;"	f	class:bf_tree_cleaner_slave_thread_t
_expose_lock	log_carray.h	/^    mcs_lock            _expose_lock;$/;"	m	class:ConsolidationArray
_extract_poor_man_key	btree_page_h.h	/^btree_page_h::_extract_poor_man_key(const void* key_with_prefix, size_t key_len_with_prefix,$/;"	f	class:btree_page_h
_extract_poor_man_key	btree_page_h.h	/^inline btree_page_h::poor_man_key btree_page_h::_extract_poor_man_key(const cvec_t& trunc_key) const {$/;"	f	class:btree_page_h
_extract_poor_man_key	btree_page_h.h	/^inline btree_page_h::poor_man_key btree_page_h::_extract_poor_man_key(const void* trunc_key,$/;"	f	class:btree_page_h
_failed	vol.h	/^    bool             _failed;$/;"	m	class:vol_t
_fake_disk_latency	vol.h	/^    int              _fake_disk_latency;$/;"	m	class:vol_t
_fd	backup.h	/^    int     _fd;$/;"	m	class:BackupFile
_fence_len	btree_logrec.h	/^    int16_t       _fence_len; \/\/ +2 -> 2$/;"	m	struct:btree_foster_rebalance_norec_t
_fence_len	btree_logrec.h	/^    uint16_t        _fence_len;          \/\/ +2 => 18, fence key length$/;"	m	struct:btree_foster_rebalance_t
_fence_len	btree_logrec.h	/^    uint16_t    _fence_len, _chain_high_len;  \/\/ +2+2 => 20$/;"	m	struct:btree_norec_alloc_t
_fetch	logbuf_core.cpp	/^w_rc_t logbuf_core::_fetch($/;"	f	class:logbuf_core
_fhdl_app	partition.h	/^    int                   _fhdl_app;$/;"	m	class:partition_t
_fhdl_rd	partition.h	/^    int                   _fhdl_rd;$/;"	m	class:partition_t
_file	sm_base.h	/^    const char *const _file;$/;"	m	struct:check_compensated_op_nesting
_file	xct.h	/^    const char *_file; \/\/ debugging$/;"	m	class:auto_rollback_t
_fill	btree_logrec.h	/^    fill2 _fill;$/;"	m	struct:btree_bulk_delete_t
_fill16_60	bf_tree_cb.h	/^    fill16                      _fill16_60;      \/\/ +2 -> 60$/;"	m	struct:bf_tree_cb_t
_fill4	logrec.h	/^    uint32_t    _fill4;    \/\/ +4.$/;"	m	struct:multi_page_log_t
_fill56	bf_tree_cb.h	/^    fill8                       _fill56;          \/\/ +1 -> 51$/;"	m	struct:bf_tree_cb_t
_fill8_61	bf_tree_cb.h	/^    fill8                       _fill8_61;      \/\/ +1 -> 61   $/;"	m	struct:bf_tree_cb_t
_fill8_62	bf_tree_cb.h	/^    fill8                       _fill8_62;      \/\/ +1 -> 62$/;"	m	struct:bf_tree_cb_t
_fill8_63	bf_tree_cb.h	/^    fill8                       _fill8_63;      \/\/ +1 -> 63$/;"	m	struct:bf_tree_cb_t
_fill8_64	bf_tree_cb.h	/^    fill8                       _fill8_64;      \/\/ +1 -> 64$/;"	m	struct:bf_tree_cb_t
_filler	stnode_page.h	/^        fill2                 _filler; \/\/ for purify$/;"	m	class:store_operation_param
_find_next	btcursor.cpp	/^rc_t bt_cursor_t::_find_next(btree_page_h &p, bool &eof)$/;"	f	class:bt_cursor_t
_find_store_table	lock_lil.cpp	/^lil_private_store_table* lil_private_vol_table::_find_store_table(uint32_t store)$/;"	f	class:lil_private_vol_table
_fingerprint	smthread.h	/^    short              _fingerprint[FINGER_BITS]; \/\/ dreadlocks$/;"	m	class:smthread_t
_fingerprint_map	smthread.h	/^    atomic_thread_map_t  _fingerprint_map; \/\/ map containing only fingerprint$/;"	m	class:smthread_t
_finish_recovery	sm.cpp	/^void ss_m::_finish_recovery()$/;"	f	class:ss_m
_first_data_pageid	vol.h	/^    shpid_t          _first_data_pageid;$/;"	m	class:vol_t
_first_lsn	xct.h	/^    lsn_t                        _first_lsn;$/;"	m	class:xct_t
_first_non_empty	mem_mgmt.h	/^    size_t _first_non_empty;$/;"	m	class:fixed_lists_mem_t
_first_time	btcursor.h	/^    bool        _first_time;$/;"	m	class:bt_cursor_t
_fix_nonswizzled	bf_tree.cpp	/^w_rc_t bf_tree_m::_fix_nonswizzled(generic_page* parent, generic_page*& page,$/;"	f	class:bf_tree_m
_fix_nonswizzled_mainmemorydb	bf_tree.cpp	/^w_rc_t bf_tree_m::_fix_nonswizzled_mainmemorydb(generic_page* parent, generic_page*& page, shpid_t shpid, latch_mode_t mode, bool conditional, bool virgin_page) {$/;"	f	class:bf_tree_m
_fixed_bf	vol.h	/^    bf_fixed_m*      _fixed_bf;$/;"	m	class:vol_t
_fixed_pages	alloc_cache.h	/^    bf_fixed_m* _fixed_pages;$/;"	m	class:alloc_cache_t
_floor	log_storage.h	/^    static long         _floor(long offset, long block_size)$/;"	f	class:log_storage
_floor	logbuf_core.h	/^    static long         _floor(long offset, long block_size) $/;"	f	class:logbuf_core
_flushX	logbuf_core.cpp	/^void logbuf_core::_flushX(lsn_t start_lsn, uint64_t start, uint64_t end) {$/;"	f	class:logbuf_core
_flush_cond	log_core.h	/^    pthread_cond_t       _flush_cond;  \/\/ paird with _wait_flush_lock$/;"	m	class:log_common
_flush_daemon	log_core.h	/^    sthread_t*           _flush_daemon;$/;"	m	class:log_common
_flush_daemon_running	log_core.h	/^    lintel::Atomic<bool> _flush_daemon_running; \/\/ for asserts only$/;"	m	class:log_common
_flush_lock	log_core.h	/^    tatas_lock           _flush_lock;$/;"	m	class:log_common
_flush_logbuf	xct.cpp	/^xct_t::_flush_logbuf()$/;"	f	class:xct_t
_flush_lsn	log_core.h	/^    lsn_t                _flush_lsn;$/;"	m	class:log_common
_flush_trigger	logbuf_core.h	/^    uint32_t _flush_trigger; \/\/ max number of segments in the write buffer (M)$/;"	m	class:logbuf_core
_flush_write_buffer	bf_tree_cleaner.cpp	/^w_rc_t bf_tree_cleaner_slave_thread_t::_flush_write_buffer(vid_t vol,$/;"	f	class:bf_tree_cleaner_slave_thread_t
_for_alignment_only	btree_page.h	/^            int64_t _for_alignment_only;$/;"	m	union:btree_page_data::__anon6::__anon7
_forward	btcursor.h	/^    bool        _forward;$/;"	m	class:bt_cursor_t
_foster_emlsn	btree_logrec.h	/^    lsn_t       _foster_emlsn;                \/\/ +8   => 16$/;"	m	struct:btree_norec_alloc_t
_foster_pid	btree_logrec.h	/^    shpid_t     _root_pid, _foster_pid;       \/\/ +4+4 => 8$/;"	m	struct:btree_norec_alloc_t
_foster_pid0	btree_logrec.h	/^    shpid_t         _foster_pid0;        \/\/ +4 => 4, foster page ID (destination page)$/;"	m	struct:btree_foster_merge_t
_foster_pid0_emlsn	btree_logrec.h	/^    lsn_t           _foster_pid0_emlsn;  \/\/ +8 => 12, foster emlsn (destination page)$/;"	m	struct:btree_foster_merge_t
_foster_slot	btree_logrec.h	/^    int32_t     _foster_slot;           \/\/ +4$/;"	m	struct:btree_foster_deadopt_t
_free	logbuf_core.h	/^    int64_t _free;  \/\/ number of bytes usable (allocated and free) for insertion$/;"	m	class:logbuf_core
_free_segment_count	lock_raw.h	/^    uint32_t            _free_segment_count;$/;"	m	class:RawLockBackgroundThread
_freelist	bf_tree.h	/^    bf_idx*              _freelist;$/;"	m	class:bf_tree_m
_freelist_len	bf_tree.h	/^    uint32_t _freelist_len;$/;"	m	class:bf_tree_m
_freelist_lock	bf_tree.h	/^    tatas_lock           _freelist_lock;$/;"	m	class:bf_tree_m
_gen_log_warnings	smthread.h	/^    bool            _gen_log_warnings;$/;"	m	class:smthread_t
_generation_count	lock_raw.h	/^    uint32_t            _generation_count;$/;"	m	class:RawLockBackgroundThread
_get_du_statistics	sm.cpp	/^ss_m::_get_du_statistics( const stid_t& stpgid, sm_du_stats_t& du, bool audit)$/;"	f	class:ss_m
_get_du_statistics	sm.cpp	/^ss_m::_get_du_statistics(vid_t vid, sm_du_stats_t& du, bool audit)$/;"	f	class:ss_m
_get_du_statistics_recurse	btree.cpp	/^btree_m::_get_du_statistics_recurse($/;"	f	class:btree_m
_get_index	log_storage.cpp	/^partition_index_t log_storage::_get_index(uint32_t n) const$/;"	f	class:log_storage
_get_lsn_for_backward_scan	logbuf_core.cpp	/^w_rc_t logbuf_core::_get_lsn_for_backward_scan(lsn_t &lsn, \/\/ IN\/OUT: the position where the lsn is stored\/the actual lsn value$/;"	f	class:logbuf_core
_get_min_size	log_storage.h	/^    fileoff_t       _get_min_size() const {$/;"	f	class:log_storage
_get_more_space_for_insertion	logbuf_core.cpp	/^void logbuf_core::_get_more_space_for_insertion(CArraySlot *info) {$/;"	f	class:logbuf_core
_get_new_seg_for_fetch	logbuf_core.cpp	/^logbuf_seg *logbuf_core::_get_new_seg_for_fetch() {$/;"	f	class:logbuf_core
_get_replacement_block	bf_tree_evict.cpp	/^w_rc_t bf_tree_m::_get_replacement_block() {$/;"	f	class:bf_tree_m
_get_store_info	smindex.cpp	/^ss_m::_get_store_info($/;"	f	class:ss_m
_get_store_property	smfile.cpp	/^ss_m::_get_store_property($/;"	f	class:ss_m
_ghost_record	btree_page_h.h	/^    bool            _ghost_record;$/;"	m	class:btrec_t
_global_stats_	smstats.cpp	/^    sm_stats_info_t _global_stats_;$/;"	m	namespace:local_ns	file:
_global_stats_mutex	smstats.cpp	/^    static queue_based_block_lock_t _global_stats_mutex;$/;"	m	namespace:local_ns	file:
_grab_free_block	bf_tree_evict.cpp	/^w_rc_t bf_tree_m::_grab_free_block(bf_idx& ret, bool evict) {$/;"	f	class:bf_tree_m
_granted_mode	lock_bucket.h	/^    okvl_mode              _granted_mode;$/;"	m	class:lock_queue_entry_t
_had_error	xct.h	/^    bool                        _had_error;$/;"	m	class:xct_t
_hash	lock_bucket.h	/^    const uint32_t _hash;  \/\/\/< precise hash for this lock queue.$/;"	m	class:lock_queue_t
_hash_bits	btree_verify.h	/^    const int _hash_bits;$/;"	m	class:verification_context
_hashmap	lock_x.h	/^    XctLockHashMap  _hashmap;$/;"	m	class:xct_lock_info_t
_hashtable	bf_tree.h	/^    bf_hashtable<bf_idx_pair>*        _hashtable;$/;"	m	class:bf_tree_m
_hashtable	logbuf_core.h	/^    logbuf_hashtable *_hashtable;  \/\/ hash table mapping from lsn to logbuf_seg$/;"	m	class:logbuf_core
_head	lock_bucket.h	/^    lock_queue_entry_t* _head;$/;"	m	class:lock_queue_t
_head	lock_x.h	/^    xct_lock_entry_t *_head;$/;"	m	class:xct_lock_info_t
_high_len	btree_logrec.h	/^    uint16_t        _high_len;           \/\/ +2 => 14, high key length$/;"	m	struct:btree_foster_merge_t
_high_len	btree_logrec.h	/^    uint16_t        _high_len;           \/\/ +2 => 20, high key length$/;"	m	struct:btree_foster_rebalance_t
_high_len	btree_logrec.h	/^    uint16_t    _low_len, _high_len;    \/\/ +2+2$/;"	m	struct:btree_foster_deadopt_t
_hit_counts	lock_bucket.h	/^    uint32_t       _hit_counts;$/;"	m	class:lock_queue_t
_htab	lock_core.h	/^    RawLockQueue*       _htab;$/;"	m	class:lock_core_m
_htabsz	lock_core.h	/^    uint32_t            _htabsz;$/;"	m	class:lock_core_m
_i	xct.cpp	/^        sthread_base_t::id_t                 _i;$/;"	m	class:PrintSmthreadById	file:
_id	bf_tree_cleaner.h	/^    const unsigned _id;$/;"	m	class:bf_tree_cleaner_slave_thread_t
_idx	bf_tree.h	/^    bf_idx _idx;$/;"	m	class:pin_for_refix_holder
_in_compensated_op	xct.h	/^    lintel::Atomic<int> _in_compensated_op; \/\/ in the midst of a compensated operation$/;"	m	class:xct_t
_in_doubt	bf_tree_cb.h	/^    bool                        _in_doubt;      \/\/ +1 -> 32$/;"	m	struct:bf_tree_cb_t
_in_sm	smthread.h	/^        bool    _in_sm;      \/\/ thread is in sm ss_m:: function$/;"	m	struct:smthread_t::tcb_t
_incr	mem_mgmt.h	/^    const size_t _incr;$/;"	m	class:fixed_lists_mem_t
_index	partition.h	/^    partition_index_t     _index; $/;"	m	class:partition_t
_indexof	log_carray.h	/^inline int ConsolidationArray::_indexof(const CArraySlot* info) const {$/;"	f	class:ConsolidationArray
_init	btcursor.cpp	/^void bt_cursor_t::_init($/;"	f	class:bt_cursor_t
_init	btree_page_h.cpp	/^void btree_page_h::_init(lsn_t lsn, lpid_t page_id, snum_t store,$/;"	f	class:btree_page_h
_init_for_str	lock_s.h	/^lockid_t::_init_for_str(const stid_t &stid, const unsigned char *keystr, int16_t keylen)$/;"	f	class:lockid_t
_init_generation_count	lock_raw.h	/^    uint32_t            _init_generation_count;$/;"	m	class:RawLockBackgroundThread
_initialize_fingerprint	smthread.cpp	/^void smthread_t::_initialize_fingerprint()$/;"	f	class:smthread_t
_initially_wakeup_workers	bf_tree_cleaner.h	/^    const bool                  _initially_wakeup_workers;$/;"	m	class:bf_tree_cleaner
_inquery_verify	xct.h	/^    bool                         _inquery_verify;$/;"	m	class:xct_t
_inquery_verify_context	xct.h	/^    inquery_verify_context_t     _inquery_verify_context;$/;"	m	class:xct_t
_inquery_verify_keyorder	xct.h	/^    bool                         _inquery_verify_keyorder;$/;"	m	class:xct_t
_inquery_verify_space	xct.h	/^    bool                         _inquery_verify_space;$/;"	m	class:xct_t
_insert_lock	log_core.h	/^    mcs_lock             _insert_lock;$/;"	m	class:log_common
_insert_seg_for_fetch	logbuf_core.cpp	/^void logbuf_core::_insert_seg_for_fetch(logbuf_seg *seg) {$/;"	f	class:logbuf_core
_insert_seg_to_hashtable_for_insertion	logbuf_core.cpp	/^void logbuf_core::_insert_seg_to_hashtable_for_insertion(logbuf_seg *seg) {$/;"	f	class:logbuf_core
_insert_seg_to_list_for_insertion	logbuf_core.cpp	/^void logbuf_core::_insert_seg_to_list_for_insertion(logbuf_seg *seg) {$/;"	f	class:logbuf_core
_install_volume_mainmemorydb	bf_tree.cpp	/^w_rc_t bf_tree_m::_install_volume_mainmemorydb(vol_t* volume) {$/;"	f	class:bf_tree_m
_instance_cnt	sm.cpp	/^int ss_m::_instance_cnt = 0;$/;"	m	class:ss_m	file:
_instance_cnt	sm.h	/^    static int _instance_cnt;$/;"	m	class:ss_m
_int_options	sm_options.h	/^    std::map<std::string, int64_t> _int_options;$/;"	m	class:sm_options
_internal	btree_page_h.h	/^    enum _internal {$/;"	g	class:btree_page_h
_internal_milliseconds	lock_raw.h	/^    uint32_t            _internal_milliseconds;$/;"	m	class:RawLockBackgroundThread
_interval_cond	bf_tree_cleaner.h	/^    pthread_cond_t              _interval_cond;$/;"	m	class:bf_tree_cleaner_slave_thread_t
_interval_cond	lock_raw.h	/^    pthread_cond_t  _interval_cond;$/;"	m	class:RawLockBackgroundThread
_interval_millisec	bf_tree_cleaner.h	/^    uint32_t                    _interval_millisec;$/;"	m	class:bf_tree_cleaner_slave_thread_t
_interval_mutex	bf_tree_cleaner.h	/^    pthread_mutex_t             _interval_mutex;$/;"	m	class:bf_tree_cleaner_slave_thread_t
_interval_mutex	lock_raw.h	/^    pthread_mutex_t _interval_mutex;$/;"	m	class:RawLockBackgroundThread
_is_active_idx	bf_tree.cpp	/^bool bf_tree_m::_is_active_idx (bf_idx idx) const {$/;"	f	class:bf_tree_m
_is_consistent_keyorder	btree_page_h.cpp	/^bool btree_page_h::_is_consistent_keyorder() const {$/;"	f	class:btree_page_h
_is_consistent_poormankey	btree_page_h.cpp	/^bool btree_page_h::_is_consistent_poormankey() const {$/;"	f	class:btree_page_h
_is_enough_spacious_ghost	btree_page_h.cpp	/^bool btree_page_h::_is_enough_spacious_ghost(const w_keystr_t &key, slotid_t slot,$/;"	f	class:btree_page_h
_is_force_until_lsn_done	bf_tree_cleaner.cpp	/^bool bf_tree_cleaner::_is_force_until_lsn_done(lsndata_t lsn) const$/;"	f	class:bf_tree_cleaner
_is_update_thread	smthread.h	/^        bool    _is_update_thread;\/\/ thread is in update function$/;"	m	struct:smthread_t::tcb_t
_is_valid_idx	bf_tree.cpp	/^bool bf_tree_m::_is_valid_idx(bf_idx idx) const {$/;"	f	class:bf_tree_m
_item_align	btree_page.h	/^    static size_t _item_align(size_t i) { return (i+sizeof(item_body)-1)&~(sizeof(item_body)-1); }$/;"	f	class:btree_page_data
_item_bodies	btree_page.h	/^inline btree_page_data::body_offset_t btree_page_data::_item_bodies(body_offset_t offset) const {$/;"	f	class:btree_page_data
_item_body_length	btree_page.h	/^inline btree_page_data::item_length_t btree_page_data::_item_body_length(body_offset_t offset) const {$/;"	f	class:btree_page_data
_item_body_length	btree_page.h	/^inline btree_page_data::item_length_t& btree_page_data::_item_body_length(body_offset_t offset) {$/;"	f	class:btree_page_data
_item_body_overhead	btree_page.h	/^inline size_t btree_page_data::_item_body_overhead() const {$/;"	f	class:btree_page_data
_items_are_consistent	btree_page.cpp	/^bool btree_page_data::_items_are_consistent() const {$/;"	f	class:btree_page_data
_join_attr	lock_raw.h	/^    pthread_attr_t  _join_attr;$/;"	m	class:RawLockBackgroundThread
_join_carray	log_core.cpp	/^rc_t log_core::_join_carray(CArraySlot*& info, long& pos, int32_t size)$/;"	f	class:log_core
_key	btcursor.h	/^    w_keystr_t  _key;$/;"	m	class:bt_cursor_t
_key	btree_page_h.h	/^    w_keystr_t      _key;$/;"	m	class:btrec_t
_kicked	chkpt.cpp	/^    bool                _kicked;$/;"	m	class:chkpt_thread_t	file:
_klen	btree_logrec.h	/^    uint16_t    _klen;$/;"	m	struct:btree_overwrite_t
_klen	btree_logrec.h	/^    uint16_t    _klen;$/;"	m	struct:btree_update_t
_lastMountLSN	log_core.h	/^    lsn_t           _lastMountLSN;$/;"	m	class:log_common
_last_log	xct.h	/^    logrec_t*                    _last_log;    \/\/ last log generated by xct$/;"	m	class:xct_t
_last_lsn	xct.h	/^    lsn_t                        _last_lsn;$/;"	m	class:xct_t
_last_non_empty	mem_mgmt.h	/^    size_t _last_non_empty;$/;"	m	class:fixed_lists_mem_t
_last_skip_lsn	partition.h	/^    lsn_t                 _last_skip_lsn;$/;"	m	class:partition_t
_latch	bf_tree.cpp	/^    latch_t &_latch;$/;"	m	struct:latch_auto_release	file:
_latch	bf_tree_cb.h	/^    latch_t                     _latch;         \/\/ +64 ->128$/;"	m	struct:bf_tree_cb_t
_latch	xct.h	/^    latch_t                      _latch;$/;"	m	class:xct_t
_latch_offset	bf_tree_cb.h	/^    int8_t                      _latch_offset;  \/\/ +1 -> 64$/;"	m	struct:bf_tree_cb_t
_latch_root_page	bf_tree.cpp	/^w_rc_t bf_tree_m::_latch_root_page(generic_page*& page, bf_idx idx, latch_mode_t mode, bool conditional) {$/;"	f	class:bf_tree_m
_leaf_key_noprefix	btree_page_h.h	/^inline const char* btree_page_h::_leaf_key_noprefix(slotid_t slot,  size_t &len) const {$/;"	f	class:btree_page_h
_leave_carray	log_core.cpp	/^rc_t log_core::_leave_carray(CArraySlot* info, int32_t size)$/;"	f	class:log_core
_len	logrec.h	/^    uint16_t            _len;  \/\/ length of the log record$/;"	m	struct:baseLogHeader
_li	lock_bucket.h	/^    xct_lock_info_t&    _li;$/;"	m	class:lock_queue_entry_t
_lil_global_table	lock_core.h	/^    lil_global_table*  _lil_global_table;$/;"	m	class:lock_core_m
_lil_lock_info	xct.h	/^        lil_private_table*     _lil_lock_info;$/;"	m	struct:xct_t::xct_core
_line	sm_base.h	/^    int _line;$/;"	m	struct:check_compensated_op_nesting
_line	xct.h	/^    int    _line; \/\/ debugging$/;"	m	class:auto_rollback_t
_link	logbuf_seg.h	/^    w_link_t _link;  \/\/ node for the doubly linked list$/;"	m	class:logbuf_seg
_link	xct.h	/^    w_link_t    _link;$/;"	m	class:stid_list_elem_t
_link	xct_dependent.h	/^    w_link_t    _link;$/;"	m	class:xct_dependent_t
_lists	mem_mgmt.h	/^    list_header_t ** _lists;$/;"	m	class:fixed_lists_mem_t
_loadStores	xct.h	/^        w_list_t<stid_list_elem_t,queue_based_lock_t>    _loadStores;$/;"	m	struct:xct_t::xct_core
_locate_first	btcursor.cpp	/^rc_t bt_cursor_t::_locate_first() {$/;"	f	class:bt_cursor_t
_lock	bf_hashtable.cpp	/^    srwlock_t                   _lock;$/;"	m	class:bf_hashbucket	file:
_lock	logbuf_hashtable.cpp	/^    srwlock_t                   _lock;$/;"	m	class:logbuf_hashbucket	file:
_lock_info	xct.h	/^        xct_lock_info_t*       _lock_info;$/;"	m	struct:xct_t::xct_core
_lock_pool	lock_core.h	/^    GcPoolForest<RawLock>*      _lock_pool;$/;"	m	class:lock_core_m
_lock_pool	lock_raw.h	/^    GcPoolForest<RawLock>*     _lock_pool;$/;"	m	class:RawLockBackgroundThread
_lock_taken	lock_lil.h	/^    bool        _lock_taken[LIL_MODES]; \/\/ +4 -> 8$/;"	m	class:lil_private_store_table
_lock_taken	lock_lil.h	/^    bool        _lock_taken[LIL_MODES]; \/\/ +4 -> 8$/;"	m	class:lil_private_vol_table
_locked	xct.h	/^    const bool            _locked;$/;"	m	class:xct_i
_lockpool_initseg	lock_raw.h	/^    uint32_t            _lockpool_initseg;$/;"	m	class:RawLockBackgroundThread
_lockpool_segsize	lock_raw.h	/^    size_t              _lockpool_segsize;$/;"	m	class:RawLockBackgroundThread
_log	log_core.cpp	/^    log_common* _log;$/;"	m	class:flush_daemon_thread_t	file:
_log_buf	xct.h	/^    logrec_t*                    _log_buf;$/;"	m	class:xct_t
_log_buf_for_piggybacked_ssx	xct.h	/^    logrec_t*                    _log_buf_for_piggybacked_ssx;$/;"	m	class:xct_t
_log_bytes_ready	xct.h	/^    fileoff_t                    _log_bytes_ready; \/\/ avail for insert\/reserv$/;"	m	class:xct_t
_log_bytes_reserved_space	xct.h	/^    fileoff_t                    _log_bytes_reserved_space;\/\/requested from$/;"	m	class:xct_t
_log_bytes_rsvd	xct.h	/^    fileoff_t                    _log_bytes_rsvd; \/\/ reserved for rollback$/;"	m	class:xct_t
_log_bytes_used	xct.h	/^    fileoff_t                    _log_bytes_used; \/\/ total used by the xct$/;"	m	class:xct_t
_log_bytes_used_fwd	xct.h	/^    fileoff_t                    _log_bytes_used_fwd; \/\/ used by the xct in$/;"	m	class:xct_t
_log_corruption	log_core.h	/^    bool            _log_corruption;$/;"	m	class:log_common
_log_me_node	smthread.h	/^        queue_based_block_lock_t::ext_qnode _log_me_node;$/;"	m	struct:smthread_t::tcb_t
_log_prefix	log_storage.cpp	/^const char log_storage::_log_prefix[] = "log.";$/;"	m	class:log_storage	file:
_log_prefix	log_storage.h	/^    static const char    _log_prefix[];$/;"	m	class:log_storage
_log_space_waiters	log_resv.h	/^    std::deque<waiting_xct*> _log_space_waiters;$/;"	m	class:log_resv
_logbuf_lock	logbuf_core.h	/^    tatas_lock _logbuf_lock;$/;"	m	class:logbuf_core
_logdir	log_storage.h	/^    char*           _logdir;$/;"	m	class:log_storage
_logrec_buf	vol.h	/^    char _logrec_buf[128];$/;"	m	class:vol_t
_lookup_for_compensate	logbuf_core.cpp	/^logbuf_seg *logbuf_core::_lookup_for_compensate(lsn_t lsn) {$/;"	f	class:logbuf_core
_loser_xct	xct.h	/^    loser_xct_state_t            _loser_xct;$/;"	m	class:xct_t
_low_len	btree_logrec.h	/^    uint16_t    _low_len, _high_len;    \/\/ +2+2$/;"	m	struct:btree_foster_deadopt_t
_low_water_marks	log_lsn_tracker.h	/^    lsndata_t*          _low_water_marks;$/;"	m	class:PoorMansOldestLsnTracker
_lower	btcursor.h	/^    w_keystr_t  _lower;$/;"	m	class:bt_cursor_t
_lower_inclusive	btcursor.h	/^    bool        _lower_inclusive;$/;"	m	class:bt_cursor_t
_lsn	btcursor.h	/^    lsn_t       _lsn;$/;"	m	class:bt_cursor_t
_lsn_ck	logrec.h	/^    const lsn_t*            _lsn_ck() const {$/;"	f	class:logrec_t
_lsn_ck	logrec.h	/^    lsn_t*            _lsn_ck() {$/;"	f	class:logrec_t
_make_master_name	log_storage.cpp	/^void log_storage::_make_master_name($/;"	f	class:log_storage
_make_rec	btcursor.cpp	/^rc_t bt_cursor_t::_make_rec(const btree_page_h& page)$/;"	f	class:bt_cursor_t
_make_store_flag	sm.cpp	/^ss_m::_make_store_flag(store_property_t property)$/;"	f	class:ss_m
_mask	partition.h	/^    uint32_t     _mask;$/;"	m	class:partition_t
_master_lsn	log_storage.h	/^    lsn_t                   _master_lsn;$/;"	m	class:log_storage
_master_prefix	log_storage.cpp	/^const char log_storage::_master_prefix[] = "chk."; \/\/ same size as _log_prefix$/;"	m	class:log_storage	file:
_master_prefix	log_storage.h	/^    static const char    _master_prefix[];$/;"	m	class:log_storage
_max	mem_mgmt.h	/^    const size_t _max;$/;"	m	class:fixed_lists_mem_t
_max_seg_count	logbuf_core.h	/^    uint32_t _max_seg_count;  \/\/ max number of segments in the log buffer (N)$/;"	m	class:logbuf_core
_max_segment_count	lock_raw.h	/^    uint32_t            _max_segment_count;$/;"	m	class:RawLockBackgroundThread
_may_check	xct.h	/^    const bool            _may_check;$/;"	m	class:xct_i
_me1	smthread.h	/^        queue_based_lock_t::ext_qnode _me1;$/;"	m	struct:smthread_t::tcb_t
_me2	smthread.h	/^        queue_based_lock_t::ext_qnode _me2;$/;"	m	struct:smthread_t::tcb_t
_me3	smthread.h	/^        queue_based_lock_t::ext_qnode _me3;$/;"	m	struct:smthread_t::tcb_t
_min_chkpt_rec_lsn	log_storage.h	/^    lsn_t                   _min_chkpt_rec_lsn;$/;"	m	class:log_storage
_mode	fixable_page_h.h	/^    latch_mode_t  _mode;$/;"	m	class:fixable_page_h
_modify_hash	btree_impl_verify.cpp	/^uint32_t verification_context::_modify_hash ($/;"	f	class:verification_context
_move_count	btree_logrec.h	/^    int32_t         _move_count;         \/\/ +4 => 20, number of records to move$/;"	m	struct:btree_foster_merge_t
_move_count	btree_logrec.h	/^    int32_t         _move_count;         \/\/ +4 => 4, number of records to move$/;"	m	struct:btree_foster_rebalance_t
_mutex	vol.h	/^    mutable srwlock_t _mutex;$/;"	m	class:vol_t
_mutex	vol.h	/^    srwlock_t _mutex;$/;"	m	class:vol_m
_needs_lock	btcursor.h	/^    bool        _needs_lock;$/;"	m	class:bt_cursor_t
_new_child_emlsn	btree_logrec.h	/^    lsn_t   _new_child_emlsn;   \/\/ +8$/;"	m	struct:btree_foster_adopt_t
_new_child_key_len	btree_logrec.h	/^    int16_t _new_child_key_len; \/\/ +2$/;"	m	struct:btree_foster_adopt_t
_new_child_pid	btree_logrec.h	/^    shpid_t _new_child_pid;     \/\/ +4$/;"	m	struct:btree_foster_adopt_t
_new_elen	btree_logrec.h	/^    uint16_t    _new_elen;$/;"	m	struct:btree_update_t
_new_pid0	btree_logrec.h	/^    shpid_t         _new_pid0;           \/\/ +4 => 8, non-leaf node only$/;"	m	struct:btree_foster_rebalance_t
_new_pid0_emlsn	btree_logrec.h	/^    lsn_t           _new_pid0_emlsn;     \/\/ +8 => 16, non-leaf node only$/;"	m	struct:btree_foster_rebalance_t
_new_xct	sm.cpp	/^xct_t* ss_m::_new_xct($/;"	f	class:ss_m
_next	lock_bucket.h	/^    lock_queue_entry_t* _next;$/;"	m	class:lock_queue_entry_t
_next	lock_bucket.h	/^    lock_queue_t*  _next;$/;"	m	class:lock_queue_t
_next_vid	vol.h	/^    vid_t _next_vid;$/;"	m	class:vol_m
_node_key_noprefix	btree_page_h.h	/^inline const char* btree_page_h::_node_key_noprefix(slotid_t slot,  size_t &len) const {$/;"	f	class:btree_page_h
_non_contiguous_free_pages	alloc_cache.h	/^    std::vector<shpid_t> _non_contiguous_free_pages;$/;"	m	class:alloc_cache_t
_num	partition.h	/^    partition_number_t    _num;$/;"	m	class:partition_t
_num_pages	vol.h	/^    uint             _num_pages;$/;"	m	class:vol_t
_nxt_tid	xct.cpp	/^tid_t                                 xct_t::_nxt_tid = tid_t::null;$/;"	m	class:xct_t	file:
_nxt_tid	xct.h	/^    static tid_t                 _nxt_tid;\/\/ only safe for pre-emptive$/;"	m	class:xct_t
_observed_release_version	lock_bucket.h	/^    uint64_t            _observed_release_version;$/;"	m	class:lock_queue_entry_t
_offset	btree_logrec.h	/^    uint16_t    _offset;$/;"	m	struct:btree_overwrite_t
_old_elen	btree_logrec.h	/^    uint16_t    _old_elen;$/;"	m	struct:btree_update_t
_old_epoch	log_core.h	/^    epoch                _old_epoch;$/;"	m	class:log_common
_oldest_lsn_tracker	log_resv.h	/^    PoorMansOldestLsnTracker* _oldest_lsn_tracker;$/;"	m	class:log_resv
_oldest_tid	xct.cpp	/^tid_t                                xct_t::_oldest_tid = tid_t::null;$/;"	m	class:xct_t	file:
_oldest_tid	xct.h	/^    static tid_t                 _oldest_tid;$/;"	m	class:xct_t
_op	stnode_page.h	/^        uint16_t               _op;$/;"	m	class:store_operation_param
_open_partition	log_storage.cpp	/^log_storage::_open_partition(partition_number_t  __num,$/;"	f	class:log_storage
_open_partition_for_append	log_storage.h	/^    partition_t *       _open_partition_for_append(partition_number_t n,$/;"	f	class:log_storage
_open_partition_for_read	log_storage.h	/^    partition_t *       _open_partition_for_read(partition_number_t n,$/;"	f	class:log_storage
_options	sm.cpp	/^sm_options ss_m::_options;$/;"	m	class:ss_m	file:
_options	sm.h	/^    static sm_options _options;$/;"	m	class:ss_m
_original_value	restart.h	/^         bool _original_value;$/;"	m	class:AutoTurnOffLogging
_original_xct_depth	xct.h	/^    size_t _original_xct_depth;$/;"	m	class:sys_xct_section_t
_outer	smthread.h	/^        tcb_t*   _outer; \/\/ this forms a singly linked list$/;"	m	struct:smthread_t::tcb_t
_owner	partition.h	/^    log_storage*             _owner;$/;"	m	class:partition_t
_pack_fence_rec	btree_page_h.h	/^inline int btree_page_h::_pack_fence_rec(cvec_t& out, const w_keystr_t& low,$/;"	f	class:btree_page_h
_pack_leaf_record	btree_page_h.h	/^inline void btree_page_h::_pack_leaf_record(cvec_t& out, pack_scratch_t& out_scratch,$/;"	f	class:btree_page_h
_pack_leaf_record_prefix	btree_page_h.h	/^inline void btree_page_h::_pack_leaf_record_prefix(cvec_t& out, pack_scratch_t& out_scratch,$/;"	f	class:btree_page_h
_pack_node_record	btree_page_h.h	/^inline void btree_page_h::_pack_node_record(cvec_t& out, const cvec_t& trunc_key,$/;"	f	class:btree_page_h
_padding	log_carray.h	/^    \/** @cond *\/ char   _padding[CACHELINE_SIZE]; \/** @endcond *\/$/;"	m	class:ConsolidationArray
_padding	log_core.h	/^    \/** @cond *\/ char    _padding[CACHELINE_SIZE]; \/** @endcond *\/$/;"	m	class:log_common
_padding0	logbuf_core.h	/^    \/** @cond *\/ char    _padding0[CACHELINE_TATAS_PADDING]; \/** @endcond *\/$/;"	m	class:logbuf_core
_padding00	logbuf_core.h	/^    \/** @cond *\/ char    _padding00[CACHELINE_TATAS_PADDING]; \/** @endcond *\/$/;"	m	class:logbuf_core
_padding2	log_core.h	/^    \/** @cond *\/ char    _padding2[CACHELINE_TATAS_PADDING]; \/** @endcond *\/$/;"	m	class:log_common
_padding3	log_core.h	/^    \/** @cond *\/ char    _padding3[CACHELINE_TATAS_PADDING]; \/** @endcond *\/$/;"	m	class:log_common
_padding4	log_core.h	/^    \/** @cond *\/ char    _padding4[CACHELINE_MCS_PADDING]; \/** @endcond *\/$/;"	m	class:log_common
_page2_pid	logrec.h	/^    shpid_t     _page2_pid; \/\/ +4$/;"	m	struct:multi_page_log_t
_page2_prv	logrec.h	/^    lsn_t       _page2_prv; \/\/ +8$/;"	m	struct:multi_page_log_t
_page_cnt	bf_fixed.h	/^    uint32_t    _page_cnt;$/;"	m	class:bf_fixed_m
_page_count	bf_transit_bucket.h	/^    int            _page_count;$/;"	m	class:transit_bucket_t
_page_prv	logrec.h	/^    lsn_t               _page_prv;$/;"	m	struct:baseLogHeader
_page_tag	logrec.h	/^    uint16_t             _page_tag; \/\/ tag_t 2 bytes$/;"	m	struct:baseLogHeader
_pages	bf_fixed.h	/^    generic_page*     _pages;$/;"	m	class:bf_fixed_m
_pages	bf_transit_bucket.h	/^    bfpid_t        _pages[MAX_IN_TRANSIT];$/;"	m	class:transit_bucket_t
_pages_checked	btree_verify.h	/^    int _pages_checked;$/;"	m	class:verification_context
_pages_inconsistent	btree_verify.h	/^    int _pages_inconsistent;$/;"	m	class:verification_context
_parent	bf_fixed.h	/^    vol_t*      _parent;$/;"	m	class:bf_fixed_m
_parent	bf_tree_cb.h	/^    bf_idx _parent;        \/\/ +4 -> 28$/;"	m	struct:bf_tree_cb_t
_parent	bf_tree_cleaner.h	/^    bf_tree_cleaner*            _parent;$/;"	m	class:bf_tree_cleaner_slave_thread_t
_parse_master_chkpt_contents	log_storage.cpp	/^rc_t log_storage::_parse_master_chkpt_contents($/;"	f	class:log_storage
_parse_master_chkpt_string	log_storage.cpp	/^rc_t log_storage::_parse_master_chkpt_string($/;"	f	class:log_storage
_part	log_storage.h	/^    partition_t         _part[PARTITION_COUNT];$/;"	m	class:log_storage
_part_size	logbuf_core.h	/^    fileoff_t _part_size;$/;"	m	class:logbuf_core
_partition	log_storage.cpp	/^log_storage::_partition(partition_index_t i) const$/;"	f	class:log_storage
_partition_data_size	log_storage.h	/^    fileoff_t               _partition_data_size;$/;"	m	class:log_storage
_partition_data_size	logbuf_core.h	/^    fileoff_t _partition_data_size() $/;"	f	class:logbuf_core
_partition_exists	log_storage.cpp	/^bool log_storage::_partition_exists(partition_number_t pnum)$/;"	f	class:log_storage
_partition_lock	log_storage.h	/^    mutable queue_based_block_lock_t _partition_lock;$/;"	m	class:log_storage
_partition_size	log_storage.h	/^    fileoff_t               _partition_size;$/;"	m	class:log_storage
_path	backup.h	/^    std::string _path;$/;"	m	class:BackupFile
_peek	partition.cpp	/^partition_t::_peek($/;"	f	class:partition_t
_peekbuf	partition.h	/^    char*               _peekbuf;$/;"	m	class:partition_t
_permission_to_violate	lock_x.h	/^    bool      _permission_to_violate;$/;"	m	class:xct_lock_info_t
_pid	btcursor.h	/^    shpid_t     _pid;$/;"	m	class:bt_cursor_t
_pid_bfidx	btcursor.h	/^    pin_for_refix_holder _pid_bfidx;$/;"	m	class:bt_cursor_t
_pid_shpid	bf_tree_cb.h	/^    shpid_t _pid_shpid;     \/\/ +4  -> 8$/;"	m	struct:bf_tree_cb_t
_pid_vol	bf_tree_cb.h	/^    vid_t _pid_vol;       \/\/ +2  -> 4$/;"	m	struct:bf_tree_cb_t
_piggy_backed_single_log_sys_xct	xct.h	/^    bool                         _piggy_backed_single_log_sys_xct;$/;"	m	class:xct_t
_pin_cnt	bf_tree_cb.h	/^    int32_t _pin_cnt;       \/\/ +4 -> 12$/;"	m	struct:bf_tree_cb_t
_pin_cnt_change	prologue.h	/^    int               _pin_cnt_change;$/;"	m	class:prologue_rc_t
_poor	btree_page_h.h	/^inline btree_page_h::poor_man_key btree_page_h::_poor(int slot) const {$/;"	f	class:btree_page_h
_pp	generic_page.h	/^    generic_page* _pp;$/;"	m	class:generic_page_h
_pre_abort	xct.cpp	/^xct_t::_pre_abort()$/;"	f	class:xct_t
_pre_commit	xct.cpp	/^xct_t::_pre_commit(uint32_t flags)$/;"	f	class:xct_t
_predict_leaf_data_length	btree_page_h.h	/^inline size_t btree_page_h::_predict_leaf_data_length(int trunc_key_length,$/;"	f	class:btree_page_h
_prefix_len	btree_logrec.h	/^    uint16_t        _prefix_len;         \/\/ +2 => 24, source page prefix length$/;"	m	struct:btree_foster_merge_t
_prefix_len	btree_logrec.h	/^    uint16_t        _prefix_len;         \/\/ +2 => 26, source page prefix length$/;"	m	struct:btree_foster_rebalance_t
_preload_root_page	bf_tree.cpp	/^w_rc_t bf_tree_m::_preload_root_page(bf_tree_vol_t* desc, vol_t* volume, snum_t store, shpid_t shpid, bf_idx idx) {$/;"	f	class:bf_tree_m
_prev	lock_bucket.h	/^    lock_queue_entry_t* _prev;$/;"	m	class:lock_queue_entry_t
_prime	logbuf_core.cpp	/^void logbuf_core::_prime($/;"	f	class:logbuf_core
_print_lock_entries	restart.cpp	/^void restart_m::_print_lock_entries(XctLockHeap& lock_heap) \/\/ In: heap object contains lock entries$/;"	f	class:restart_m
_proc	smthread.h	/^    st_proc_t* const   _proc;$/;"	m	class:smthread_t
_ptr	xct.cpp	/^    lil_private_table* _ptr;$/;"	m	struct:lil_lock_info_ptr	file:
_ptr	xct.cpp	/^    xct_lock_info_t* _ptr;$/;"	m	struct:lock_info_ptr	file:
_query_concurrency	xct.h	/^    concurrency_t                _query_concurrency;$/;"	m	class:xct_t
_query_exlock_for_select	xct.h	/^    bool                         _query_exlock_for_select;$/;"	m	class:xct_t
_queue	lock_bucket.h	/^    lock_queue_t* _queue;$/;"	m	class:bucket_t
_queue_latch	lock_bucket.h	/^    srwlock_t     _queue_latch;$/;"	m	class:bucket_t
_queue_lock	alloc_cache.h	/^    mutable srwlock_t _queue_lock;$/;"	m	class:alloc_cache_t
_raw_lock_cleaner	lock_core.h	/^    RawLockBackgroundThread*    _raw_lock_cleaner;$/;"	m	class:lock_core_m
_raw_lock_cleaner_functor	lock_core.h	/^    RawLockCleanerFunctor*      _raw_lock_cleaner_functor;$/;"	m	class:lock_core_m
_raw_lock_xct	xct.h	/^        RawXct*                _raw_lock_xct;$/;"	m	struct:xct_t::xct_core
_rc	prologue.h	/^    rc_t              _rc;$/;"	m	class:prologue_rc_t
_re_acquire_lock	restart.cpp	/^void restart_m::_re_acquire_lock(XctLockHeap& lock_heap, \/\/ In: heap to record all re-acquired locks$/;"	f	class:restart_m
_read_master	log_storage.cpp	/^w_rc_t log_storage::_read_master($/;"	f	class:log_storage
_read_only	xct.h	/^        bool                      _read_only;$/;"	m	struct:xct_t::xct_core
_read_watermark	xct.h	/^    lsn_t                        _read_watermark;$/;"	m	class:xct_t
_readbuf	log_core.h	/^    char*           _readbuf;$/;"	m	class:log_common
_readonly	vol.h	/^    bool             _readonly;$/;"	m	class:vol_t
_rec_lsn	bf_tree_cb.h	/^    lsndata_t _rec_lsn;       \/\/ +8 -> 24$/;"	m	struct:bf_tree_cb_t
_record_data_len	btree_logrec.h	/^    uint16_t        _record_data_len;    \/\/ +2 => 22, length of record data$/;"	m	struct:btree_foster_merge_t
_record_data_len	btree_logrec.h	/^    uint16_t        _record_data_len;    \/\/ +2 => 24, length of record data$/;"	m	struct:btree_foster_rebalance_t
_recovery_access	bf_tree_cb.h	/^    bool                       _recovery_access;       \/\/ +1 -> 52$/;"	m	struct:bf_tree_cb_t
_redo_log_with_pid	restart.cpp	/^void restart_m::_redo_log_with_pid($/;"	f	class:restart_m
_redo_page_pass	restart.cpp	/^void restart_m::_redo_page_pass()$/;"	f	class:restart_m
_refbit_approximate	bf_tree_cb.h	/^    uint16_t                    _refbit_approximate;\/\/ +2  -> 14$/;"	m	struct:bf_tree_cb_t
_refix_current_key	btcursor.cpp	/^w_rc_t bt_cursor_t::_refix_current_key(btree_page_h &p) {$/;"	f	class:bt_cursor_t
_registered	xct_dependent.h	/^    bool        _registered;$/;"	m	class:xct_dependent_t
_release_current_page	btcursor.cpp	/^void bt_cursor_t::_release_current_page() {$/;"	f	class:bt_cursor_t
_release_version	lock_bucket.h	/^    uint64_t       _release_version;$/;"	m	class:lock_queue_t
_release_version	lock_lil.h	/^    uint32_t            _release_version; \/\/ +4 -> 16$/;"	m	class:lil_global_table_base
_remove_seg	logbuf_core.cpp	/^void logbuf_core::_remove_seg(logbuf_seg *seg) {$/;"	f	class:logbuf_core
_replacement	logbuf_core.cpp	/^logbuf_seg *logbuf_core::_replacement() {$/;"	f	class:logbuf_core
_replacement_priority	bf_tree_cb.h	/^    char                        _replacement_priority;      \/\/ +1 -> 31$/;"	m	struct:bf_tree_cb_t
_replacement_priority	smthread.h	/^    char _replacement_priority; \/\/ identify workload priority (for use by the page replacement policy)$/;"	m	class:smthread_t
_request_lock_IS	lock_lil.cpp	/^w_rc_t lil_global_table_base::_request_lock_IS(lsn_t &observed_tag)$/;"	f	class:lil_global_table_base
_request_lock_IX	lock_lil.cpp	/^w_rc_t lil_global_table_base::_request_lock_IX(lsn_t &observed_tag)$/;"	f	class:lil_global_table_base
_request_lock_S	lock_lil.cpp	/^w_rc_t lil_global_table_base::_request_lock_S(lsn_t &observed_tag)$/;"	f	class:lil_global_table_base
_request_lock_X	lock_lil.cpp	/^w_rc_t lil_global_table_base::_request_lock_X(lsn_t &observed_tag)$/;"	f	class:lil_global_table_base
_requested_lsn	bf_tree_cleaner.h	/^    lsndata_t _requested_lsn;$/;"	m	class:bf_tree_cleaner
_requested_mode	lock_bucket.h	/^    okvl_mode              _requested_mode;$/;"	m	class:lock_queue_entry_t
_requested_volumes	bf_tree_cleaner.h	/^    volatile bool               _requested_volumes[vol_m::MAX_VOLS];$/;"	m	class:bf_tree_cleaner
_requests_latch	lock_bucket.h	/^    srwlock_t     _requests_latch;$/;"	m	class:lock_queue_t
_reservations_active	log_resv.h	/^    bool            _reservations_active;$/;"	m	class:log_resv
_reserve_buffer_space	logbuf_core.cpp	/^void logbuf_core::_reserve_buffer_space(CArraySlot *info, long recsize) {$/;"	f	class:logbuf_core
_restart_thread	restart.h	/^    restart_thread_t*           _restart_thread;$/;"	m	class:restart_m
_restore_mgr	vol.h	/^    RestoreMgr*      _restore_mgr;$/;"	m	class:vol_t
_results	btree_verify.h	/^    std::map<snum_t, verification_context*> _results;$/;"	m	class:verify_volume_result
_resv	log_core.h	/^    log_resv*       _resv;$/;"	m	class:log_common
_retire	chkpt.cpp	/^    bool                _retire;$/;"	m	class:chkpt_thread_t	file:
_retire_awaken_cond	chkpt.cpp	/^    pthread_cond_t      _retire_awaken_cond; \/\/ paried with _retire_awaken_lock$/;"	m	class:chkpt_thread_t	file:
_retire_awaken_lock	chkpt.cpp	/^    pthread_mutex_t     _retire_awaken_lock; \/\/ paired with _retire_awaken_cond$/;"	m	class:chkpt_thread_t	file:
_retrieve_page	backup.cpp	/^w_rc_t BackupManager::_retrieve_page(BackupFile &file, generic_page& page, shpid_t shpid) {$/;"	f	class:BackupManager
_robust_compare_key_noprefix	btree_page_h.h	/^inline int btree_page_h::_robust_compare_key_noprefix(slotid_t slot, const void *key_noprefix,$/;"	f	class:btree_page_h
_robust_compare_slot_with_key	btree_page_h.cpp	/^inline int btree_page_h::_robust_compare_slot_with_key(int slot, const void* key_noprefix, size_t key_len, poor_man_key key_poor) const {$/;"	f	class:btree_page_h
_robust_leaf_key_noprefix	btree_page_h.h	/^inline const char* btree_page_h::_robust_leaf_key_noprefix(slotid_t slot,  size_t &len) const {$/;"	f	class:btree_page_h
_robust_node_key_noprefix	btree_page_h.h	/^inline const char* btree_page_h::_robust_node_key_noprefix(slotid_t slot,  size_t &len) const {$/;"	f	class:btree_page_h
_roll	xct.h	/^    bool   _roll;$/;"	m	class:auto_rollback_t
_rollback_work	sm.cpp	/^ss_m::_rollback_work(const sm_save_point_t& sp)$/;"	f	class:ss_m
_rolling_back	xct.h	/^    bool                         _rolling_back;\/\/ true if aborting OR$/;"	m	class:xct_t
_root_pages	bf_tree_vol.h	/^    bf_idx _root_pages[MAX_STORE_COUNT];$/;"	m	struct:bf_tree_vol_t
_root_pid	btree_logrec.h	/^    shpid_t     _root_pid, _foster_pid;       \/\/ +4+4 => 8$/;"	m	struct:btree_norec_alloc_t
_root_shpid	btree_logrec.h	/^    shpid_t     _root_shpid;$/;"	m	struct:btree_overwrite_t
_root_shpid	btree_logrec.h	/^    shpid_t     _root_shpid;$/;"	m	struct:btree_update_t
_running	bf_tree_cleaner.h	/^    lintel::Atomic<bool> _running;$/;"	m	class:bf_tree_cleaner_slave_thread_t
_running	lock_raw.h	/^    bool            _running;$/;"	m	class:RawLockBackgroundThread
_sanity_check	log_core.cpp	/^void log_common::_sanity_check() const$/;"	f	class:log_common
_save_pt	xct.h	/^    lsn_t  _save_pt;$/;"	m	class:auto_rollback_t
_save_work	sm.cpp	/^ss_m::_save_work(sm_save_point_t& sp)$/;"	f	class:ss_m
_scavenge_cond	log_storage.h	/^    pthread_cond_t      _scavenge_cond;$/;"	m	class:log_storage
_scavenge_lock	log_storage.h	/^    pthread_mutex_t     _scavenge_lock;$/;"	m	class:log_storage
_seg_count	logbuf_core.h	/^    uint32_t _seg_count;  \/\/ current number of segments in the log buffer           $/;"	m	class:logbuf_core
_seg_list	logbuf_core.h	/^    logbuf_seg_list_t *_seg_list;  \/\/ doubly-linked list, protected by _logbuf_lock$/;"	m	class:logbuf_core
_seg_list_lock	logbuf_core.h	/^    tatas_lock _seg_list_lock; \/\/ not used as of now$/;"	m	class:logbuf_core
_segsize	log_core.h	/^    long _segsize; \/\/ log buffer size$/;"	m	class:log_common
_segsize	log_storage.h	/^    long            _segsize;$/;"	m	class:log_storage
_set_current_page	btcursor.cpp	/^void bt_cursor_t::_set_current_page(btree_page_h &page) {$/;"	f	class:bt_cursor_t
_set_fhdl_app	partition.h	/^    void              _set_fhdl_app(int fd) {$/;"	f	class:partition_t
_set_last_skip_lsn	partition.h	/^    void              _set_last_skip_lsn(const lsn_t &l) { _last_skip_lsn = l;}$/;"	f	class:partition_t
_set_recovery_mode	sm.cpp	/^void ss_m::_set_recovery_mode()$/;"	f	class:ss_m
_set_size	log_storage.cpp	/^w_rc_t log_storage::_set_size(fileoff_t size)$/;"	f	class:log_storage
_set_state	partition.h	/^    void               _set_state(uint32_t m) { _mask |= m ; }$/;"	f	class:partition_t
_set_store_property	smfile.cpp	/^ss_m::_set_store_property($/;"	f	class:ss_m
_setdebuginfo	crash.cpp	/^_setdebuginfo($/;"	f
_shared_latch	lock_x.h	/^    srwlock_t _shared_latch;$/;"	m	class:xct_lock_info_t
_shpid	logrec.h	/^    shpid_t             _shpid; \/\/ 4 bytes$/;"	m	struct:baseLogHeader
_shutting_down	log_core.h	/^    lintel::Atomic<bool> _shutting_down;$/;"	m	class:log_common
_single_log_sys_xct	xct.h	/^    bool                         _single_log_sys_xct;$/;"	m	class:xct_t
_size	backup.h	/^    size_t  _size;$/;"	m	class:AlignedMemory
_size	bf_hashtable.h	/^    uint32_t            _size;$/;"	m	class:bf_hashtable
_size	logbuf_hashtable.h	/^    uint32_t            _size;$/;"	m	class:logbuf_hashtable
_size	partition.h	/^    fileoff_t             _size;$/;"	m	class:partition_t
_size	pmap.h	/^    enum    { _size = smlevel_0::ext_map_sz_in_bytes };$/;"	e	enum:Pmap::__anon37
_skip	partition.cpp	/^partition_t::_skip(const lsn_t &ll, int fd)$/;"	f	class:partition_t
_skip_log	log_storage.h	/^    skip_log*           _skip_log;$/;"	m	class:log_storage
_slave_threads	bf_tree_cleaner.h	/^    bf_tree_cleaner_slave_thread_t** _slave_threads;$/;"	m	class:bf_tree_cleaner
_slave_threads_size	bf_tree_cleaner.h	/^    const unsigned _slave_threads_size;$/;"	m	class:bf_tree_cleaner
_slot	btcursor.h	/^    slotid_t    _slot;$/;"	m	class:bt_cursor_t
_slot_mark	log_carray.h	/^    int32_t             _slot_mark;$/;"	m	class:ConsolidationArray
_smthread_block	smthread.cpp	/^w_error_codes  smthread_t::_smthread_block($/;"	f	class:smthread_t
_smthread_unblock	smthread.cpp	/^w_rc_t    smthread_t::_smthread_unblock(w_error_codes e)$/;"	f	class:smthread_t
_snum	logrec.h	/^    snum_t              _snum; \/\/ 4 bytes$/;"	m	struct:baseLogHeader
_snum	stnode_page.h	/^        snum_t                _snum;$/;"	m	class:store_operation_param
_sort_buffer	bf_tree_cleaner.h	/^    uint64_t*                   _sort_buffer;$/;"	m	class:bf_tree_cleaner_slave_thread_t
_sort_buffer_size	bf_tree_cleaner.h	/^    size_t                      _sort_buffer_size;$/;"	m	class:bf_tree_cleaner_slave_thread_t
_source	btree_page_h.h	/^    fixable_page_h* _source;$/;"	m	class:borrowed_btree_page_h
_space_available	log_resv.h	/^    fileoff_t       _space_available; \/\/ how many unreserved bytes left$/;"	m	class:log_resv
_space_cond	log_resv.h	/^    pthread_cond_t          _space_cond; \/\/ tied to _space_lock$/;"	m	class:log_resv
_space_lock	log_resv.h	/^    pthread_mutex_t         _space_lock; \/\/ tied to _space_cond$/;"	m	class:log_resv
_space_rsvd_for_chkpt	log_resv.h	/^    fileoff_t       _space_rsvd_for_chkpt; \/\/ can we run a chkpt now?$/;"	m	class:log_resv
_special_pages	stnode_page.h	/^    bf_fixed_m*   _special_pages;      \/\/\/ The buffer manager holding the volume's special pages$/;"	m	class:stnode_cache_t
_spin_lock	lock_lil.h	/^    tatas_lock _spin_lock;$/;"	m	class:lil_global_table_base
_spin_lock	stnode_page.h	/^    mutable queue_based_lock_t _spin_lock;$/;"	m	class:stnode_cache_t
_ssx_chain_len	xct.h	/^    uint32_t                     _ssx_chain_len;$/;"	m	class:xct_t
_start	log_core.h	/^    long _start; \/\/ byte number of oldest unwritten byte$/;"	m	class:log_common
_start_requested	bf_tree_cleaner.h	/^    lintel::Atomic<bool> _start_requested;$/;"	m	class:bf_tree_cleaner_slave_thread_t
_state	xct.h	/^        state_t                   _state;$/;"	m	struct:xct_t::xct_core
_steal_records	btree_page_h.cpp	/^void btree_page_h::_steal_records(btree_page_h* steal_src,$/;"	f	class:btree_page_h
_stnode_cache	vol.h	/^    stnode_cache_t*  _stnode_cache;$/;"	m	class:vol_t
_stnode_page	stnode_page.h	/^    stnode_page_h _stnode_page;        \/\/\/ The stnode_page of the volume we are caching$/;"	m	class:stnode_cache_t
_stop_requested	bf_tree_cleaner.h	/^    lintel::Atomic<bool> _stop_requested;$/;"	m	class:bf_tree_cleaner_slave_thread_t
_stop_requested	lock_raw.h	/^    bool            _stop_requested;$/;"	m	class:RawLockBackgroundThread
_storage	log_core.h	/^    log_storage*    _storage;$/;"	m	class:log_common
_storage	log_resv.h	/^    log_storage*    _storage;$/;"	m	class:log_resv
_store	btcursor.h	/^    stid_t      _store;$/;"	m	class:bt_cursor_t
_store	lock_lil.h	/^    uint32_t    _store;    \/\/ +4 -> 4. zero if this table is not used yet.$/;"	m	class:lil_private_store_table
_store_num	bf_tree_cb.h	/^    snum_t                     _store_num;            \/\/ +4 -> 56$/;"	m	struct:bf_tree_cb_t
_store_tables	lock_lil.h	/^    lil_global_store_table _store_tables[stnode_page_h::max]; \/\/ for all possible stores$/;"	m	class:lil_global_vol_table
_store_tables	lock_lil.h	/^    lil_private_store_table _store_tables[MAX_STORE_PER_VOL_XCT]; \/\/ 8 * MAX_STORE_PER_VOL_XCT$/;"	m	class:lil_private_vol_table
_stores	lock_lil.h	/^    uint16_t    _stores;   \/\/ +2 -> 4. number of stores used in _store_tables$/;"	m	class:lil_private_vol_table
_storesToFree	xct.h	/^        w_list_t<stid_list_elem_t,queue_based_lock_t>    _storesToFree;$/;"	m	struct:xct_t::xct_core
_string_options	sm_options.h	/^    std::map<std::string, std::string> _string_options;$/;"	m	class:sm_options
_swizzle_child_pointer	bf_tree.cpp	/^void bf_tree_m::_swizzle_child_pointer(generic_page* parent, shpid_t* pointer_addr) {$/;"	f	class:bf_tree_m
_swizzled	bf_tree_cb.h	/^    bool                        _swizzled;      \/\/ +1 -> 29$/;"	m	struct:bf_tree_cb_t
_swizzled_page_count_approximate	bf_tree.h	/^    int32_t              _swizzled_page_count_approximate;$/;"	m	class:bf_tree_m
_swizzled_ptr_cnt_hint	bf_tree_cb.h	/^    uint16_t                    _swizzled_ptr_cnt_hint; \/\/ +2 -> 50$/;"	m	struct:bf_tree_cb_t
_sx_adopt_foster	btree_impl_split.cpp	/^rc_t btree_impl::_sx_adopt_foster (btree_page_h &parent, btree_page_h &child) {$/;"	f	class:btree_impl
_sx_adopt_foster_all	btree_impl_split.cpp	/^rc_t btree_impl::_sx_adopt_foster_all (btree_page_h &root, bool recursive)$/;"	f	class:btree_impl
_sx_adopt_foster_all_core	btree_impl_split.cpp	/^rc_t btree_impl::_sx_adopt_foster_all_core ($/;"	f	class:btree_impl
_sx_adopt_foster_sweep	btree_impl_split.cpp	/^rc_t btree_impl::_sx_adopt_foster_sweep (btree_page_h &parent_arg)$/;"	f	class:btree_impl
_sx_adopt_foster_sweep_approximate	btree_impl_split.cpp	/^rc_t btree_impl::_sx_adopt_foster_sweep_approximate (btree_page_h &parent,$/;"	f	class:btree_impl
_sx_create_tree	btree_impl_grow.cpp	/^rc_t btree_impl::_sx_create_tree(const stid_t &stid, lpid_t &root_pid)$/;"	f	class:btree_impl
_sx_deadopt_foster	btree_impl_merge.cpp	/^rc_t btree_impl::_sx_deadopt_foster(btree_page_h &real_parent, slotid_t foster_parent_slot)$/;"	f	class:btree_impl
_sx_defrag_page	btree_impl_defrag.cpp	/^rc_t btree_impl::_sx_defrag_page(btree_page_h &page)$/;"	f	class:btree_impl
_sx_defrag_tree	btree_impl_defrag.cpp	/^rc_t btree_impl::_sx_defrag_tree($/;"	f	class:btree_impl
_sx_grow_tree	btree_impl_grow.cpp	/^btree_impl::_sx_grow_tree(btree_page_h& rp)$/;"	f	class:btree_impl
_sx_merge_foster	btree_impl_merge.cpp	/^rc_t btree_impl::_sx_merge_foster(btree_page_h &page)$/;"	f	class:btree_impl
_sx_norec_alloc	btree_impl_split.cpp	/^rc_t btree_impl::_sx_norec_alloc(btree_page_h &page, lpid_t &new_page_id) {$/;"	f	class:btree_impl
_sx_opportunistic_adopt_foster	btree_impl_split.cpp	/^rc_t btree_impl::_sx_opportunistic_adopt_foster (btree_page_h &parent,$/;"	f	class:btree_impl
_sx_rebalance_foster	btree_impl_merge.cpp	/^rc_t btree_impl::_sx_rebalance_foster(btree_page_h &page)$/;"	f	class:btree_impl
_sx_rebalance_foster	btree_impl_merge.cpp	/^rc_t btree_impl::_sx_rebalance_foster(btree_page_h &page,        \/\/ In\/Out: source page, foster parent$/;"	f	class:btree_impl
_sx_reserve_ghost	btree_impl.cpp	/^rc_t btree_impl::_sx_reserve_ghost(btree_page_h &leaf, const w_keystr_t &key, int elem_len)$/;"	f	class:btree_impl
_sx_shrink_tree	btree_impl_grow.cpp	/^btree_impl::_sx_shrink_tree(btree_page_h& rp)$/;"	f	class:btree_impl
_sx_split_foster	btree_impl_split.cpp	/^rc_t btree_impl::_sx_split_foster(btree_page_h &page,                \/\/ In: source page, foster parent$/;"	f	class:btree_impl
_sx_split_foster_new	btree_impl_split.cpp	/^rc_t btree_impl::_sx_split_foster_new(btree_page_h& page, lpid_t& new_page_id,$/;"	f	class:btree_impl
_sx_split_if_needed	btree_impl_split.cpp	/^rc_t btree_impl::_sx_split_if_needed (btree_page_h &page, const w_keystr_t &new_key) {$/;"	f	class:btree_impl
_sx_update_child_emlsn	bf_tree.cpp	/^w_rc_t bf_tree_m::_sx_update_child_emlsn(btree_page_h &parent, general_recordid_t child_slotid,$/;"	f	class:bf_tree_m
_sync_logbuf	xct.cpp	/^xct_t::_sync_logbuf(bool block, bool signal)$/;"	f	class:xct_t
_sys_xct	xct.h	/^    bool                         _sys_xct;$/;"	m	class:xct_t
_table	bf_hashtable.h	/^    bf_hashbucket<T>*      _table;$/;"	m	class:bf_hashtable
_table	logbuf_hashtable.h	/^    logbuf_hashbucket*      _table;$/;"	m	class:logbuf_hashtable
_table_bucket	lock_core.h	/^    uint32_t        _table_bucket(uint32_t id) const { return id % _htabsz; }$/;"	f	class:lock_core_m
_tail	lock_bucket.h	/^    lock_queue_entry_t* _tail;$/;"	m	class:lock_queue_t
_tail	lock_x.h	/^    xct_lock_entry_t *_tail;$/;"	m	class:xct_lock_info_t
_tail_size	logbuf_core.h	/^    uint32_t _tail_size; \/\/ total size of tail blocks$/;"	m	class:logbuf_core
_take_interval	bf_tree_cleaner.cpp	/^void bf_tree_cleaner_slave_thread_t::_take_interval()$/;"	f	class:bf_tree_cleaner_slave_thread_t
_tb_cond	bf_transit_bucket.h	/^    pthread_cond_t _tb_cond;$/;"	m	class:transit_bucket_t
_tb_mutex	bf_transit_bucket.h	/^    pthread_mutex_t _tb_mutex; \/\/ paired with _tb_cond$/;"	m	class:transit_bucket_t
_tcb_tail	smthread.h	/^    tcb_t*  _tcb_tail;$/;"	m	class:smthread_t
_teardown	xct.cpp	/^xct_t::_teardown(bool is_chaining) {$/;"	f	class:xct_t
_test	xct.h	/^    int    _test;$/;"	m	class:auto_rollback_t
_the_xct	prologue.h	/^    xct_t *           _the_xct; \/\/ attached xct when we constructed prologue$/;"	m	class:prologue_rc_t
_thr	lock_bucket.h	/^    smthread_t&         _thr;  \/\/\/< owning thread.$/;"	m	class:lock_queue_entry_t
_thread	lock_raw.h	/^    pthread_t       _thread;$/;"	m	class:RawLockBackgroundThread
_threads_attached	xct.h	/^        lintel::Atomic<int> _threads_attached;$/;"	m	struct:xct_t::xct_core
_ticker	sm.cpp	/^ticker_thread_t* smlevel_0::_ticker = 0;$/;"	m	class:smlevel_0	file:
_ticker	sm_base.h	/^    static ticker_thread_t* _ticker;$/;"	m	class:smlevel_0
_tid	lock_x.h	/^    tid_t           _tid;$/;"	m	class:xct_lock_info_t
_tid	sm.h	/^    tid_t            _tid;$/;"	m	class:sm_save_point_t
_tid	xct.h	/^        tid_t                  _tid;$/;"	m	struct:xct_t::xct_core
_tid	xct.h	/^    tid_t                        _tid;$/;"	m	class:xct_t
_timeout	xct.h	/^        timeout_in_ms          _timeout; \/\/ default timeout value for lock reqs$/;"	m	struct:xct_t::xct_core
_tmp_next_key_buf	btcursor.h	/^    w_keystr_t  _tmp_next_key_buf;$/;"	m	class:bt_cursor_t
_to_archive_lsn	logbuf_core.h	/^    lsn_t _to_archive_lsn;  $/;"	m	class:logbuf_core
_to_archive_seg	logbuf_core.h	/^    logbuf_seg *_to_archive_seg;  $/;"	m	class:logbuf_core
_to_flush_lsn	logbuf_core.h	/^    lsn_t _to_flush_lsn;  \/\/ same as _durable_lsn$/;"	m	class:logbuf_core
_to_flush_seg	logbuf_core.h	/^    logbuf_seg *_to_flush_seg;  $/;"	m	class:logbuf_core
_to_insert_lsn	logbuf_core.h	/^    lsn_t _to_insert_lsn;  \/\/ same as _curr_lsn$/;"	m	class:logbuf_core
_to_insert_seg	logbuf_core.h	/^    logbuf_seg *_to_insert_seg;  $/;"	m	class:logbuf_core
_toggle	prologue.h	/^    xct_log_switch_t* _toggle;$/;"	m	class:prologue_rc_t
_transit_buckets	bf_transit_bucket.h	/^    static transit_bucket_t   _transit_buckets[NUM_TRANSIT_BUCKETS];$/;"	m	class:transit_bucket_t
_truncate_log	sm.cpp	/^rc_t ss_m::_truncate_log(bool ignore_chkpt)$/;"	f	class:ss_m
_try_initialize_fingerprint	smthread.cpp	/^bool smthread_t::_try_initialize_fingerprint() $/;"	f	class:smthread_t
_try_recover_page	bf_tree.cpp	/^w_rc_t bf_tree_m::_try_recover_page(generic_page* parent,     \/\/ In: parent page$/;"	f	class:bf_tree_m
_type	logrec.h	/^    u_char             _type; \/\/ kind_t (included from logtype_gen.h)$/;"	m	struct:baseLogHeader
_u	stnode_page.h	/^        } _u;$/;"	m	class:store_operation_param	typeref:union:store_operation_param::__anon44
_uncommitted_cnt	bf_tree_cb.h	/^    uint16_t                    _uncommitted_cnt; \/\/ +2 -> 58$/;"	m	struct:bf_tree_cb_t
_undo_nxt	xct.h	/^    lsn_t                        _undo_nxt;$/;"	m	class:xct_t
_undo_txn_pass	restart.cpp	/^void restart_m::_undo_txn_pass()$/;"	f	class:restart_m
_uninitialize_fingerprint	smthread.cpp	/^void smthread_t::_uninitialize_fingerprint() $/;"	f	class:smthread_t
_unix_fd	bf_fixed.h	/^    int         _unix_fd;$/;"	m	class:bf_fixed_m
_unix_fd	vol.h	/^    int              _unix_fd;$/;"	m	class:vol_t
_unswizzle_a_frame	bf_tree.cpp	/^bool bf_tree_m::_unswizzle_a_frame(bf_idx parent_idx, uint32_t child_slot) {$/;"	f	class:bf_tree_m
_unused1	lock_lil.h	/^    uint16_t    _unused1;   \/\/ +2 -> 4$/;"	m	class:lil_private_table
_unused2	lock_lil.h	/^    uint32_t    _unused2;   \/\/ +4 -> 8$/;"	m	class:lil_private_table
_update_btree_consecutive_skewed_insertions	btree_page_h.cpp	/^void btree_page_h::_update_btree_consecutive_skewed_insertions(slotid_t slot) {$/;"	f	class:btree_page_h
_update_epochs	log_core.cpp	/^bool log_core::_update_epochs(CArraySlot* info) {$/;"	f	class:log_core
_update_epochs	logbuf_core.cpp	/^bool logbuf_core::_update_epochs(CArraySlot* info) {$/;"	f	class:logbuf_core
_update_page_cas	plog_xct.cpp	/^rc_t plog_xct_t::_update_page_cas(logrec_t* lr)$/;"	f	class:plog_xct_t
_update_page_lsns	plog_xct.cpp	/^void plog_xct_t::_update_page_lsns(const fixable_page_h *page)$/;"	f	class:plog_xct_t
_update_page_lsns	xct.cpp	/^void xct_t::_update_page_lsns(const fixable_page_h *page, const lsn_t &new_lsn) {$/;"	f	class:xct_t
_updating_operations	xct.h	/^        lintel::Atomic<int> _updating_operations;$/;"	m	struct:xct_t::xct_core
_upper	btcursor.h	/^    w_keystr_t  _upper;$/;"	m	class:bt_cursor_t
_upper_inclusive	btcursor.h	/^    bool        _upper_inclusive;$/;"	m	class:bt_cursor_t
_used	bf_tree_cb.h	/^    bool _used;          \/\/ +1  -> 2$/;"	m	struct:bf_tree_cb_t
_used	mem_mgmt.h	/^    size_t _used;$/;"	m	class:fixed_lists_mem_t
_used_count	bf_hashtable.cpp	/^    uint32_t _used_count;$/;"	m	class:bf_hashbucket	file:
_used_count	logbuf_hashtable.cpp	/^    uint32_t _used_count;$/;"	m	class:logbuf_hashbucket	file:
_used_size	plog.h	/^    uint32_t    _used_size;$/;"	m	class:plog_t
_ux_adopt_foster_apply_child	btree_impl_split.cpp	/^void btree_impl::_ux_adopt_foster_apply_child (btree_page_h &child)$/;"	f	class:btree_impl
_ux_adopt_foster_apply_parent	btree_impl_split.cpp	/^void btree_impl::_ux_adopt_foster_apply_parent (btree_page_h &parent,$/;"	f	class:btree_impl
_ux_adopt_foster_core	btree_impl_split.cpp	/^rc_t btree_impl::_ux_adopt_foster_core (btree_page_h &parent, btree_page_h &child,$/;"	f	class:btree_impl
_ux_assure_fence_low_entry	btree_impl_lock.cpp	/^rc_t btree_impl::_ux_assure_fence_low_entry(btree_page_h &leaf)$/;"	f	class:btree_impl
_ux_create_tree_core	btree_impl_grow.cpp	/^rc_t btree_impl::_ux_create_tree_core(const stid_t &stid, const lpid_t &root_pid)$/;"	f	class:btree_impl
_ux_deadopt_foster_apply_foster_parent	btree_impl_merge.cpp	/^void btree_impl::_ux_deadopt_foster_apply_foster_parent(btree_page_h &foster_parent,$/;"	f	class:btree_impl
_ux_deadopt_foster_apply_real_parent	btree_impl_merge.cpp	/^void btree_impl::_ux_deadopt_foster_apply_real_parent(btree_page_h &real_parent,$/;"	f	class:btree_impl
_ux_deadopt_foster_core	btree_impl_merge.cpp	/^rc_t btree_impl::_ux_deadopt_foster_core(btree_page_h &real_parent, slotid_t foster_parent_slot)$/;"	f	class:btree_impl
_ux_defrag_page_core	btree_impl_defrag.cpp	/^rc_t btree_impl::_ux_defrag_page_core(btree_page_h &page)$/;"	f	class:btree_impl
_ux_defrag_tree_core	btree_impl_defrag.cpp	/^rc_t btree_impl::_ux_defrag_tree_core($/;"	f	class:btree_impl
_ux_get_page_and_status	btree_impl.cpp	/^btree_impl::_ux_get_page_and_status(stid_t store,$/;"	f	class:btree_impl
_ux_insert	btree_impl.cpp	/^btree_impl::_ux_insert($/;"	f	class:btree_impl
_ux_insert_core	btree_impl.cpp	/^btree_impl::_ux_insert_core($/;"	f	class:btree_impl
_ux_insert_core_tail	btree_impl.cpp	/^rc_t btree_impl::_ux_insert_core_tail(stid_t store,$/;"	f	class:btree_impl
_ux_lock_key	btree_impl_lock.cpp	/^btree_impl::_ux_lock_key($/;"	f	class:btree_impl
_ux_lock_key	btree_impl_lock.cpp	/^rc_t btree_impl::_ux_lock_key($/;"	f	class:btree_impl
_ux_lock_range	btree_impl_lock.cpp	/^btree_impl::_ux_lock_range(const stid_t&     stid,$/;"	f	class:btree_impl
_ux_lock_range	btree_impl_lock.cpp	/^btree_impl::_ux_lock_range(const stid_t&    stid,$/;"	f	class:btree_impl
_ux_lookup	btree_impl_search.cpp	/^btree_impl::_ux_lookup(stid_t store, const w_keystr_t& key, bool& found,$/;"	f	class:btree_impl
_ux_lookup_core	btree_impl_search.cpp	/^btree_impl::_ux_lookup_core(stid_t store, const w_keystr_t& key, $/;"	f	class:btree_impl
_ux_merge_foster_apply_parent	btree_impl_merge.cpp	/^void btree_impl::_ux_merge_foster_apply_parent($/;"	f	class:btree_impl
_ux_merge_foster_core	btree_impl_merge.cpp	/^rc_t btree_impl::_ux_merge_foster_core(btree_page_h &page,      \/\/ In\/Out: destination, foster parent page$/;"	f	class:btree_impl
_ux_norec_alloc_core	btree_impl_split.cpp	/^rc_t btree_impl::_ux_norec_alloc_core(btree_page_h &page, lpid_t &new_page_id) {$/;"	f	class:btree_impl
_ux_overwrite	btree_impl.cpp	/^rc_t btree_impl::_ux_overwrite($/;"	f	class:btree_impl
_ux_overwrite_core	btree_impl.cpp	/^rc_t btree_impl::_ux_overwrite_core($/;"	f	class:btree_impl
_ux_put	btree_impl.cpp	/^btree_impl::_ux_put($/;"	f	class:btree_impl
_ux_put_core	btree_impl.cpp	/^btree_impl::_ux_put_core($/;"	f	class:btree_impl
_ux_rebalance_foster_apply	btree_impl_merge.cpp	/^rc_t btree_impl::_ux_rebalance_foster_apply($/;"	f	class:btree_impl
_ux_rebalance_foster_core	btree_impl_merge.cpp	/^rc_t btree_impl::_ux_rebalance_foster_core($/;"	f	class:btree_impl
_ux_rebalance_foster_norec	btree_impl_merge.cpp	/^rc_t btree_impl::_ux_rebalance_foster_norec(btree_page_h &page,$/;"	f	class:btree_impl
_ux_remove	btree_impl.cpp	/^btree_impl::_ux_remove(stid_t store, const w_keystr_t &key, const bool undo)$/;"	f	class:btree_impl
_ux_remove_core	btree_impl.cpp	/^btree_impl::_ux_remove_core(stid_t store, const w_keystr_t &key, const bool undo)$/;"	f	class:btree_impl
_ux_reserve_ghost_core	btree_impl.cpp	/^rc_t btree_impl::_ux_reserve_ghost_core(btree_page_h &leaf, const w_keystr_t &key, int elem_len) {$/;"	f	class:btree_impl
_ux_shrink_tree_core	btree_impl_grow.cpp	/^btree_impl::_ux_shrink_tree_core(btree_page_h& rp)$/;"	f	class:btree_impl
_ux_traverse	btree_impl_search.cpp	/^btree_impl::_ux_traverse(stid_t store, const w_keystr_t &key,$/;"	f	class:btree_impl
_ux_traverse_recurse	btree_impl_search.cpp	/^btree_impl::_ux_traverse_recurse(btree_page_h&                start,$/;"	f	class:btree_impl
_ux_traverse_search	btree_impl_search.cpp	/^void btree_impl::_ux_traverse_search(btree_impl::traverse_mode_t traverse_mode,$/;"	f	class:btree_impl
_ux_traverse_try_eager_adopt	btree_impl_search.cpp	/^rc_t btree_impl::_ux_traverse_try_eager_adopt(btree_page_h &current, $/;"	f	class:btree_impl
_ux_traverse_try_opportunistic_adopt	btree_impl_search.cpp	/^rc_t btree_impl::_ux_traverse_try_opportunistic_adopt(btree_page_h &current, $/;"	f	class:btree_impl
_ux_undo_ghost_mark	btree_impl.cpp	/^btree_impl::_ux_undo_ghost_mark(stid_t store, const w_keystr_t &key)$/;"	f	class:btree_impl
_ux_update	btree_impl.cpp	/^btree_impl::_ux_update(stid_t store, const w_keystr_t &key, const cvec_t &el, const bool undo)$/;"	f	class:btree_impl
_ux_update_core	btree_impl.cpp	/^btree_impl::_ux_update_core(stid_t store, const w_keystr_t &key, const cvec_t &el, const bool undo)$/;"	f	class:btree_impl
_ux_update_core_tail	btree_impl.cpp	/^btree_impl::_ux_update_core_tail(stid_t store,$/;"	f	class:btree_impl
_ux_verify_feed_page	btree_impl_verify.cpp	/^rc_t btree_impl::_ux_verify_feed_page($/;"	f	class:btree_impl
_ux_verify_tree	btree_impl_verify.cpp	/^rc_t  btree_impl::_ux_verify_tree($/;"	f	class:btree_impl
_ux_verify_tree_recurse	btree_impl_verify.cpp	/^rc_t btree_impl::_ux_verify_tree_recurse($/;"	f	class:btree_impl
_ux_verify_volume	btree_impl_verify.cpp	/^rc_t btree_impl::_ux_verify_volume($/;"	f	class:btree_impl
_validate_access	bf_tree.cpp	/^w_rc_t bf_tree_m::_validate_access(generic_page*& page)   \/\/ pointer to the underlying page _pp$/;"	f	class:bf_tree_m
_value1	stnode_page.h	/^                uint16_t      _value1;$/;"	m	struct:store_operation_param::__anon44::__anon45
_value2	stnode_page.h	/^                uint16_t      _value2;$/;"	m	struct:store_operation_param::__anon44::__anon45
_version_major	log_storage.cpp	/^const uint32_t log_storage::_version_major = 6;$/;"	m	class:log_storage	file:
_version_major	log_storage.h	/^    static const uint32_t  _version_major;$/;"	m	class:log_storage
_version_minor	log_storage.cpp	/^const uint32_t log_storage::_version_minor = 1;$/;"	m	class:log_storage	file:
_version_minor	log_storage.h	/^    static const uint32_t  _version_minor;$/;"	m	class:log_storage
_victim	prologue.h	/^    xct_t*            _victim;$/;"	m	class:prologue_rc_t
_vid	backup.h	/^    vid_t _vid;$/;"	m	class:BackupFile
_vid	lock_lil.h	/^    uint16_t    _vid;      \/\/ +2 -> 2. zero if this table is not used yet.$/;"	m	class:lil_private_vol_table
_vid	logrec.h	/^    vid_t               _vid;   \/\/ 2 bytes$/;"	m	struct:baseLogHeader
_vid	stnode_page.h	/^    const vid_t   _vid;                \/\/\/ The volume number of the volume we are caching$/;"	m	class:stnode_cache_t
_vid	vol.h	/^    vid_t            _vid;$/;"	m	class:vol_t
_vol	sm_s.h	/^    vid_t          _vol;$/;"	m	class:lpid_t
_vol_tables	lock_lil.h	/^    lil_global_vol_table _vol_tables[MAX_VOL_GLOBAL];$/;"	m	class:lil_global_table
_vol_tables	lock_lil.h	/^    lil_private_vol_table _vol_tables[MAX_VOL_PER_XCT];$/;"	m	class:lil_private_table
_volume	bf_tree_vol.h	/^    vol_t* _volume;$/;"	m	struct:bf_tree_vol_t
_volumes	bf_tree.h	/^    bf_tree_vol_t*       _volumes[vol_m::MAX_VOLS + 1];$/;"	m	class:bf_tree_m
_volumes	lock_lil.h	/^    uint16_t    _volumes;   \/\/ +2 -> 2. number of volumes used in _vol_tables$/;"	m	class:lil_private_table
_wait_cond	log_core.h	/^    pthread_cond_t       _wait_cond;  \/\/ paired with _wait_flush_lock$/;"	m	class:log_common
_wait_flush_lock	log_core.h	/^    pthread_mutex_t      _wait_flush_lock;$/;"	m	class:log_common
_wait_map	lock_x.h	/^    atomic_thread_map_t  _wait_map; \/\/ for dreadlocks DLD$/;"	m	class:xct_lock_info_t
_waiter_cond	lock_lil.h	/^    pthread_cond_t      _waiter_cond;$/;"	m	class:lil_global_table_base
_waiter_mutex	lock_lil.h	/^    pthread_mutex_t     _waiter_mutex;$/;"	m	class:lil_global_table_base
_waiting	smthread.h	/^    bool            _waiting;$/;"	m	class:smthread_t
_waiting_S	lock_lil.h	/^    uint16_t  _waiting_S; \/\/ +2 -> 10$/;"	m	class:lil_global_table_base
_waiting_X	lock_lil.h	/^    uint16_t  _waiting_X; \/\/ +2 -> 12$/;"	m	class:lil_global_table_base
_waiting_for_flush	log_core.h	/^    bool _waiting_for_flush; \/\/ protected by log_m::_wait_flush_lock$/;"	m	class:log_common
_waiting_for_space	log_resv.h	/^    bool _waiting_for_space; \/\/ protected by log_m::_insert_lock\/_wait_flush_lock$/;"	m	class:log_resv
_wakeup_a_cleaner	bf_tree_cleaner.cpp	/^w_rc_t bf_tree_cleaner::_wakeup_a_cleaner(unsigned id)$/;"	f	class:bf_tree_cleaner
_wakeup_requested	bf_tree_cleaner.h	/^    lintel::Atomic<bool> _wakeup_requested;$/;"	m	class:bf_tree_cleaner_slave_thread_t
_warn_on	xct.h	/^        bool                   _warn_on;$/;"	m	struct:xct_t::xct_core
_write_buffer	bf_tree_cleaner.h	/^    generic_page*                     _write_buffer;$/;"	m	class:bf_tree_cleaner_slave_thread_t
_write_buffer_indexes	bf_tree_cleaner.h	/^    bf_idx*                     _write_buffer_indexes;$/;"	m	class:bf_tree_cleaner_slave_thread_t
_write_master	log_storage.cpp	/^void log_storage::_write_master(const lsn_t &l, const lsn_t &min)$/;"	f	class:log_storage
_writebuf	log_core.h	/^    char*           _writebuf;$/;"	m	class:log_common
_x_lock_tag	lock_bucket.h	/^    lsn_t          _x_lock_tag;$/;"	m	class:lock_queue_t
_x_lock_tag	lock_lil.h	/^    lsn_t               _x_lock_tag; \/\/ +8 -> 24. this is for Safe SX-ELR$/;"	m	class:lil_global_table_base
_xct	lock_bucket.h	/^    xct_t&              _xct;  \/\/\/< owning xct.$/;"	m	class:lock_queue_entry_t
_xct	xct.h	/^    xct_t*        _xct;$/;"	m	class:xct_auto_abort_t
_xct	xct.h	/^    xct_t* _xct;$/;"	m	class:auto_release_anchor_t
_xct_aborting	xct.h	/^        bool              _xct_aborting; \/\/ distinguish abort()ing xct from$/;"	m	struct:xct_t::xct_core
_xct_chain_len	xct.h	/^    uint32_t                     _xct_chain_len;$/;"	m	class:xct_t
_xct_ended	xct.h	/^        lintel::Atomic<int> _xct_ended; \/\/ used for self-checking (assertions) only$/;"	m	struct:xct_t::xct_core
_xct_entry	lock_bucket.h	/^    xct_lock_entry_t*   _xct_entry;$/;"	m	class:lock_queue_entry_t
_xct_log	smthread.h	/^        xct_log_t         *_xct_log;$/;"	m	struct:smthread_t::tcb_t
_xct_log_off	xct.h	/^    bool         _xct_log_off;$/;"	m	class:xct_log_t
_xct_pool	lock_core.h	/^    GcPoolForest<RawXct>*       _xct_pool;$/;"	m	class:lock_core_m
_xct_pool	lock_raw.h	/^    GcPoolForest<RawXct>*      _xct_pool;$/;"	m	class:RawLockBackgroundThread
_xct_state	prologue.h	/^    xct_state_t       _xct_state;$/;"	m	class:prologue_rc_t
_xctpool_initseg	lock_raw.h	/^    uint32_t            _xctpool_initseg;$/;"	m	class:RawLockBackgroundThread
_xctpool_segsize	lock_raw.h	/^    size_t              _xctpool_segsize;$/;"	m	class:RawLockBackgroundThread
_xd	sm_base.h	/^    xct_t* _xd;$/;"	m	struct:check_compensated_op_nesting
_xd	xct.h	/^    xct_t* _xd;$/;"	m	class:auto_rollback_t
_xd	xct_dependent.h	/^    xct_t *     _xd;$/;"	m	class:xct_dependent_t
_xid	logrec.h	/^    tid_t               _xid;      \/\/ NOT IN SINGLE-LOG SYSTEM TRANSACTION!  (xct)tid of this xct$/;"	m	struct:xidChainLogHeader
_xid_prv	logrec.h	/^    lsn_t               _xid_prv;     \/\/ NOT IN SINGLE-LOG SYSTEM TRANSACTION! (xct)previous logrec of this xct$/;"	m	struct:xidChainLogHeader
_xlink	xct.h	/^    w_link_t                      _xlink;$/;"	m	class:xct_t
_xlist	xct.h	/^    static w_descend_list_t<xct_t, queue_based_lock_t, tid_t> _xlist;$/;"	m	class:xct_t
_xlist_mutex	xct.cpp	/^        xct_t::_xlist(W_KEYED_ARG(xct_t, _tid,_xlink), &_xlist_mutex);$/;"	v
_xlist_mutex	xct.cpp	/^queue_based_lock_t        xct_t::_xlist_mutex;$/;"	m	class:xct_t	file:
_xlist_mutex	xct.h	/^    static queue_based_lock_t    _xlist_mutex;$/;"	m	class:xct_t
_xlist_mutex_node	smthread.h	/^        queue_based_lock_t::ext_qnode _xlist_mutex_node;$/;"	m	struct:smthread_t::tcb_t
abort	xct.cpp	/^xct_t::abort(bool save_stats_structure \/* = false *\/)$/;"	f	class:xct_t
abort	xct.h	/^    rc_t abort() {W_DO(_xct->abort()); return RCOK;}$/;"	f	class:xct_auto_abort_t
abort_xct	sm.cpp	/^ss_m::abort_xct()$/;"	f	class:ss_m
abort_xct	sm.cpp	/^ss_m::abort_xct(sm_stats_info_t*&             _stats)$/;"	f	class:ss_m
abortable_xct	prologue.h	/^        abortable_xct   \/\/ active or prepared$/;"	e	enum:prologue_rc_t::xct_state_t
aborttest	crash.cpp	/^aborttest() $/;"	f
accept_empty_child	btree_page_h.cpp	/^void btree_page_h::accept_empty_child(lsn_t new_lsn, shpid_t new_page_id, const bool f_redo) {$/;"	f	class:btree_page_h
account	logrec.cpp	/^void logrec_accounting_impl_t::account(logrec_t &l, bool fwd)$/;"	f	class:logrec_accounting_impl_t
account	logrec.cpp	/^void logrec_accounting_t::account(logrec_t &l, bool fwd)$/;"	f	class:logrec_accounting_t
account_end	logrec.cpp	/^void logrec_accounting_impl_t::account_end(bool fwd)$/;"	f	class:logrec_accounting_impl_t
account_end	logrec.cpp	/^void logrec_accounting_t::account_end(bool fwd)$/;"	f	class:logrec_accounting_t
acquire	lock_raw.cpp	/^w_error_codes RawLockQueue::acquire(RawXct* xct, uint32_t hash, const okvl_mode& mode,$/;"	f	class:RawLockQueue
acquire_1thread_log_mutex	xct.h	/^    void                         acquire_1thread_log_mutex() {$/;"	f	class:xct_t
acquire_1thread_xct_mutex	xct.cpp	/^xct_t::acquire_1thread_xct_mutex() const \/\/ default: true$/;"	f	class:xct_t
acquire_lock	lock_core.cpp	/^w_error_codes lock_core_m::acquire_lock(RawXct* xct, uint32_t hash, const okvl_mode& mode,$/;"	f	class:lock_core_m
acquire_partition_lock	log_storage.cpp	/^log_storage::acquire_partition_lock()$/;"	f	class:log_storage
acquire_scavenge_lock	log_storage.cpp	/^log_storage::acquire_scavenge_lock()$/;"	f	class:log_storage
acquire_store_lock	lock_lil.cpp	/^w_rc_t lil_private_vol_table::acquire_store_lock(lil_global_table *global_table, const stid_t &stid,$/;"	f	class:lil_private_vol_table
acquire_vol_store_lock	lock_lil.cpp	/^w_rc_t lil_private_table::acquire_vol_store_lock(lil_global_table *global_table, const stid_t &stid,$/;"	f	class:lil_private_table
acquire_vol_table	lock_lil.cpp	/^w_rc_t lil_private_table::acquire_vol_table(lil_global_table *global_table,$/;"	f	class:lil_private_table
acquire_xlist_mutex	xct.cpp	/^w_rc_t  xct_t::acquire_xlist_mutex()$/;"	f	class:xct_t
activate	logarchiver.cpp	/^bool ArchiverControl::activate(bool wait, lsn_t lsn)$/;"	f	class:ArchiverControl
activate	logarchiver.cpp	/^void LogArchiver::ReaderThread::activate(lsn_t endLSN)$/;"	f	class:LogArchiver::ReaderThread
activate	logarchiver.cpp	/^void LogArchiver::activate(lsn_t endLSN, bool wait)$/;"	f	class:LogArchiver
activateCond	logarchiver.h	/^    pthread_cond_t activateCond;$/;"	m	struct:ArchiverControl
activate_archiver	sm.cpp	/^ss_m::activate_archiver()$/;"	f	class:ss_m
activate_reservations	log_core.h	/^    virtual void                activate_reservations()$/;"	f	class:log_common
activate_reservations	log_resv.cpp	/^log_resv::activate_reservations(const lsn_t& curr_lsn)$/;"	f	class:log_resv
activated	logarchiver.h	/^    bool activated;$/;"	m	struct:ArchiverControl
active	logarchiver.h	/^            bool active;$/;"	m	struct:LogArchiver::ArchiveScanner::MergeHeapEntry
add	logarchiver.cpp	/^bool LogArchiver::BlockAssembly::add(logrec_t* lr)$/;"	f	class:LogArchiver::BlockAssembly
add	sm_du_stats.cpp	/^btree_int_stats_t::add(const btree_int_stats_t& stats)$/;"	f	class:btree_int_stats_t
add	sm_du_stats.cpp	/^btree_lf_stats_t::add(const btree_lf_stats_t& stats)$/;"	f	class:btree_lf_stats_t
add	sm_du_stats.cpp	/^btree_stats_t::add(const btree_stats_t& stats)$/;"	f	class:btree_stats_t
add	sm_du_stats.cpp	/^sm_du_stats_t::add(const sm_du_stats_t& stats)$/;"	f	class:sm_du_stats_t
add	sm_du_stats.cpp	/^volume_hdr_stats_t::add(const volume_hdr_stats_t& stats)$/;"	f	class:volume_hdr_stats_t
add	sm_du_stats.cpp	/^volume_map_stats_t::add(const volume_map_stats_t& stats)$/;"	f	class:volume_map_stats_t
addInput	logarchiver.cpp	/^void LogArchiver::ArchiveScanner::RunMerger::addInput(RunScanner* r)$/;"	f	class:LogArchiver::ArchiveScanner::RunMerger
add_backup	vol.cpp	/^void vol_t::add_backup(string path, lsn_t backupLSN)$/;"	f	class:vol_t
add_backup_log	logrec.cpp	/^add_backup_log::add_backup_log(vid_t vid, const char* dev_name)$/;"	f	class:add_backup_log
add_dependent	xct.cpp	/^xct_t::add_dependent(xct_dependent_t* dependent)$/;"	f	class:xct_t
add_expectation	btree_impl_verify.cpp	/^void verification_context::add_expectation ($/;"	f	class:verification_context
add_expectation	btree_verify.h	/^    void add_expectation (shpid_t pid, int16_t level, bool high, const w_keystr_t &key) {$/;"	f	class:verification_context
add_expectation	btree_verify.h	/^    void add_expectation (shpid_t pid, int16_t level, bool high, size_t key_len, const char* key) {$/;"	f	class:verification_context
add_fact	btree_impl_verify.cpp	/^void verification_context::add_fact (shpid_t pid, int16_t level, bool high,$/;"	f	class:verification_context
add_fact	btree_verify.h	/^    void add_fact (shpid_t pid, int16_t level, bool high, const w_keystr_t &key) {$/;"	f	class:verification_context
add_fact	btree_verify.h	/^    void add_fact (shpid_t pid, int16_t level, bool high, size_t key_len, const char* key) {$/;"	f	class:verification_context
add_from_TL_stats	smthread.cpp	/^smthread_t::add_from_TL_stats(sm_stats_info_t &w) const$/;"	f	class:smthread_t
add_from_global_stats	smstats.cpp	/^smlevel_0::add_from_global_stats(sm_stats_info_t &to)$/;"	f	class:smlevel_0
add_root_page	bf_tree_vol.h	/^    void add_root_page(snum_t store, bf_idx idx)$/;"	f	struct:bf_tree_vol_t
add_to_global_stats	smstats.cpp	/^smlevel_0::add_to_global_stats(const sm_stats_info_t &from)$/;"	f	class:smlevel_0
add_to_list	mem_mgmt.cpp	/^void fixed_lists_mem_t::add_to_list(size_t block_size, char* address)$/;"	f	class:fixed_lists_mem_t
address	mem_mgmt.h	/^        char* address;$/;"	m	struct:mem_mgmt_t::slot_t
after_run	smthread.cpp	/^void smthread_t::after_run() { \/\/ called before destructor$/;"	f	class:smthread_t
all_fingerprints	smthread.cpp	/^static atomic_thread_map_t all_fingerprints;$/;"	v	file:
alloc_a_page	vol.cpp	/^rc_t vol_t::alloc_a_page(shpid_t& shpid, bool redo)$/;"	f	class:vol_t
alloc_a_page_log	logrec.cpp	/^alloc_a_page_log::alloc_a_page_log(vid_t vid, shpid_t pid)$/;"	f	class:alloc_a_page_log
alloc_cache_t	alloc_cache.h	/^    alloc_cache_t (bf_fixed_m* fixed_pages) :$/;"	f	class:alloc_cache_t
alloc_cache_t	alloc_cache.h	/^class alloc_cache_t {$/;"	c
alloc_ext_cnt	sm_du_stats.h	/^    base_stat_t        alloc_ext_cnt;        \/* allocated extents $/;"	m	struct:volume_hdr_stats_t
alloc_page	alloc_page.h	/^class alloc_page : public generic_page_header {$/;"	c
alloc_page_h	alloc_page.cpp	/^alloc_page_h::alloc_page_h(generic_page* s, const lpid_t& pid):$/;"	f	class:alloc_page_h
alloc_page_h	alloc_page.h	/^    alloc_page_h(generic_page* s) : generic_page_h(s) {$/;"	f	class:alloc_page_h
alloc_page_h	alloc_page.h	/^class alloc_page_h : public generic_page_h {$/;"	c
alloc_pg_cnt	sm_du_stats.cpp	/^btree_stats_t::alloc_pg_cnt() const$/;"	f	class:btree_stats_t
alloc_pg_cnt	sm_du_stats.cpp	/^volume_map_stats_t::alloc_pg_cnt() const$/;"	f	class:volume_map_stats_t
alloc_pid_to_pid_offset	alloc_page.h	/^    inline static shpid_t alloc_pid_to_pid_offset(shpid_t alloc_pid) {$/;"	f	class:alloc_page_h
alloc_size	plog.h	/^    uint32_t alloc_size() { return _alloc_size; }$/;"	f	class:plog_t
allocate	allocator.cpp	/^T* sm_tls_allocator::allocate(size_t n)$/;"	f	class:sm_tls_allocator
allocate	allocator.cpp	/^logrec_t* sm_tls_allocator::allocate(size_t)$/;"	f	class:sm_tls_allocator
allocate	allocator.cpp	/^plog_xct_t* sm_tls_allocator::allocate(size_t)$/;"	f	class:sm_tls_allocator
allocate	allocator.cpp	/^xct_t* sm_tls_allocator::allocate<xct_t>(size_t)$/;"	f	class:sm_tls_allocator
allocate	allocator.cpp	/^xct_t::xct_core* sm_tls_allocator::allocate<xct_t::xct_core>(size_t)$/;"	f	class:sm_tls_allocator
allocate	allocator.h	/^    void* allocate(size_t n)$/;"	f	class:sm_naive_allocator
allocate	logarchiver.cpp	/^slot_t LogArchiver::ArchiverHeap::allocate(size_t length)$/;"	f	class:LogArchiver::ArchiverHeap
allocate	mem_mgmt.cpp	/^rc_t fixed_lists_mem_t::allocate(size_t length, slot_t& slot)$/;"	f	class:fixed_lists_mem_t
allocate_lock	lock_raw.cpp	/^RawLock* RawXct::allocate_lock(uint32_t hash, const okvl_mode& mode, RawLock::LockState state) {$/;"	f	class:RawXct
allocate_one_page	alloc_cache.cpp	/^rc_t alloc_cache_t::allocate_one_page (shpid_t &pid)$/;"	f	class:alloc_cache_t
allocate_xct	lock.cpp	/^RawXct* lock_m::allocate_xct() {$/;"	f	class:lock_m
allocate_xct	lock_core.cpp	/^RawXct* lock_core_m::allocate_xct() {$/;"	f	class:lock_core_m
allocator	sm.cpp	/^    sm_naive_allocator smlevel_0::allocator;$/;"	m	class:smlevel_0	file:
allocator	sm.cpp	/^    sm_tls_allocator smlevel_0::allocator;$/;"	m	class:smlevel_0	file:
allocator	sm_base.h	/^    static sm_naive_allocator allocator;$/;"	m	class:smlevel_0
allocator	sm_base.h	/^    static sm_tls_allocator allocator;$/;"	m	class:smlevel_0
alternative_lock_log_restart	sm_external.h	/^const int32_t alternative_lock_log_restart =    \/\/ sm_restart, measurement purpose$/;"	v
alternative_lock_page_restart	sm_external.h	/^const int32_t alternative_lock_page_restart =   \/\/ sm_restart, measurement purpose$/;"	v
alternative_log_log_restart	sm_external.h	/^const int32_t alternative_log_log_restart =     \/\/ sm_restart, measurement purpose$/;"	v
analysis_pass_backward	restart.cpp	/^restart_m::analysis_pass_backward($/;"	f	class:restart_m
analysis_pass_forward	restart.cpp	/^restart_m::analysis_pass_forward($/;"	f	class:restart_m
anchor	xct.cpp	/^xct_t::anchor(bool grabit)$/;"	f	class:xct_t
append	logarchiver.cpp	/^rc_t LogArchiver::ArchiveDirectory::append(char* data, size_t length)$/;"	f	class:LogArchiver::ArchiveDirectory
appendFd	logarchiver.h	/^        int appendFd;$/;"	m	class:LogArchiver::ArchiveDirectory
appendNewEntry	logarchiver.cpp	/^void LogArchiver::ArchiveIndex::appendNewEntry()$/;"	f	class:LogArchiver::ArchiveIndex
appendPos	logarchiver.h	/^        fileoff_t appendPos;$/;"	m	class:LogArchiver::ArchiveDirectory
append_if_not_exists	bf_hashtable.cpp	/^bool bf_hashbucket<T>::append_if_not_exists (uint64_t key, T value) {$/;"	f	class:bf_hashbucket
append_if_not_exists	logbuf_hashtable.cpp	/^bool logbuf_hashbucket::append_if_not_exists (uint64_t key, logbuf_seg* value) {$/;"	f	class:logbuf_hashbucket
apply	logrec.cpp	/^void page_img_format_t::apply(fixable_page_h* page)$/;"	f	class:page_img_format_t
apply_allocate_one_page	alloc_cache.cpp	/^rc_t alloc_cache_t::apply_allocate_one_page (shpid_t pid)$/;"	f	class:alloc_cache_t
apply_deallocate_one_page	alloc_cache.cpp	/^rc_t alloc_cache_t::apply_deallocate_one_page (shpid_t pid)$/;"	f	class:alloc_cache_t
archIndex	logarchiver.h	/^        ArchiveIndex* archIndex;$/;"	m	class:LogArchiver::ArchiveDirectory
archIndex	logarchiver.h	/^        ArchiveIndex* archIndex;$/;"	m	class:LogArchiver::ArchiveScanner
archIndex	logarchiver.h	/^        ArchiveIndex* archIndex;$/;"	m	class:LogArchiver::BlockAssembly
archdir	logarchiver.h	/^        std::string archdir;$/;"	m	class:LogArchiver::ArchiveDirectory
archive	restore.h	/^    LogArchiver::ArchiveDirectory* archive;$/;"	m	class:RestoreMgr
assert_empty	lock.cpp	/^lock_m::assert_empty() const$/;"	f	class:lock_m
assert_empty	lock_dump.cpp	/^lock_core_m::assert_empty() const$/;"	f	class:lock_core_m
assert_xlist_mutex_is_mine	xct.cpp	/^void xct_t::assert_xlist_mutex_is_mine()$/;"	f	class:xct_t
assert_xlist_mutex_not_mine	xct.cpp	/^void xct_t::assert_xlist_mutex_not_mine()$/;"	f	class:xct_t
associate_page	bf_tree.cpp	/^void bf_tree_m::associate_page(generic_page*&_pp, bf_idx idx, lpid_t page_updated)$/;"	f	class:bf_tree_m
asyncRC	logarchiver.h	/^        rc_t asyncRC;$/;"	m	class:LogArchiver::MergerDaemon
asyncWriter	restore.h	/^    SegmentWriter* asyncWriter;$/;"	m	class:RestoreMgr
atomic_lock_insert	lock_raw.cpp	/^void RawLockQueue::atomic_lock_insert(RawLock* new_lock) {$/;"	f	class:RawLockQueue
atomic_synchronize	lock_raw.h	/^inline void atomic_synchronize() {$/;"	f
atomic_synchronize_if_mutex	lock_raw.h	/^inline void atomic_synchronize_if_mutex() { atomic_synchronize(); }$/;"	f
atomic_synchronize_if_mutex	lock_raw.h	/^inline void atomic_synchronize_if_mutex() {}$/;"	f
atomic_thread_map_t	smthread.h	/^typedef sm_thread_map_t atomic_thread_map_t;$/;"	t
attach_thread	xct.cpp	/^xct_t::attach_thread()$/;"	f	class:xct_t
attach_update_thread	xct.cpp	/^xct_t::attach_update_thread()$/;"	f	class:xct_t
attach_xct	sm.h	/^    static void           attach_xct(xct_t *x) { me()->attach_xct(x); }$/;"	f	class:ss_m
attach_xct	smthread.cpp	/^smthread_t::attach_xct(xct_t* x)$/;"	f	class:smthread_t
audit	sm_du_stats.cpp	/^btree_int_stats_t::audit() const$/;"	f	class:btree_int_stats_t
audit	sm_du_stats.cpp	/^btree_lf_stats_t::audit() const$/;"	f	class:btree_lf_stats_t
audit	sm_du_stats.cpp	/^btree_stats_t::audit() const$/;"	f	class:btree_stats_t
audit	sm_du_stats.cpp	/^sm_du_stats_t::audit() const$/;"	f	class:sm_du_stats_t
audit	sm_du_stats.cpp	/^volume_hdr_stats_t::audit() const$/;"	f	class:volume_hdr_stats_t
audit	sm_du_stats.cpp	/^volume_map_stats_t::audit() const$/;"	f	class:volume_map_stats_t
auto_release_anchor_t	xct.h	/^    auto_release_anchor_t (bool and_compensate) :$/;"	f	class:auto_release_anchor_t
auto_release_anchor_t	xct.h	/^class auto_release_anchor_t {$/;"	c
auto_rollback_t	xct.h	/^    auto_rollback_t(int line, const char *file)$/;"	f	class:auto_rollback_t
auto_rollback_t	xct.h	/^class auto_rollback_t {$/;"	c
await_not_in_transit_out	bf_transit_bucket.h	/^    void await_not_in_transit_out(const bfpid_t &pid) {$/;"	f	class:transit_bucket_t
awaken	chkpt.cpp	/^chkpt_thread_t::awaken()$/;"	f	class:chkpt_thread_t
backup	restore.h	/^    BackupReader* backup;$/;"	m	class:RestoreMgr
backupLSN	vol.h	/^    lsn_t      backupLSN;$/;"	m	class:volhdr_t
backup_table	chkpt.h	/^  chkpt_backup_tab_t backup_table;$/;"	m	struct:chkpt_t
bad_cmp_t	sm_base.h	/^    enum cmp_t { bad_cmp_t=badOp, eq=eqOp,$/;"	e	enum:smlevel_0::cmp_t
base	log_core.h	/^        long base; \/\/ absolute position of _buf[0] (absolute meaning$/;"	m	struct:log_common::epoch
baseLogHeader	logrec.h	/^struct baseLogHeader$/;"	s
base_lsn	log_core.h	/^        lsn_t base_lsn; \/\/ lsn of _buf[0] for this epoch$/;"	m	struct:log_common::epoch
base_lsn	logbuf_seg.h	/^    lsn_t base_lsn;  \/\/ starting lsn of this segment, as key in the hashtable$/;"	m	class:logbuf_seg
base_stat_t	sm_base.h	/^    typedef w_base_t::base_stat_t base_stat_t;$/;"	t	class:smlevel_0
base_stat_t	sm_du_stats.h	/^typedef w_base_t::base_stat_t base_stat_t;$/;"	t
before_recovery	sm_base.h	/^    static bool before_recovery() {$/;"	f	class:smlevel_0
before_run	smthread.cpp	/^void smthread_t::before_run() {$/;"	f	class:smthread_t
begin	ringbuffer.h	/^    int begin;$/;"	m	class:AsyncRingBuffer
beginLSN	logarchiver.h	/^            lsn_t beginLSN;$/;"	m	struct:LogArchiver::ArchiveDirectory::RunFileStats
begin_sys_xct	sm.cpp	/^rc_t ss_m::begin_sys_xct(bool single_log_sys_xct,$/;"	f	class:ss_m
begin_xct	sm.cpp	/^ss_m::begin_xct($/;"	f	class:ss_m
begin_xct	sm.cpp	/^ss_m::begin_xct(tid_t& tid, timeout_in_ms timeout)$/;"	f	class:ss_m
begin_xct	sm.cpp	/^ss_m::begin_xct(timeout_in_ms timeout)$/;"	f	class:ss_m
beginning_bytes	logrec.h	/^    size_t      beginning_bytes;$/;"	m	struct:page_img_format_t
bf	sm.cpp	/^bf_tree_m* smlevel_0::bf = 0;$/;"	m	class:smlevel_0	file:
bf	sm_base.h	/^    static bf_tree_m* bf;$/;"	m	class:smlevel_0
bf_eviction_thread_t	bf_tree.h	/^class bf_eviction_thread_t : public smthread_t$/;"	c
bf_fixed_m	bf_fixed.cpp	/^bf_fixed_m::bf_fixed_m(vol_t* parent, int unix_fd, shpid_t max_pid)$/;"	f	class:bf_fixed_m
bf_fixed_m	bf_fixed.h	/^class bf_fixed_m {$/;"	c
bf_hash	bf_hashtable.cpp	/^inline uint32_t bf_hash(uint64_t x) {$/;"	f
bf_hashbucket	bf_hashtable.cpp	/^class bf_hashbucket {$/;"	c	file:
bf_hashbucket_chunk	bf_hashtable.cpp	/^struct bf_hashbucket_chunk {$/;"	s	file:
bf_hashbucket_chunk_linked	bf_hashtable.cpp	/^    bf_hashbucket_chunk_linked (uint32_t size_)$/;"	f	struct:bf_hashbucket_chunk_linked
bf_hashbucket_chunk_linked	bf_hashtable.cpp	/^struct bf_hashbucket_chunk_linked {$/;"	s	file:
bf_hashtable	bf_hashtable.cpp	/^bf_hashtable<T>::bf_hashtable(uint32_t size) : _size(size) {$/;"	f	class:bf_hashtable
bf_hashtable	bf_hashtable.h	/^class bf_hashtable {$/;"	c
bf_htab_stats_t	smstats.h	/^class bf_htab_stats_t {$/;"	c
bf_idx	bf_idx.h	/^typedef uint32_t bf_idx;$/;"	t
bf_idx_pair	bf_hashtable.h	/^typedef pair<bf_idx, bf_idx> bf_idx_pair;$/;"	t
bf_key	bf_tree.h	/^inline uint64_t bf_key(const lpid_t &pid) {$/;"	f
bf_key	bf_tree.h	/^inline uint64_t bf_key(vid_t vid, shpid_t shpid) {$/;"	f
bf_tree_cb_t	bf_tree_cb.h	/^struct bf_tree_cb_t {$/;"	s
bf_tree_cleaner	bf_tree_cleaner.cpp	/^bf_tree_cleaner::bf_tree_cleaner(bf_tree_m* bufferpool, uint32_t cleaner_threads,$/;"	f	class:bf_tree_cleaner
bf_tree_cleaner	bf_tree_cleaner.h	/^class bf_tree_cleaner {$/;"	c
bf_tree_cleaner_slave_thread_t	bf_tree_cleaner.cpp	/^bf_tree_cleaner_slave_thread_t::bf_tree_cleaner_slave_thread_t(bf_tree_cleaner* parent, unsigned id)$/;"	f	class:bf_tree_cleaner_slave_thread_t
bf_tree_cleaner_slave_thread_t	bf_tree_cleaner.h	/^class bf_tree_cleaner_slave_thread_t : public smthread_t {$/;"	c
bf_tree_m	bf_tree.cpp	/^bf_tree_m::bf_tree_m(const sm_options& options)$/;"	f	class:bf_tree_m
bf_tree_m	bf_tree.h	/^class bf_tree_m {$/;"	c
bf_tree_vol_t	bf_tree_vol.h	/^    bf_tree_vol_t (vol_t* volume) : _volume (volume) {$/;"	f	struct:bf_tree_vol_t
bf_tree_vol_t	bf_tree_vol.h	/^struct bf_tree_vol_t {$/;"	s
bfht	smstats.h	/^    bf_htab_stats_t  bfht;$/;"	m	class:sm_stats_info_t
bit	alloc_page.h	/^    bool       bit(uint32_t index) { return (bitmap[byte_place(index)]&bit_mask(index)) != 0; }$/;"	f	class:alloc_page
bit_mask	alloc_page.h	/^    uint32_t bit_mask  (uint32_t index) { return 1 << bit_place(index); }$/;"	f	class:alloc_page
bit_place	alloc_page.h	/^    uint32_t bit_place (uint32_t index) { return index & 0x7; }$/;"	f	class:alloc_page
bitmap	alloc_page.h	/^    uint8_t bitmap[bitmapsize];$/;"	m	class:alloc_page
bitmap	logrec.h	/^    char bitmap[maxBitmapSize];$/;"	m	struct:chkpt_restore_tab_t
bitmap	restore.h	/^    RestoreBitmap* bitmap;$/;"	m	class:RestoreMgr
bitmapSize	logrec.h	/^    uint32_t bitmapSize;$/;"	m	struct:chkpt_restore_tab_t
bitmapsize	alloc_page.h	/^    static const int bitmapsize = 8192 - sizeof(generic_page_header) - sizeof(shpid_t)*2;$/;"	m	class:alloc_page
bits	pmap.h	/^    u_char  bits[_size];$/;"	m	struct:Pmap
bits	restore.h	/^    std::vector<bool> bits;$/;"	m	class:RestoreBitmap
bits_held	alloc_page.h	/^    static const int bits_held = alloc_page::bits_held;$/;"	m	class:alloc_page_h
bits_held	alloc_page.h	/^    static const int bits_held = bitmapsize * 8;$/;"	m	class:alloc_page
bk	sm.cpp	/^BackupManager* smlevel_0::bk = 0;$/;"	m	class:smlevel_0	file:
bk	sm_base.h	/^    static BackupManager* bk;$/;"	m	class:smlevel_0
blkAssemb	logarchiver.h	/^    BlockAssembly* blkAssemb;$/;"	m	class:LogArchiver
block	partition.cpp	/^    char *block() { return _block; }$/;"	f	class:block_of_zeroes
blockCount	logarchiver.h	/^            size_t blockCount;$/;"	m	struct:LogArchiver::ArchiveScanner::RunScanner
blockCount	ringbuffer.h	/^    const size_t blockCount;$/;"	m	class:AsyncRingBuffer
blockNumber	logarchiver.h	/^            uint8_t blockNumber;$/;"	m	struct:LogArchiver::ArchiveIndex::BlockHeader
blockSize	logarchiver.h	/^        size_t blockSize;$/;"	m	class:LogArchiver::ArchiveDirectory
blockSize	logarchiver.h	/^        size_t blockSize;$/;"	m	class:LogArchiver::ArchiveIndex
blockSize	logarchiver.h	/^        size_t blockSize;$/;"	m	class:LogArchiver::BaseThread
blockSize	logarchiver.h	/^        size_t blockSize;$/;"	m	class:LogArchiver::BlockAssembly
blockSize	logarchiver.h	/^        size_t blockSize;$/;"	m	class:LogArchiver::LogConsumer
blockSize	logarchiver.h	/^    size_t blockSize;$/;"	m	class:LogScanner
blockSize	ringbuffer.h	/^    const size_t blockSize;$/;"	m	class:AsyncRingBuffer
block_of_zeroes	partition.cpp	/^    NORET block_of_zeroes() {$/;"	f	class:block_of_zeroes
block_of_zeroes	partition.cpp	/^class block_of_zeroes {$/;"	c	file:
block_of_zeros	partition.cpp	/^char *block_of_zeros() {$/;"	f
block_size	mem_mgmt.h	/^        uint16_t block_size() {$/;"	f	class:fixed_lists_mem_t::list_header_t
blocker	lock_raw.h	/^        RawXct*     blocker;$/;"	m	struct:RawLockQueue::Compatibility
blocker	lock_raw.h	/^    RawXct*                     blocker;$/;"	m	struct:RawXct
body	btree_page.h	/^        item_body body[max_bodies];$/;"	m	union:btree_page_data::__anon11
body_offset_t	btree_page.h	/^    typedef int16_t  body_offset_t;$/;"	t	class:btree_page_data
bof	sm_s.cpp	/^const lpid_t lpid_t::bof;$/;"	m	class:lpid_t	file:
bof	sm_s.h	/^    static const lpid_t bof;$/;"	m	class:lpid_t
borrowed_btree_page_h	btree_page_h.h	/^    borrowed_btree_page_h(fixable_page_h* source) :$/;"	f	class:borrowed_btree_page_h
borrowed_btree_page_h	btree_page_h.h	/^class borrowed_btree_page_h : public btree_page_h {$/;"	c
bparity	ringbuffer.h	/^    bool bparity;$/;"	m	class:AsyncRingBuffer
bpos	logarchiver.h	/^            size_t bpos;$/;"	m	struct:LogArchiver::ArchiveScanner::RunScanner
brec	logrec.h	/^    brec_t             brec[max];$/;"	m	struct:chkpt_bf_tab_t
brec_t	logrec.h	/^    struct brec_t {$/;"	s	struct:chkpt_bf_tab_t
bt	sm.cpp	/^btree_m* smlevel_0::bt = 0;$/;"	m	class:smlevel_0	file:
bt	sm_base.h	/^    static btree_m* bt;$/;"	m	class:smlevel_0
bt_cursor_t	btcursor.cpp	/^bt_cursor_t::bt_cursor_t($/;"	f	class:bt_cursor_t
bt_cursor_t	btcursor.cpp	/^bt_cursor_t::bt_cursor_t(stid_t store, bool forward)$/;"	f	class:bt_cursor_t
bt_cursor_t	btcursor.h	/^class bt_cursor_t : private smlevel_0 {$/;"	c
btrec_t	btree_page_h.h	/^    NORET            btrec_t()        {};$/;"	f	class:btrec_t
btrec_t	btree_page_h.h	/^btrec_t::btrec_t(const btree_page_h& page, slotid_t slot) {$/;"	f	class:btrec_t
btrec_t	btree_page_h.h	/^class btrec_t {$/;"	c
btree	sm_du_stats.h	/^    btree_stats_t     btree;$/;"	m	struct:sm_du_stats_t
btree_bulk_delete_t	btree_logrec.h	/^    btree_bulk_delete_t(shpid_t foster_parent, shpid_t new_foster_child,$/;"	f	struct:btree_bulk_delete_t
btree_bulk_delete_t	btree_logrec.h	/^struct btree_bulk_delete_t : public multi_page_log_t {$/;"	s
btree_chain_fence_high_length	btree_page.h	/^    int16_t btree_chain_fence_high_length;      \/\/ +2 -> 20$/;"	m	class:btree_page_data
btree_cnt	sm_du_stats.h	/^    base_stat_t        btree_cnt;$/;"	m	struct:sm_du_stats_t
btree_compress_page_log	btree_logrec.cpp	/^btree_compress_page_log::btree_compress_page_log($/;"	f	class:btree_compress_page_log
btree_consecutive_skewed_insertions	btree_page.h	/^    int16_t btree_consecutive_skewed_insertions; \/\/ +2 -> 24$/;"	m	class:btree_page_data
btree_fence_high_length	btree_page.h	/^    int16_t btree_fence_high_length;            \/\/ +2 -> 18$/;"	m	class:btree_page_data
btree_fence_low_length	btree_page.h	/^    int16_t btree_fence_low_length;             \/\/ +2 -> 16$/;"	m	class:btree_page_data
btree_foster	btree_page.h	/^    shpid_t btree_foster;                       \/\/ +4 -> 12$/;"	m	class:btree_page_data
btree_foster_adopt_log	btree_logrec.cpp	/^btree_foster_adopt_log::btree_foster_adopt_log (const btree_page_h& p, const btree_page_h& p2,$/;"	f	class:btree_foster_adopt_log
btree_foster_adopt_t	btree_logrec.cpp	/^btree_foster_adopt_t::btree_foster_adopt_t(shpid_t page2_id, shpid_t new_child_pid,$/;"	f	class:btree_foster_adopt_t
btree_foster_adopt_t	btree_logrec.h	/^struct btree_foster_adopt_t : multi_page_log_t {$/;"	s
btree_foster_deadopt_log	btree_logrec.cpp	/^btree_foster_deadopt_log::btree_foster_deadopt_log ($/;"	f	class:btree_foster_deadopt_log
btree_foster_deadopt_t	btree_logrec.cpp	/^btree_foster_deadopt_t::btree_foster_deadopt_t(shpid_t page2_id, shpid_t deadopted_pid,$/;"	f	class:btree_foster_deadopt_t
btree_foster_deadopt_t	btree_logrec.h	/^struct btree_foster_deadopt_t : multi_page_log_t {$/;"	s
btree_foster_emlsn	btree_page.h	/^    lsn_t   btree_foster_emlsn; \/\/ +8 -> 48$/;"	m	class:btree_page_data
btree_foster_merge_log	btree_logrec.cpp	/^btree_foster_merge_log::btree_foster_merge_log (const btree_page_h& p, \/\/ destination$/;"	f	class:btree_foster_merge_log
btree_foster_merge_t	btree_logrec.cpp	/^btree_foster_merge_t::btree_foster_merge_t(shpid_t page2_id,$/;"	f	class:btree_foster_merge_t
btree_foster_merge_t	btree_logrec.h	/^struct btree_foster_merge_t : multi_page_log_t {$/;"	s
btree_foster_rebalance_log	btree_logrec.cpp	/^btree_foster_rebalance_log::btree_foster_rebalance_log ($/;"	f	class:btree_foster_rebalance_log
btree_foster_rebalance_norec_log	btree_logrec.cpp	/^btree_foster_rebalance_norec_log::btree_foster_rebalance_norec_log($/;"	f	class:btree_foster_rebalance_norec_log
btree_foster_rebalance_norec_t	btree_logrec.h	/^    btree_foster_rebalance_norec_t(const btree_page_h& p,$/;"	f	struct:btree_foster_rebalance_norec_t
btree_foster_rebalance_norec_t	btree_logrec.h	/^struct btree_foster_rebalance_norec_t : multi_page_log_t {$/;"	s
btree_foster_rebalance_t	btree_logrec.cpp	/^btree_foster_rebalance_t::btree_foster_rebalance_t($/;"	f	class:btree_foster_rebalance_t
btree_foster_rebalance_t	btree_logrec.h	/^struct btree_foster_rebalance_t : multi_page_log_t {$/;"	s
btree_ghost_mark_log	btree_logrec.cpp	/^btree_ghost_mark_log::btree_ghost_mark_log(const btree_page_h& p,$/;"	f	class:btree_ghost_mark_log
btree_ghost_reclaim_log	btree_logrec.cpp	/^btree_ghost_reclaim_log::btree_ghost_reclaim_log(const btree_page_h& p,$/;"	f	class:btree_ghost_reclaim_log
btree_ghost_reserve_log	btree_logrec.cpp	/^btree_ghost_reserve_log::btree_ghost_reserve_log ($/;"	f	class:btree_ghost_reserve_log
btree_ghost_reserve_t	btree_logrec.cpp	/^btree_ghost_reserve_t::btree_ghost_reserve_t(const w_keystr_t& key, int elem_length)$/;"	f	class:btree_ghost_reserve_t
btree_ghost_reserve_t	btree_logrec.h	/^struct btree_ghost_reserve_t {$/;"	s
btree_ghost_t	btree_logrec.cpp	/^btree_ghost_t::btree_ghost_t(const btree_page_h& p, const vector<slotid_t>& slots, const bool is_sys_txn)$/;"	f	class:btree_ghost_t
btree_ghost_t	btree_logrec.h	/^struct btree_ghost_t {$/;"	s
btree_impl	btree_impl.h	/^class btree_impl : public smlevel_0  {$/;"	c
btree_insert_log	btree_logrec.cpp	/^btree_insert_log::btree_insert_log($/;"	f	class:btree_insert_log
btree_insert_nonghost_log	btree_logrec.cpp	/^btree_insert_nonghost_log::btree_insert_nonghost_log($/;"	f	class:btree_insert_nonghost_log
btree_insert_t	btree_logrec.cpp	/^btree_insert_t::btree_insert_t($/;"	f	class:btree_insert_t
btree_insert_t	btree_logrec.h	/^struct btree_insert_t {$/;"	s
btree_int_stats_t	sm_du_stats.h	/^    NORET              btree_int_stats_t() {clear();}$/;"	f	struct:btree_int_stats_t
btree_int_stats_t	sm_du_stats.h	/^struct btree_int_stats_t {$/;"	s
btree_level	btree_page.h	/^    int16_t btree_level;                        \/\/ +2 -> 14$/;"	m	class:btree_page_data
btree_lf_stats_t	sm_du_stats.h	/^    NORET              btree_lf_stats_t() {clear();}$/;"	f	struct:btree_lf_stats_t
btree_lf_stats_t	sm_du_stats.h	/^struct btree_lf_stats_t {$/;"	s
btree_m	btree.h	/^    NORET                        btree_m()   {};$/;"	f	class:btree_m
btree_m	btree.h	/^class btree_m : public smlevel_0 {$/;"	c
btree_norec_alloc_log	btree_logrec.cpp	/^btree_norec_alloc_log::btree_norec_alloc_log(const btree_page_h &p, const btree_page_h &,$/;"	f	class:btree_norec_alloc_log
btree_norec_alloc_t	btree_logrec.cpp	/^btree_norec_alloc_t::btree_norec_alloc_t(const btree_page_h &p,$/;"	f	class:btree_norec_alloc_t
btree_norec_alloc_t	btree_logrec.h	/^struct btree_norec_alloc_t : public multi_page_log_t {$/;"	s
btree_overwrite_log	btree_logrec.cpp	/^btree_overwrite_log::btree_overwrite_log (const btree_page_h& page, const w_keystr_t& key,$/;"	f	class:btree_overwrite_log
btree_overwrite_t	btree_logrec.h	/^    btree_overwrite_t(const btree_page_h& page, const w_keystr_t& key,$/;"	f	struct:btree_overwrite_t
btree_overwrite_t	btree_logrec.h	/^struct btree_overwrite_t {$/;"	s
btree_page	btree_page.h	/^class btree_page : public btree_page_data {$/;"	c
btree_page_data	btree_page.h	/^class btree_page_data : public generic_page_header {$/;"	c
btree_page_h	btree_page_h.h	/^    btree_page_h() {}$/;"	f	class:btree_page_h
btree_page_h	btree_page_h.h	/^    btree_page_h(const btree_page_h& p) : fixable_page_h(p) {}$/;"	f	class:btree_page_h
btree_page_h	btree_page_h.h	/^class btree_page_h : public fixable_page_h {$/;"	c
btree_pid0	btree_page.h	/^    shpid_t btree_pid0;                         \/\/ +4 -> 8$/;"	m	class:btree_page_data
btree_pid0_emlsn	btree_page.h	/^    lsn_t   btree_pid0_emlsn;   \/\/ +8 -> 40$/;"	m	class:btree_page_data
btree_prefix_length	btree_page.h	/^    int16_t btree_prefix_length;                \/\/ +2 -> 22$/;"	m	class:btree_page_data
btree_root	btree_page.h	/^    shpid_t btree_root;                         \/\/ +4 -> 4$/;"	m	class:btree_page_data
btree_root	btree_page_h.h	/^    shpid_t                     btree_root() const { return page()->btree_root;}$/;"	f	class:btree_page_h
btree_split_log	btree_logrec.cpp	/^btree_split_log::btree_split_log($/;"	f	class:btree_split_log
btree_stats_t	sm_du_stats.h	/^    NORET           btree_stats_t() {clear();}$/;"	f	struct:btree_stats_t
btree_stats_t	sm_du_stats.h	/^struct btree_stats_t {$/;"	s
btree_update_log	btree_logrec.cpp	/^btree_update_log::btree_update_log($/;"	f	class:btree_update_log
btree_update_t	btree_logrec.h	/^    btree_update_t(const btree_page_h& page, const w_keystr_t& key,$/;"	f	struct:btree_update_t
btree_update_t	btree_logrec.h	/^struct btree_update_t {$/;"	s
bucketSize	logarchiver.h	/^            size_t bucketSize;$/;"	m	struct:LogArchiver::ArchiveScanner::RunScanner
bucketSize	logarchiver.h	/^        size_t bucketSize;$/;"	m	class:LogArchiver::ArchiveIndex
bucketSize	logarchiver.h	/^        size_t bucketSize;$/;"	m	class:LogArchiver::BlockAssembly
bucket_t	lock_bucket.h	/^    bucket_t() : _queue(NULL) {}$/;"	f	class:bucket_t
bucket_t	lock_bucket.h	/^class bucket_t {$/;"	c
buckets	logarchiver.h	/^        vector<pair<lpid_t, size_t> > buckets;$/;"	m	class:LogArchiver::BlockAssembly
buf	logarchiver.h	/^        AsyncRingBuffer* buf;$/;"	m	class:LogArchiver::BaseThread
buf	logbuf_seg.h	/^    char *buf;  \/\/ memory space for the segment$/;"	m	class:logbuf_seg
buf	ringbuffer.h	/^    char * buf;$/;"	m	class:AsyncRingBuffer
buffer	backup_reader.h	/^    char* buffer;$/;"	m	class:BackupReader
buffer	logarchiver.h	/^            char* buffer;$/;"	m	struct:LogArchiver::ArchiveScanner::RunScanner
buffer_pool_size	smstats.h	/^    u_long buffer_pool_size;    \/\/ buffer pool size in kilo-bytes$/;"	m	struct:sm_config_info_t
bufferedRequests	restore.h	/^    std::map<shpid_t, generic_page*> bufferedRequests;$/;"	m	class:RestoreMgr
build_caches	vol.cpp	/^void vol_t::build_caches()$/;"	f	class:vol_t
byte_place	alloc_page.h	/^    uint32_t byte_place(uint32_t index) { return index >> 3; }$/;"	f	class:alloc_page
bytes_written_bwd	logrec.cpp	/^    static __thread uint64_t bytes_written_bwd [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
bytes_written_bwd	logrec.cpp	/^__thread uint64_t logrec_accounting_impl_t::bytes_written_bwd [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
bytes_written_bwd_cxt	logrec.cpp	/^    static __thread uint64_t bytes_written_bwd_cxt [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
bytes_written_bwd_cxt	logrec.cpp	/^__thread uint64_t logrec_accounting_impl_t::bytes_written_bwd_cxt [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
bytes_written_fwd	logrec.cpp	/^    static __thread uint64_t bytes_written_fwd [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
bytes_written_fwd	logrec.cpp	/^__thread uint64_t logrec_accounting_impl_t::bytes_written_fwd [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
c	btree_page_h.h	/^        char	c[sizeof(shpid_t)];\/\/ int32 = 4 bytes$/;"	m	union:btree_page_h::record_info_shpid_convert
c	btree_page_h.h	/^        char    c[sizeof(int16_t)];\/\/ int16 = 2 bytes, enough for max. record size in current implementation$/;"	m	union:btree_page_h::record_info_int16_convert
calculate_checksum	generic_page.cpp	/^uint32_t generic_page_header::calculate_checksum () const {$/;"	f	class:generic_page_header
calculate_prefix_length	btree_page_h.cpp	/^int16_t btree_page_h::calculate_prefix_length(int16_t existing_prefix_len,  \/\/ Existing prefix length$/;"	f	class:btree_page_h
can_be_granted	lock_bucket.h	/^        bool can_be_granted;$/;"	m	struct:lock_queue_t::check_grant_result
can_be_granted	lock_raw.h	/^        bool        can_be_granted;$/;"	m	struct:RawLockQueue::Compatibility
can_be_in_xct	prologue.h	/^        can_be_in_xct,  \/\/ in or not -- no test for active or prepared$/;"	e	enum:prologue_rc_t::xct_state_t
carray_slotid_t	log_carray.h	/^typedef uint32_t carray_slotid_t;$/;"	t
carray_status_t	log_carray.h	/^typedef int64_t carray_status_t;$/;"	t
cat	logrec.h	/^logrec_t::cat() const$/;"	f	class:logrec_t
cat_str	logrec.cpp	/^logrec_t::cat_str() const$/;"	f	class:logrec_t
category_t	logrec.h	/^    enum category_t {$/;"	g	class:logrec_t
ceil2	log_storage.h	/^    static long         ceil2(long offset, long block_size)$/;"	f	class:log_storage
chain	xct.cpp	/^xct_t::chain(bool lazy)$/;"	f	class:xct_t
chain_xct	sm.cpp	/^ss_m::chain_xct( sm_stats_info_t*&  _stats, bool lazy)$/;"	f	class:ss_m
chain_xct	sm.cpp	/^ss_m::chain_xct(bool lazy)$/;"	f	class:ss_m
change_possible_after_fix	fixable_page_h.cpp	/^bool fixable_page_h::change_possible_after_fix() const {$/;"	f	class:fixable_page_h
change_state	xct.cpp	/^xct_t::change_state(state_t new_state)$/;"	f	class:xct_t
check	xct.cpp	/^xct_log_warn_check_t::check(xct_t *& _victim)$/;"	f	class:xct_log_warn_check_t
check_actual_pin_count	smthread.h	/^smthread_t::check_actual_pin_count(int actual) $/;"	f	class:smthread_t
check_chance_for_norecord_split	btree_page_h.cpp	/^bool btree_page_h::check_chance_for_norecord_split(const w_keystr_t& key_to_insert) const {$/;"	f	class:btree_page_h
check_compatiblity	lock_raw.cpp	/^RawLockQueue::Compatibility RawLockQueue::check_compatiblity(RawLock *lock) const {$/;"	f	class:RawLockQueue
check_compensated_op_nesting	sm_base.h	/^    check_compensated_op_nesting(xct_t* xd, int line, const char *const file)$/;"	f	struct:check_compensated_op_nesting
check_compensated_op_nesting	sm_base.h	/^struct check_compensated_op_nesting {$/;"	s
check_disk	vol.cpp	/^rc_t vol_t::check_disk()$/;"	f	class:vol_t
check_error_on_start	xct.h	/^    rc_t check_error_on_start () const {$/;"	f	class:sys_xct_section_t
check_fhdl_app	partition.cpp	/^partition_t::check_fhdl_app() const {$/;"	f	class:partition_t
check_fhdl_app	partition.h	/^    void               check_fhdl_app() const { }$/;"	f	class:partition_t
check_fhdl_rd	partition.cpp	/^partition_t::check_fhdl_rd() const {$/;"	f	class:partition_t
check_fhdl_rd	partition.h	/^    void               check_fhdl_rd() const { }$/;"	f	class:partition_t
check_grant_result	lock_bucket.h	/^    struct check_grant_result {$/;"	s	class:lock_queue_t
check_metadata_restored	vol.cpp	/^inline void vol_t::check_metadata_restored() const$/;"	f	class:vol_t
check_not_contain	alloc_cache.cpp	/^inline bool check_not_contain (const std::vector<shpid_t> &list, shpid_t pid)$/;"	f
check_one_thread_attached	xct.cpp	/^xct_t::check_one_thread_attached() const$/;"	f	class:xct_t
check_pin_count	smthread.h	/^smthread_t::check_pin_count(int W_IFDEBUG4(change)) $/;"	f	class:smthread_t
check_restore_finished	vol.cpp	/^bool vol_t::check_restore_finished()$/;"	f	class:vol_t
check_space_for_insert_leaf	btree_page_h.cpp	/^bool btree_page_h::check_space_for_insert_leaf(const w_keystr_t& trunc_key,$/;"	f	class:btree_page_h
check_space_for_insert_leaf	btree_page_h.cpp	/^bool btree_page_h::check_space_for_insert_leaf(size_t trunc_key_length, size_t element_length) {$/;"	f	class:btree_page_h
check_space_for_insert_node	btree_page_h.cpp	/^bool btree_page_h::check_space_for_insert_node(const w_keystr_t& key) {$/;"	f	class:btree_page_h
checkpoint	sm.cpp	/^ss_m::checkpoint()$/;"	f	class:ss_m
checkpoint_sync	sm.cpp	/^ss_m::checkpoint_sync()$/;"	f	class:ss_m
checksum	generic_page.h	/^    mutable uint32_t checksum;     \/\/ +4 -> 4$/;"	m	class:generic_page_header
child	btree_page.h	/^                shpid_t       child;$/;"	m	struct:btree_page_data::__anon6::__anon7::__anon9
child	btree_page_h.cpp	/^shpid_t btree_page_h::child(slotid_t slot) const$/;"	f	class:btree_page_h
child	btree_page_h.h	/^    shpid_t            child() const    { return _child; }$/;"	f	class:btrec_t
child_emlsn	btree_page_h.h	/^    const lsn_t&       child_emlsn() const { return _child_emlsn; }$/;"	f	class:btrec_t
child_opaqueptr	btree_page_h.h	/^inline shpid_t btree_page_h::child_opaqueptr(slotid_t slot) const {$/;"	f	class:btree_page_h
child_slot_address	fixable_page_h.cpp	/^shpid_t* fixable_page_h::child_slot_address(int child_slot) const {$/;"	f	class:fixable_page_h
chkpt	sm.cpp	/^chkpt_m* smlevel_0::chkpt = 0;$/;"	m	class:smlevel_0	file:
chkpt	sm_base.h	/^    static chkpt_m*    chkpt;$/;"	m	class:smlevel_0
chkpt_backup_tab_log	logrec.cpp	/^chkpt_backup_tab_log::chkpt_backup_tab_log($/;"	f	class:chkpt_backup_tab_log
chkpt_backup_tab_t	logrec.cpp	/^chkpt_backup_tab_t::chkpt_backup_tab_t($/;"	f	class:chkpt_backup_tab_t
chkpt_backup_tab_t	logrec.h	/^struct chkpt_backup_tab_t$/;"	s
chkpt_begin_log	logrec.cpp	/^chkpt_begin_log::chkpt_begin_log(const lsn_t &lastMountLSN)$/;"	f	class:chkpt_begin_log
chkpt_bf_tab_log	logrec.cpp	/^chkpt_bf_tab_log::chkpt_bf_tab_log($/;"	f	class:chkpt_bf_tab_log
chkpt_bf_tab_t	logrec.cpp	/^chkpt_bf_tab_t::chkpt_bf_tab_t($/;"	f	class:chkpt_bf_tab_t
chkpt_bf_tab_t	logrec.h	/^struct chkpt_bf_tab_t {$/;"	s
chkpt_count	chkpt.cpp	/^    unsigned int        chkpt_count;$/;"	m	class:chkpt_thread_t	file:
chkpt_dev_tab_log	logrec.cpp	/^chkpt_dev_tab_log::chkpt_dev_tab_log(vid_t next_vid,$/;"	f	class:chkpt_dev_tab_log
chkpt_dev_tab_t	logrec.cpp	/^chkpt_dev_tab_t::chkpt_dev_tab_t(vid_t next_vid,$/;"	f	class:chkpt_dev_tab_t
chkpt_dev_tab_t	logrec.h	/^struct chkpt_dev_tab_t$/;"	s
chkpt_displacement	sm.cpp	/^smlevel_0::fileoff_t        smlevel_0::chkpt_displacement = 0;$/;"	m	class:smlevel_0	file:
chkpt_displacement	sm_base.h	/^    static fileoff_t chkpt_displacement;$/;"	m	class:smlevel_0
chkpt_end_log	logrec.cpp	/^chkpt_end_log::chkpt_end_log(const lsn_t& lsn, const lsn_t& min_rec_lsn,$/;"	f	class:chkpt_end_log
chkpt_m	chkpt.cpp	/^chkpt_m::chkpt_m()$/;"	f	class:chkpt_m
chkpt_m	chkpt.h	/^class chkpt_m {$/;"	c
chkpt_mode_t	chkpt.h	/^    enum chkpt_mode_t {$/;"	g	class:chkpt_m
chkpt_read_critical_section	chkpt_serial.h	/^    chkpt_read_critical_section()$/;"	f	struct:chkpt_read_critical_section
chkpt_read_critical_section	chkpt_serial.h	/^struct chkpt_read_critical_section {$/;"	s
chkpt_restore_progress	vol.cpp	/^void vol_t::chkpt_restore_progress(chkpt_restore_tab_t* tab)$/;"	f	class:vol_t
chkpt_restore_tab_log	logrec.cpp	/^chkpt_restore_tab_log::chkpt_restore_tab_log(vid_t vid)$/;"	f	class:chkpt_restore_tab_log
chkpt_restore_tab_t	logrec.h	/^    chkpt_restore_tab_t(vid_t vid)$/;"	f	struct:chkpt_restore_tab_t
chkpt_restore_tab_t	logrec.h	/^struct chkpt_restore_tab_t$/;"	s
chkpt_serial_m	chkpt_serial.h	/^class chkpt_serial_m : public smlevel_0 {$/;"	c
chkpt_t	chkpt.h	/^struct chkpt_t{$/;"	s
chkpt_thread_t	chkpt.cpp	/^chkpt_thread_t::chkpt_thread_t()$/;"	f	class:chkpt_thread_t
chkpt_thread_t	chkpt.cpp	/^class chkpt_thread_t : public smthread_t$/;"	c	file:
chkpt_xct_lock_log	logrec.cpp	/^chkpt_xct_lock_log::chkpt_xct_lock_log($/;"	f	class:chkpt_xct_lock_log
chkpt_xct_lock_t	logrec.cpp	/^chkpt_xct_lock_t::chkpt_xct_lock_t($/;"	f	class:chkpt_xct_lock_t
chkpt_xct_lock_t	logrec.h	/^struct chkpt_xct_lock_t {$/;"	s
chkpt_xct_tab_log	logrec.cpp	/^chkpt_xct_tab_log::chkpt_xct_tab_log($/;"	f	class:chkpt_xct_tab_log
chkpt_xct_tab_t	logrec.cpp	/^chkpt_xct_tab_t::chkpt_xct_tab_t($/;"	f	class:chkpt_xct_tab_t
chkpt_xct_tab_t	logrec.h	/^struct chkpt_xct_tab_t {$/;"	s
cleaner	lock_core.cpp	/^    RawLockBackgroundThread*    cleaner;$/;"	m	struct:RawLockCleanerFunctor	file:
cleanup	xct.cpp	/^xct_t::cleanup(bool \/*dispose_prepared*\/)$/;"	f	class:xct_t
clear	bf_tree_cb.h	/^    inline void clear () {$/;"	f	struct:bf_tree_cb_t
clear	lock_lil.h	/^    void clear() {$/;"	f	class:lil_global_table
clear	lock_lil.h	/^    void clear() {$/;"	f	class:lil_private_store_table
clear	lock_lil.h	/^    void clear() {$/;"	f	class:lil_private_table
clear	lock_lil.h	/^    void clear() {$/;"	f	class:lil_private_vol_table
clear	partition.cpp	/^partition_t::clear()$/;"	f	class:partition_t
clear	pmap.h	/^    inline    void    clear(int bit) { bm_clr(bits, bit); }$/;"	f	struct:Pmap
clear	sm_du_stats.cpp	/^btree_int_stats_t::clear()$/;"	f	class:btree_int_stats_t
clear	sm_du_stats.cpp	/^btree_lf_stats_t::clear()$/;"	f	class:btree_lf_stats_t
clear	sm_du_stats.cpp	/^btree_stats_t::clear()$/;"	f	class:btree_stats_t
clear	sm_du_stats.cpp	/^sm_du_stats_t::clear()$/;"	f	class:sm_du_stats_t
clear	sm_du_stats.cpp	/^volume_hdr_stats_t::clear()$/;"	f	class:volume_hdr_stats_t
clear	sm_du_stats.cpp	/^volume_map_stats_t::clear()$/;"	f	class:volume_map_stats_t
clear_TL_stats	smthread.cpp	/^smthread_t::tcb_t::clear_TL_stats()$/;"	f	class:smthread_t::tcb_t
clear_all	pmap.h	/^    inline    void    clear_all() { bm_zero(bits, _count); }$/;"	f	struct:Pmap
clear_all_fingerprints	smthread.cpp	/^void clear_all_fingerprints()$/;"	f
clear_caches	vol.cpp	/^void vol_t::clear_caches()$/;"	f	class:vol_t
clear_ex_need	btree_impl.h	/^    inline static void clear_ex_need (shpid_t real_parent_pid) {$/;"	f	class:btree_impl
clear_except_latch	bf_tree_cb.h	/^    inline void clear_except_latch () {$/;"	f	struct:bf_tree_cb_t
clear_forster_child	btree_impl.h	/^    inline static void clear_forster_child (shpid_t foster_parent_pid) {$/;"	f	class:btree_impl
clear_in_doubt	bf_tree.cpp	/^void bf_tree_m::clear_in_doubt(const bf_idx idx, bool still_used, uint64_t key) {$/;"	f	class:bf_tree_m
clear_latch	bf_tree_cb.h	/^    inline void clear_latch() {$/;"	f	struct:bf_tree_cb_t
clear_lock_flags	lock_lil.cpp	/^inline void clear_lock_flags(bool *lock_taken, bool read_lock_only) {$/;"	f
clear_recovery_access	bf_tree.cpp	/^void bf_tree_m::clear_recovery_access(const generic_page* p) {$/;"	f	class:bf_tree_m
clear_recovery_access	fixable_page_h.cpp	/^void fixable_page_h::clear_recovery_access() const$/;"	f	class:fixable_page_h
clear_stats	xct.h	/^    void                        clear_stats() {$/;"	f	class:xct_t
clear_wait_map	lock_x.h	/^    void              clear_wait_map() {$/;"	f	class:xct_lock_info_t
clog	sm.cpp	/^log_core* smlevel_0::clog = 0;$/;"	m	class:smlevel_0	file:
clog	sm_base.h	/^    static log_core* clog;$/;"	m	class:smlevel_0
close	backup.cpp	/^void BackupFile::close() {$/;"	f	class:BackupFile
close	btcursor.cpp	/^void bt_cursor_t::close()$/;"	f	class:bt_cursor_t
close	logarchiver.cpp	/^void LogArchiver::ArchiveScanner::RunMerger::close()$/;"	f	class:LogArchiver::ArchiveScanner::RunMerger
close	logarchiver.h	/^        void close (RunMerger* merger)$/;"	f	class:LogArchiver::ArchiveScanner
close	partition.cpp	/^partition_t::close(bool both)$/;"	f	class:partition_t
close	partition.h	/^    void               close() { this->close(false);  }$/;"	f	class:partition_t
closeCurrentRun	logarchiver.cpp	/^rc_t LogArchiver::ArchiveDirectory::closeCurrentRun(lsn_t runEndLSN)$/;"	f	class:LogArchiver::ArchiveDirectory
closeScan	logarchiver.cpp	/^rc_t LogArchiver::ArchiveDirectory::closeScan(int& fd)$/;"	f	class:LogArchiver::ArchiveDirectory
close_for_append	partition.cpp	/^partition_t::close_for_append()$/;"	f	class:partition_t
close_for_read	partition.cpp	/^partition_t::close_for_read()$/;"	f	class:partition_t
clsn	generic_page.h	/^    const lsn_t&  clsn()   const { return _pp->clsn; }$/;"	f	class:generic_page_h
clsn	generic_page.h	/^    lsn_t            clsn;         \/\/ +8 -> 32$/;"	m	class:generic_page_header
cmp	logarchiver.h	/^            MergeHeapCmp cmp;$/;"	m	struct:LogArchiver::ArchiveScanner::RunMerger
cmp_t	sm_base.h	/^    enum cmp_t { bad_cmp_t=badOp, eq=eqOp,$/;"	g	class:smlevel_0
cnt	btree_logrec.h	/^                  cnt:15;$/;"	m	struct:btree_ghost_t
collect	lock_vtable.cpp	/^int lock_core_m::collect( vtable_t&, bool) { return 0; }$/;"	f	class:lock_core_m
collect	lock_vtable.cpp	/^lock_core_m::collect( vtable_t& v, bool names_too)$/;"	f	class:lock_core_m
collect	lock_vtable.cpp	/^lock_m::collect( vtable_t & res, bool names_too) $/;"	f	class:lock_m
collect	vtable_smthread.cpp	/^smthread_t::collect(vtable_t &v, bool names_too)$/;"	f	class:smthread_t
collect	vtable_xct.cpp	/^xct_t::collect( vtable_t& v, bool names_too)$/;"	f	class:xct_t
comment_log	logrec.cpp	/^comment_log::comment_log(const char *msg)$/;"	f	class:comment_log
commit	xct.cpp	/^xct_t::commit(bool lazy,lsn_t* plastlsn)$/;"	f	class:xct_t
commit	xct.h	/^    rc_t commit() {$/;"	f	class:xct_auto_abort_t
commit_as_group_member	xct.cpp	/^xct_t::commit_as_group_member()$/;"	f	class:xct_t
commit_free_locks	xct.cpp	/^xct_t::commit_free_locks(bool read_lock_only, lsn_t commit_lsn)$/;"	f	class:xct_t
commit_lsn	sm.cpp	/^lsn_t        smlevel_0::commit_lsn = lsn_t::null;$/;"	m	class:smlevel_0	file:
commit_lsn	sm_base.h	/^    static lsn_t        commit_lsn;      \/\/ commit_lsn is for use_concurrent_commit_restart() only$/;"	m	class:smlevel_0
commit_sys_xct	sm.cpp	/^ss_m::commit_sys_xct()$/;"	f	class:ss_m
commit_t	xct.h	/^    enum commit_t { t_normal = 0, t_lazy = 1, t_chain = 2, t_group = 4 };$/;"	g	class:xct_t
commit_xct	sm.cpp	/^ss_m::commit_xct(bool lazy, lsn_t* plastlsn)$/;"	f	class:ss_m
commit_xct	sm.cpp	/^ss_m::commit_xct(sm_stats_info_t*& _stats, bool lazy,$/;"	f	class:ss_m
commit_xct_group	sm.cpp	/^ss_m::commit_xct_group(xct_t *list[], int listlen)$/;"	f	class:ss_m
commitable_xct	prologue.h	/^        commitable_xct, \/\/ must be prepared if external,$/;"	e	enum:prologue_rc_t::xct_state_t
comp_lock_info_t	restart.h	/^    comp_lock_info_t(const okvl_mode& mode): lock_mode(mode) {};$/;"	f	struct:comp_lock_info_t
comp_lock_info_t	restart.h	/^struct comp_lock_info_t$/;"	s
comp_mount_log_t	restart.h	/^    comp_mount_log_t(): mount_log_rec_buf(NULL) {};$/;"	f	struct:comp_mount_log_t
comp_mount_log_t	restart.h	/^struct comp_mount_log_t$/;"	s
compact	btree_page.cpp	/^void btree_page_data::compact() {$/;"	f	class:btree_page_data
compare_with_chain_fence_high	btree_page_h.h	/^inline int btree_page_h::compare_with_chain_fence_high (const char* key, size_t key_len) const {$/;"	f	class:btree_page_h
compare_with_chain_fence_high	btree_page_h.h	/^inline int btree_page_h::compare_with_chain_fence_high (const w_keystr_t &key) const {$/;"	f	class:btree_page_h
compare_with_fence_high	btree_page_h.h	/^inline int btree_page_h::compare_with_fence_high (const char* key, size_t key_len) const {$/;"	f	class:btree_page_h
compare_with_fence_high	btree_page_h.h	/^inline int btree_page_h::compare_with_fence_high (const w_keystr_t &key) const {$/;"	f	class:btree_page_h
compare_with_fence_high_noprefix	btree_page_h.h	/^inline int btree_page_h::compare_with_fence_high_noprefix (const char* key, size_t key_len) const {$/;"	f	class:btree_page_h
compare_with_fence_low	btree_page_h.h	/^inline int btree_page_h::compare_with_fence_low (const char* key, size_t key_len) const {$/;"	f	class:btree_page_h
compare_with_fence_low	btree_page_h.h	/^inline int btree_page_h::compare_with_fence_low (const w_keystr_t &key) const {$/;"	f	class:btree_page_h
compare_with_fence_low_noprefix	btree_page_h.h	/^inline int btree_page_h::compare_with_fence_low_noprefix (const char* key, size_t key_len) const {$/;"	f	class:btree_page_h
compensate	log_core.cpp	/^rc_t log_core::compensate(const lsn_t& orig_lsn, const lsn_t& undo_lsn)$/;"	f	class:log_core
compensate	logbuf_core.cpp	/^rc_t logbuf_core::compensate(const lsn_t& orig_lsn, const lsn_t& undo_lsn) {$/;"	f	class:logbuf_core
compensate	xct.cpp	/^xct_t::compensate(const lsn_t& lsn, bool undoable ADD_LOG_COMMENT_SIG)$/;"	f	class:xct_t
compensate_log	logrec.cpp	/^compensate_log::compensate_log(const lsn_t& rec_lsn)$/;"	f	class:compensate_log
compensate_undo	xct.cpp	/^xct_t::compensate_undo(const lsn_t& lsn)$/;"	f	class:xct_t
compensated_op_depth	xct.cpp	/^check_compensated_op_nesting::compensated_op_depth(xct_t* xd, int dflt)$/;"	f	class:check_compensated_op_nesting
compensated_op_depth	xct.cpp	/^xct_t::compensated_op_depth() const$/;"	f	class:xct_t
complete_acquire	lock_raw.cpp	/^w_error_codes RawLockQueue::complete_acquire(RawLock** lock, bool check_only, int32_t timeout_in_ms) {$/;"	f	class:RawLockQueue
compress	btree_page_h.cpp	/^rc_t btree_page_h::compress(const w_keystr_t& low, const w_keystr_t& high,$/;"	f	class:btree_page_h
compute	smstats.cpp	/^void bf_htab_stats_t::compute()$/;"	f	class:bf_htab_stats_t
compute	smstats.cpp	/^void sm_stats_t::compute()$/;"	f	class:sm_stats_t
compute	smstats.h	/^    void    compute() { $/;"	f	class:sm_stats_info_t
concurrency_t	sm.h	/^    typedef smlevel_0::concurrency_t concurrency_t;$/;"	t	class:ss_m
concurrency_t	sm_base.h	/^    enum concurrency_t {$/;"	g	class:smlevel_0
concurrent_restart_mode_t	sm_base.h	/^    enum concurrent_restart_mode_t {$/;"	g	class:smlevel_0
cond	log_resv.h	/^        pthread_cond_t* cond;$/;"	m	struct:log_resv::waiting_xct
config_info	sm.cpp	/^ss_m::config_info(sm_config_info_t& info) {$/;"	f	class:ss_m
const_stats_ref	xct.h	/^    const sm_stats_info_t&      const_stats_ref() { return *__stats; }$/;"	f	class:xct_t
construct_once	btree.cpp	/^void btree_m::construct_once()$/;"	f	class:btree_m
construct_pid	logrec.h	/^logrec_t::construct_pid() const$/;"	f	class:logrec_t
construct_pid2	logrec.h	/^inline lpid_t logrec_t::construct_pid2() const {$/;"	f	class:logrec_t
consume_chkpt_reservation	log_core.h	/^    virtual fileoff_t           consume_chkpt_reservation(fileoff_t howmuch)$/;"	f	class:log_common
consume_chkpt_reservation	log_resv.cpp	/^fileoff_t log_resv::consume_chkpt_reservation(fileoff_t amt)$/;"	f	class:log_resv
consumer	logarchiver.h	/^    LogConsumer* consumer;$/;"	m	class:LogArchiver
consumerRelease	ringbuffer.h	/^inline void AsyncRingBuffer::consumerRelease()$/;"	f	class:AsyncRingBuffer
consumerRequest	ringbuffer.h	/^inline char* AsyncRingBuffer::consumerRequest()$/;"	f	class:AsyncRingBuffer
control	logarchiver.h	/^        ArchiverControl control;$/;"	m	class:LogArchiver::ReaderThread
control	logarchiver.h	/^    ArchiverControl control;$/;"	m	class:LogArchiver
copy_chain_fence_high_key	btree_page_h.h	/^    void                copy_chain_fence_high_key(w_keystr_t &buffer) const {$/;"	f	class:btree_page_h
copy_element	btree_page_h.cpp	/^bool btree_page_h::copy_element(int slot, char *out_buffer, smsize_t &len, bool &ghost) const {$/;"	f	class:btree_page_h
copy_fence_high_key	btree_page_h.h	/^    void                copy_fence_high_key(w_keystr_t &buffer) const {$/;"	f	class:btree_page_h
copy_fence_low_key	btree_page_h.h	/^    void                copy_fence_low_key(w_keystr_t &buffer) const$/;"	f	class:btree_page_h
copy_records	btree_page_h.cpp	/^rc_t btree_page_h::copy_records(const int  rec_count,     \/\/ In: number of records to copy$/;"	f	class:btree_page_h
core	lock.h	/^    lock_core_m*                core() const { return _core; }$/;"	f	class:lock_m
corrupt	logrec.cpp	/^logrec_t::corrupt()$/;"	f	class:logrec_t
count	log_carray.h	/^    carray_status_t count;              \/\/ +8 -> 72$/;"	m	struct:CArraySlot
count	logrec.h	/^    uint16_t count;$/;"	m	struct:chkpt_dev_tab_t
count	logrec.h	/^    uint32_t              count;$/;"	m	struct:chkpt_bf_tab_t
count	logrec.h	/^    uint32_t            count;$/;"	m	struct:chkpt_xct_tab_t
count	logrec.h	/^    uint32_t            count;$/;"	m	struct:xct_list_t
count	logrec.h	/^    uint32_t         count;$/;"	m	struct:chkpt_xct_lock_t
count	logrec.h	/^    uint32_t count;$/;"	m	struct:chkpt_backup_tab_t
count	pmap.h	/^    inline    int    count() const { return _count; }$/;"	f	struct:Pmap
count	restore.cpp	/^        size_t count;$/;"	m	struct:SegmentWriter::Request	file:
count	smthread.cpp	/^int smthread_init_t::count = 0;$/;"	m	class:smthread_init_t	file:
count	smthread.h	/^    static int       count;$/;"	m	class:smthread_init_t
crashtest	crash.cpp	/^crashtest($/;"	f	file:
create	btree.cpp	/^btree_m::create($/;"	f	class:btree_m
create_TL_stats	smthread.cpp	/^smthread_t::tcb_t::create_TL_stats() { $/;"	f	class:smthread_t::tcb_t
create_assoc	smindex.cpp	/^rc_t ss_m::create_assoc(stid_t stid, const w_keystr_t& key, const vec_t& el)$/;"	f	class:ss_m
create_index	smindex.cpp	/^rc_t ss_m::create_index(vid_t vid, stid_t &stid)$/;"	f	class:ss_m
create_part_okvl	btree_impl.cpp	/^okvl_mode btree_impl::create_part_okvl($/;"	f	class:btree_impl
create_store	vol.cpp	/^rc_t vol_t::create_store(smlevel_0::store_flag_t flags, snum_t& snum)$/;"	f	class:vol_t
create_vol	sm.cpp	/^ss_m::create_vol(const char* dev_name, smksize_t quota_KB, vid_t& vid)$/;"	f	class:ss_m
curr	xct.h	/^    xct_t* curr() const { return unsafe_iterator.curr(); }$/;"	f	class:xct_i
curr_lsn	log_core.h	/^    virtual lsn_t               curr_lsn()  const$/;"	f	class:log_common
curr_partition	log_storage.cpp	/^partition_t * log_storage::curr_partition() const$/;"	f	class:log_storage
current	lock_raw.h	/^        MarkablePointer<RawLock>    current;$/;"	m	struct:RawLockQueue::Iterator
currentBlock	logarchiver.h	/^        char* currentBlock;$/;"	m	class:LogArchiver::LogConsumer
currentFd	logarchiver.h	/^        int currentFd;$/;"	m	class:LogArchiver::BaseThread
currentRun	logarchiver.h	/^        uint8_t currentRun;$/;"	m	class:LogArchiver::ArchiverHeap
currentRun	logarchiver.h	/^        uint8_t currentRun;$/;"	m	class:LogArchiver::WriterThread
cursor	log.h	/^    lsn_t                        cursor;$/;"	m	class:log_i
data	btree_logrec.h	/^    char          data[logrec_t::max_data_sz - sizeof(uint16_t) * 2];$/;"	m	struct:btree_ghost_reserve_t
data	btree_logrec.h	/^    char        data[logrec_t::max_data_sz - sizeof(shpid_t) - 2*sizeof(int16_t) - sizeof(bool)];$/;"	m	struct:btree_insert_t
data	logrec.h	/^    char        data[logrec_t::max_data_sz - 2 * sizeof(size_t)];$/;"	m	struct:page_img_format_t
data	logrec.h	/^    char     data[logrec_t::max_data_sz];$/;"	m	struct:chkpt_backup_tab_t
data	logrec.h	/^    char     data[logrec_t::max_data_sz];$/;"	m	struct:chkpt_dev_tab_t
data	logrec.h	/^inline char*  logrec_t::data()$/;"	f	class:logrec_t
data	logrec.h	/^inline const char*  logrec_t::data() const$/;"	f	class:logrec_t
data	plog.h	/^    char*       data;$/;"	m	class:plog_t
data_bs	sm_du_stats.h	/^    base_stat_t        data_bs;           \/* space for data associated to keys *\/$/;"	m	struct:btree_lf_stats_t
data_size	logrec.h	/^    uint32_t data_size;$/;"	m	struct:chkpt_backup_tab_t
data_size	logrec.h	/^    uint32_t data_size;$/;"	m	struct:chkpt_dev_tab_t
data_ssx	logrec.h	/^inline char*  logrec_t::data_ssx()$/;"	f	class:logrec_t
data_ssx	logrec.h	/^inline const char*  logrec_t::data_ssx() const$/;"	f	class:logrec_t
data_ssx_multi	logrec.h	/^inline const multi_page_log_t* logrec_t::data_ssx_multi() const {$/;"	f	class:logrec_t
data_ssx_multi	logrec.h	/^inline multi_page_log_t* logrec_t::data_ssx_multi() {$/;"	f	class:logrec_t
data_sz	btree_page.h	/^        data_sz = sizeof(generic_page) - hdr_sz,$/;"	e	enum:btree_page_data::__anon4
data_sz	btree_page_h.h	/^        data_sz = btree_page::data_sz,$/;"	e	enum:btree_page_h::__anon12
dcommit_timeout	sm_base.h	/^    static int    dcommit_timeout; \/\/ to convey option to coordinator,$/;"	m	class:smlevel_0
deadlock_detected	lock_bucket.h	/^        bool deadlock_detected;$/;"	m	struct:lock_queue_t::check_grant_result
deadlock_detected_by_others	lock_raw.h	/^    bool                        deadlock_detected_by_others;$/;"	m	struct:RawXct
deadlock_myself_should_die	lock_bucket.h	/^        bool deadlock_myself_should_die;$/;"	m	struct:lock_queue_t::check_grant_result
deadlock_other_victim	lock_bucket.h	/^        smthread_t* deadlock_other_victim;$/;"	m	struct:lock_queue_t::check_grant_result
deadlocked	lock_raw.h	/^        bool        deadlocked;$/;"	m	struct:RawLockQueue::Compatibility
dealloc_a_page_log	logrec.cpp	/^dealloc_a_page_log::dealloc_a_page_log(vid_t vid, shpid_t pid)$/;"	f	class:dealloc_a_page_log
deallocate_lock	lock_raw.cpp	/^void RawXct::deallocate_lock(RawLock* lock) {$/;"	f	class:RawXct
deallocate_one_page	alloc_cache.cpp	/^rc_t alloc_cache_t::deallocate_one_page (shpid_t pid)$/;"	f	class:alloc_cache_t
deallocate_page	vol.cpp	/^rc_t vol_t::deallocate_page(const shpid_t& pid, bool redo)$/;"	f	class:vol_t
deallocate_xct	lock.cpp	/^void lock_m::deallocate_xct(RawXct* xct) {$/;"	f	class:lock_m
deallocate_xct	lock_core.cpp	/^void lock_core_m::deallocate_xct(RawXct* xct) {$/;"	f	class:lock_core_m
debug_abort	crash.h	/^	debug_abort,  \/\/ 3$/;"	e	enum:debuginfo_enum
debug_crash	crash.h	/^	debug_crash, \/\/ 2$/;"	e	enum:debuginfo_enum
debug_delay	crash.h	/^	debug_delay,  \/\/ 1$/;"	e	enum:debuginfo_enum
debug_dump	bf_tree.cpp	/^void bf_tree_m::debug_dump(std::ostream &o) const$/;"	f	class:bf_tree_m
debug_dump_page_pointers	bf_tree.cpp	/^void bf_tree_m::debug_dump_page_pointers(std::ostream& o, generic_page* page) const {$/;"	f	class:bf_tree_m
debug_dump_pointer	bf_tree.cpp	/^void bf_tree_m::debug_dump_pointer(ostream& o, shpid_t shpid) const$/;"	f	class:bf_tree_m
debug_get_original_pageid	bf_tree.cpp	/^shpid_t bf_tree_m::debug_get_original_pageid (shpid_t shpid) const {$/;"	f	class:bf_tree_m
debug_none	crash.h	/^	debug_none,  \/\/0$/;"	e	enum:debuginfo_enum
debug_yield	crash.h	/^	debug_yield };$/;"	e	enum:debuginfo_enum
debugflags	xct.cpp	/^debugflags(const char *a)$/;"	f
debuginfo	crash.cpp	/^struct debuginfo {$/;"	s	file:
debuginfo_enum	crash.h	/^enum debuginfo_enum { $/;"	g
defrag	btree_page_h.cpp	/^rc_t btree_page_h::defrag( const bool full_logging_redo) {$/;"	f	class:btree_page_h
defrag	mem_mgmt.cpp	/^rc_t fixed_lists_mem_t::defrag()$/;"	f	class:fixed_lists_mem_t
defrag_index_page	smindex.cpp	/^rc_t ss_m::defrag_index_page(btree_page_h &page)$/;"	f	class:ss_m
defrag_page	btree.cpp	/^rc_t btree_m::defrag_page(btree_page_h &page)$/;"	f	class:btree_m
delaytest	crash.cpp	/^delaytest($/;"	f	file:
delete_chain	bf_hashtable.cpp	/^    void delete_chain() {$/;"	f	struct:bf_hashbucket_chunk
delete_chain	bf_hashtable.cpp	/^    void delete_chain() {$/;"	f	struct:bf_hashbucket_chunk_linked
delete_chain	logbuf_hashtable.cpp	/^    void delete_chain() {$/;"	f	struct:logbuf_hashbucket_chunk
delete_chain	logbuf_hashtable.cpp	/^    void delete_chain() {$/;"	f	struct:logbuf_hashbucket_chunk_linked
delete_item	btree_page.cpp	/^void btree_page_data::delete_item(int item) {$/;"	f	class:btree_page_data
delete_old_partitions	log_storage.cpp	/^int log_storage::delete_old_partitions(lsn_t lsn)$/;"	f	class:log_storage
delete_range	btree_page.cpp	/^void btree_page_data::delete_range(int from, int to)$/;"	f	class:btree_page_data
delete_range	btree_page_h.cpp	/^void btree_page_h::delete_range(int from, int to)$/;"	f	class:btree_page_h
deleting	stnode_page.h	/^    uint16_t        deleting;  \/\/ +2 -> 8$/;"	m	struct:stnode_t
delink	lock_raw.cpp	/^bool RawLockQueue::delink(RawLock* predecessor, RawLock* target, RawLock* successor) const {$/;"	f	class:RawLockQueue
depth	smthread.cpp	/^__thread int func_helper::depth = 0;$/;"	m	class:func_helper	file:
depth	smthread.h	/^    static __thread int depth;$/;"	m	class:func_helper
deserialize	restore.cpp	/^void RestoreBitmap::deserialize(char* buf, size_t from, size_t to)$/;"	f	class:RestoreBitmap
deserializeRunInfo	logarchiver.cpp	/^rc_t LogArchiver::ArchiveIndex::deserializeRunInfo(RunInfo& run,$/;"	f	class:LogArchiver::ArchiveIndex
dest	logarchiver.h	/^        char* dest;$/;"	m	class:LogArchiver::BlockAssembly
destroy	bf_tree.cpp	/^w_rc_t bf_tree_m::destroy ()$/;"	f	class:bf_tree_m
destroy	partition.cpp	/^partition_t::destroy()$/;"	f	class:partition_t
destroy_TL_stats	smthread.cpp	/^smthread_t::tcb_t::destroy_TL_stats() {$/;"	f	class:smthread_t::tcb_t
destroy_assoc	smindex.cpp	/^rc_t ss_m::destroy_assoc(stid_t stid, const w_keystr_t& key)$/;"	f	class:ss_m
destroy_file	log_storage.cpp	/^log_storage::destroy_file(partition_number_t n, bool pmsg)$/;"	f	class:log_storage
destroy_index	smindex.cpp	/^rc_t ss_m::destroy_index(const stid_t& stid)$/;"	f	class:ss_m
destruct_once	btree.cpp	/^void btree_m::destruct_once()$/;"	f	class:btree_m
detach_thread	xct.cpp	/^xct_t::detach_thread()$/;"	f	class:xct_t
detach_update_thread	xct.cpp	/^xct_t::detach_update_thread()$/;"	f	class:xct_t
detach_xct	sm.h	/^    static void           detach_xct() { xct_t *x = me()->xct();$/;"	f	class:ss_m
detach_xct	smthread.cpp	/^smthread_t::detach_xct(xct_t* x)$/;"	f	class:smthread_t
dev_table	chkpt.h	/^  chkpt_dev_tab_t dev_table;$/;"	m	struct:chkpt_t
devname	vol.h	/^    const char* devname() const { return _devname; }$/;"	f	class:vol_t
dir_name	log_core.h	/^    virtual const char* dir_name() const$/;"	f	class:log_common
dir_name	log_storage.h	/^    const char *        dir_name() { return _logdir; }$/;"	f	class:log_storage
directory	logarchiver.h	/^            ArchiveDirectory* directory;$/;"	m	struct:LogArchiver::ArchiveScanner::RunScanner
directory	logarchiver.h	/^        ArchiveDirectory* directory;$/;"	m	class:LogArchiver::ArchiveScanner
directory	logarchiver.h	/^        ArchiveDirectory* directory;$/;"	m	class:LogArchiver::WriterThread
directory	logarchiver.h	/^    ArchiveDirectory* directory;$/;"	m	class:LogArchiver
disable_fake_disk_latency	sm.cpp	/^ss_m::disable_fake_disk_latency(vid_t vid)$/;"	f	class:ss_m
disable_fake_disk_latency	vol.cpp	/^void vol_t::disable_fake_disk_latency(void)$/;"	f	class:vol_t
dismount	vol.cpp	/^rc_t vol_t::dismount(bool bf_uninstall, bool abrupt)$/;"	f	class:vol_t
dismount_vol	sm.cpp	/^ss_m::dismount_vol(const char* path)$/;"	f	class:ss_m
dismount_vol_log	logrec.cpp	/^dismount_vol_log::dismount_vol_log(const char* dev_name)$/;"	f	class:dismount_vol_log
dispose	xct.cpp	/^xct_t::dispose()$/;"	f	class:xct_t
doMerge	logarchiver.cpp	/^rc_t LogArchiver::MergerDaemon::doMerge(int runNumber,$/;"	f	class:LogArchiver::MergerDaemon
do_prefetch	sm.cpp	/^bool        smlevel_0::do_prefetch = false;$/;"	m	class:smlevel_0	file:
do_prefetch	sm_base.h	/^    static bool         do_prefetch;$/;"	m	class:smlevel_0
does_already_own	lock_lil.cpp	/^bool does_already_own (lil_lock_modes_t mode, const bool *lock_taken) {$/;"	f
downgrade_latch	bf_tree.cpp	/^void bf_tree_m::downgrade_latch(const generic_page* p) {$/;"	f	class:bf_tree_m
dp_table	chkpt.h	/^  chkpt_bf_tab_t dp_table;$/;"	m	struct:chkpt_t
dummy	logrec.cpp	/^static logrec_accounting_impl_t dummy;$/;"	v	file:
dummy	sm_base.h	/^        dummy = 0$/;"	e	enum:smlevel_0::sm_constant_t
dump	lock.cpp	/^void lock_m::dump(ostream &o)$/;"	f	class:lock_m
dump	lock_dump.cpp	/^void lock_core_m::dump(ostream &o) {$/;"	f	class:lock_core_m
dump	xct.cpp	/^xct_t::dump(ostream &out)$/;"	f	class:xct_t
dumpHeap	logarchiver.cpp	/^void LogArchiver::ArchiveScanner::RunMerger::dumpHeap(ostream& out)$/;"	f	class:LogArchiver::ArchiveScanner::RunMerger
dumpIndex	logarchiver.cpp	/^void LogArchiver::ArchiveIndex::dumpIndex(ostream& out)$/;"	f	class:LogArchiver::ArchiveIndex
dumpThreadById	xct.cpp	/^dumpThreadById(int i) {$/;"	f
dumpXct	xct.cpp	/^extern "C" void dumpXct(const xct_t *x) { if(x) { cout << *x <<endl;} }$/;"	f
dump_all_sm_stats	sm.cpp	/^void dump_all_sm_stats()$/;"	f
dump_buffers	sm.cpp	/^ss_m::dump_buffers(ostream &o)$/;"	f	class:ss_m
dump_lockinfo	lock_raw.cpp	/^void RawXct::dump_lockinfo(std::ostream& o) const {$/;"	f	class:RawXct
dump_locks	sm.cpp	/^ss_m::dump_locks() {$/;"	f	class:ss_m
dump_locks	sm.cpp	/^ss_m::dump_locks(ostream &o)$/;"	f	class:ss_m
dump_locks	xct.cpp	/^xct_t::dump_locks(ostream &out) const$/;"	f	class:xct_t
dump_page_lsn_chain	log_spr.cpp	/^void restart_m::dump_page_lsn_chain(std::ostream &o, const lpid_t &pid, const lsn_t &max_lsn) {$/;"	f	class:restart_m
dump_page_lsn_chain	sm.cpp	/^void ss_m::dump_page_lsn_chain(std::ostream &o) {$/;"	f	class:ss_m
dump_page_lsn_chain	sm.cpp	/^void ss_m::dump_page_lsn_chain(std::ostream &o, const lpid_t &pid) {$/;"	f	class:ss_m
dump_page_lsn_chain	sm.cpp	/^void ss_m::dump_page_lsn_chain(std::ostream &o, const lpid_t &pid, const lsn_t &max_lsn) {$/;"	f	class:ss_m
dump_vol_store_info	sm.cpp	/^w_rc_t ss_m::dump_vol_store_info(const vid_t &vid)$/;"	f	class:ss_m
dump_xcts	sm.cpp	/^rc_t ss_m::dump_xcts(ostream& o)$/;"	f	class:ss_m
durable_lsn	log_core.h	/^    lsn_t               durable_lsn() const$/;"	f	class:log_common
dynamic_cast_to_const_smthread	smthread.cpp	/^smthread_t::dynamic_cast_to_const_smthread() const$/;"	f	class:smthread_t
dynamic_cast_to_smthread	smthread.cpp	/^smthread_t::dynamic_cast_to_smthread()$/;"	f	class:smthread_t
eFAILURE	sm_base.h	/^    enum error_constant_t { eNOERROR = 0, eFAILURE = -1 };$/;"	e	enum:smlevel_0::error_constant_t
eNOERROR	sm_base.h	/^    enum error_constant_t { eNOERROR = 0, eFAILURE = -1 };$/;"	e	enum:smlevel_0::error_constant_t
eager	logarchiver.h	/^    bool eager;$/;"	m	class:LogArchiver
early_lock_release	xct.cpp	/^rc_t xct_t::early_lock_release() {$/;"	f	class:xct_t
elem	btcursor.h	/^    char*             elem()     { return _eof ? 0 :  _elbuf; }$/;"	f	class:bt_cursor_t
elem	btree_page_h.h	/^    const cvec_t&      elem() const     { return _elem; }$/;"	f	class:btrec_t
element	btree_page_h.cpp	/^const char* btree_page_h::element(int slot, smsize_t &len, bool &ghost) const {$/;"	f	class:btree_page_h
element_length	btree_logrec.h	/^    uint16_t      element_length;$/;"	m	struct:btree_ghost_reserve_t
elen	btcursor.h	/^    int               elen() const     { return _elen; }$/;"	f	class:bt_cursor_t
elen	btree_logrec.h	/^    uint16_t    elen;$/;"	m	struct:btree_insert_t
elen	btree_page_h.h	/^    smsize_t           elen() const    { return _elem.size(); }$/;"	f	class:btrec_t
elr_clv	xct.h	/^        elr_clv$/;"	e	enum:xct_t::elr_mode_t
elr_mode_t	xct.h	/^    enum elr_mode_t {$/;"	g	class:xct_t
elr_none	xct.h	/^        elr_none,$/;"	e	enum:xct_t::elr_mode_t
elr_s	xct.h	/^        elr_s,$/;"	e	enum:xct_t::elr_mode_t
elr_sx	xct.h	/^        elr_sx,$/;"	e	enum:xct_t::elr_mode_t
emlsn_address	btree_page_h.h	/^inline lsn_t* btree_page_h::emlsn_address(general_recordid_t pos) {$/;"	f	class:btree_page_h
empty	bf_transit_bucket.h	/^    bool empty() { return _page_count < transit_bucket_t::MAX_IN_TRANSIT; }$/;"	f	class:transit_bucket_t
enable_fake_disk_latency	sm.cpp	/^ss_m::enable_fake_disk_latency(vid_t vid)$/;"	f	class:ss_m
enable_fake_disk_latency	vol.cpp	/^void vol_t::enable_fake_disk_latency(void)$/;"	f	class:vol_t
enclosure	lock_raw.h	/^        const RawLockQueue*         enclosure;$/;"	m	struct:RawLockQueue::Iterator
end	log_core.h	/^        long end;  \/\/ offset into log buffers _buf[0] of tail of$/;"	m	struct:log_common::epoch
end	logarchiver.h	/^            uint32_t end;$/;"	m	struct:LogArchiver::BlockAssembly::BlockHeader
end	ringbuffer.h	/^    int end;$/;"	m	class:AsyncRingBuffer
endLSN	logarchiver.h	/^            lsn_t endLSN;$/;"	m	struct:LogArchiver::ArchiveDirectory::RunFileStats
endLSN	logarchiver.h	/^        lsn_t endLSN;$/;"	m	class:LogArchiver::LogConsumer
endLSN	logarchiver.h	/^    lsn_t endLSN;$/;"	m	struct:ArchiverControl
endPID	logarchiver.h	/^            lpid_t endPID;$/;"	m	struct:LogArchiver::ArchiveScanner::RunMerger
end_byte	log_core.h	/^    long                 end_byte() const { return _end; }$/;"	f	class:log_common
end_sys_xct	xct.cpp	/^rc_t sys_xct_section_t::end_sys_xct (rc_t result)$/;"	f	class:sys_xct_section_t
ending_bytes	logrec.h	/^    size_t      ending_bytes;$/;"	m	struct:page_img_format_t
enqueue	restore.cpp	/^void RestoreScheduler::enqueue(const shpid_t& pid)$/;"	f	class:RestoreScheduler
enter	log_lsn_tracker.cpp	/^void PoorMansOldestLsnTracker::enter(uint64_t xct_id, const lsn_t& curr_lsn) {$/;"	f	class:PoorMansOldestLsnTracker
entered	smthread.h	/^    bool entered;$/;"	m	class:func_helper
entries	logarchiver.h	/^            std::vector<BlockEntry> entries;$/;"	m	struct:LogArchiver::ArchiveIndex::RunInfo
entries	logarchiver.h	/^            uint32_t entries;$/;"	m	struct:LogArchiver::ArchiveIndex::BlockHeader
entry	lock_x.h	/^    lock_queue_entry_t *entry;$/;"	m	class:xct_lock_entry_t
entry_cnt	sm_du_stats.h	/^    base_stat_t        entry_cnt;$/;"	m	struct:btree_lf_stats_t
entry_overhead_bs	sm_du_stats.h	/^    base_stat_t        entry_overhead_bs; \/* e.g., slot header, padding for alignment *\/$/;"	m	struct:btree_lf_stats_t
eof	btcursor.h	/^    bool              eof()     { return _eof;  }$/;"	f	class:bt_cursor_t
eof	sm_s.cpp	/^const lpid_t lpid_t::eof;$/;"	m	class:lpid_t	file:
eof	sm_s.h	/^    static const lpid_t eof;$/;"	m	class:lpid_t
eparity	ringbuffer.h	/^    bool eparity;$/;"	m	class:AsyncRingBuffer
epoch	eventlog.cpp	/^boost::gregorian::date sysevent_timer::epoch$/;"	m	class:sysevent_timer	file:
epoch	eventlog.h	/^    static boost::gregorian::date epoch;$/;"	m	class:sysevent_timer
epoch	log_core.h	/^        epoch()$/;"	f	struct:log_common::epoch
epoch	log_core.h	/^        epoch(lsn_t l, long b, long s, long e)$/;"	f	struct:log_common::epoch
epoch	log_core.h	/^    struct epoch {$/;"	s	class:log_common
eq	btree_page.cpp	/^bool btree_page_data::eq(const btree_page_data& b) const$/;"	f	class:btree_page_data
eq	sm_base.h	/^    enum cmp_t { bad_cmp_t=badOp, eq=eqOp,$/;"	e	enum:smlevel_0::cmp_t
errlog	sm.cpp	/^ErrLog*            smlevel_0::errlog;$/;"	m	class:smlevel_0	file:
errlog	sm_base.h	/^    static ErrLog* errlog;$/;"	m	class:smlevel_0
error	log_carray.h	/^    w_error_codes error;                \/\/ +sizeof(w_error_codes)$/;"	m	struct:CArraySlot
error_constant_t	sm_base.h	/^    enum error_constant_t { eNOERROR = 0, eFAILURE = -1 };$/;"	g	class:smlevel_0
error_encountered	xct.h	/^    bool                        error_encountered() const {  return false; }$/;"	f	class:xct_t
error_encountered	xct.h	/^    bool                        error_encountered() const {$/;"	f	class:xct_t
error_occurred	prologue.h	/^    bool error_occurred() const {return _rc.is_error();}$/;"	f	class:prologue_rc_t
estimate_required_space_to_merge	btree_impl_merge.cpp	/^smsize_t estimate_required_space_to_merge (btree_page_h &page, btree_page_h &merged)$/;"	f
evict_blocks	bf_tree_evict.cpp	/^w_rc_t bf_tree_m::evict_blocks(uint32_t& evicted_count,$/;"	f	class:bf_tree_m
evict_urgency_t	bf_tree.h	/^enum evict_urgency_t {$/;"	g
exists	partition.h	/^    bool               exists() const {$/;"	f	class:partition_t
ext_map_sz_in_bytes	sm_base.h	/^        ext_map_sz_in_bytes = ((ext_sz + 7) \/ 8),$/;"	e	enum:smlevel_0::sm_constant_t
ext_sz	sm_base.h	/^        ext_sz = SM_EXTENTSIZE,        \/\/ extent size$/;"	e	enum:smlevel_0::sm_constant_t
extent_size	sm_du_stats.h	/^    base_stat_t        extent_size;         \/* # of pages in an extent *\/$/;"	m	struct:volume_hdr_stats_t
extract_carray_log_size	log_carray.h	/^    static int32_t extract_carray_log_size(carray_status_t current_status) {$/;"	f	class:ConsolidationArray
extract_stid	lock_s.h	/^inline void lockid_t::extract_stid(stid_t &_s) const $/;"	f	class:lockid_t
exts_on_page	smstats.h	/^    u_long exts_on_page;$/;"	m	struct:sm_config_info_t
f	smthread.cpp	/^    SmthreadFunc&    f;$/;"	m	class:SelectSmthreadsFunc	file:
failureLSN	restore.h	/^    lsn_t failureLSN;$/;"	m	class:RestoreMgr
fake_disk_latency	vol.cpp	/^void vol_t::fake_disk_latency(long start)$/;"	f	class:vol_t
fd	logarchiver.h	/^            int fd;$/;"	m	struct:LogArchiver::ArchiveScanner::RunScanner
fence_contains	btree_page_h.h	/^inline bool btree_page_h::fence_contains(const w_keystr_t &key) const {$/;"	f	class:btree_page_h
fetch	log_core.cpp	/^log_core::fetch(lsn_t& ll, logrec_t*& rp, lsn_t* nxt, const bool forward)$/;"	f	class:log_core
fetch	logbuf_core.cpp	/^logbuf_core::fetch($/;"	f	class:logbuf_core
fetch_for_test	logbuf_core.cpp	/^int logbuf_core::fetch_for_test(lsn_t& lsn, logrec_t*& rp) {$/;"	f	class:logbuf_core
fhdl_app	partition.h	/^    int                fhdl_app() const { check_fhdl_app(); return _fhdl_app; }$/;"	f	class:partition_t
fhdl_rd	partition.h	/^    int                fhdl_rd() const { check_fhdl_rd(); return _fhdl_rd; }$/;"	f	class:partition_t
fields_sz	btree_logrec.h	/^        fields_sz = sizeof(multi_page_log_t)$/;"	e	enum:btree_bulk_delete_t::__anon3
file	smthread.h	/^    const char *file; $/;"	m	class:func_helper
fileSize	logarchiver.h	/^            size_t fileSize;$/;"	m	struct:LogArchiver::ArchiveDirectory::RunFileStats
file_was_archived	log_core.h	/^    virtual rc_t file_was_archived(const char *file)$/;"	f	class:log_common
file_was_archived	log_resv.cpp	/^log_resv::file_was_archived(const char * \/*file*\/)$/;"	f	class:log_resv
fileoff_t	log.cpp	/^typedef smlevel_0::fileoff_t fileoff_t;$/;"	t	file:
fileoff_t	log_core.cpp	/^typedef smlevel_0::fileoff_t fileoff_t;$/;"	t	file:
fileoff_t	log_resv.h	/^typedef smlevel_0::fileoff_t fileoff_t;$/;"	t
fileoff_t	log_storage.cpp	/^typedef smlevel_0::fileoff_t fileoff_t;$/;"	t	file:
fileoff_t	log_storage.h	/^    typedef smlevel_0::fileoff_t fileoff_t;$/;"	t	class:log_storage
fileoff_t	partition.h	/^    typedef smlevel_0::fileoff_t          fileoff_t;$/;"	t	class:partition_t
fileoff_t	sm_base.h	/^    typedef sthread_base_t::fileoff_t fileoff_t;$/;"	t	class:smlevel_0
fill	logrec.cpp	/^logrec_t::fill(const lpid_t* p, snum_t store, uint16_t tag, smsize_t l)$/;"	f	class:logrec_t
fill	logrec.h	/^    fill4    fill;      \/\/ for purify, +4 -> 16$/;"	m	struct:chkpt_bf_tab_t::brec_t
fill	logrec.h	/^    void fill(const generic_page_h& p, smsize_t length)$/;"	f	class:logrec_t
fill	logrec.h	/^    void fill(lpid_t pid, smsize_t length)$/;"	f	class:logrec_t
fill	logrec.h	/^    void fill(uint16_t tag, smsize_t length)$/;"	f	class:logrec_t
fill_xct_attr	logrec.cpp	/^logrec_t::fill_xct_attr(const tid_t& tid, const lsn_t& last)$/;"	f	class:logrec_t
filledFirst	logarchiver.h	/^        bool filledFirst;$/;"	m	class:LogArchiver::ArchiverHeap
filler	logrec.h	/^    fill4              filler;$/;"	m	struct:chkpt_bf_tab_t
filler	logrec.h	/^    fill4              filler;$/;"	m	struct:xct_list_t
filler	logrec.h	/^    fill4            filler;$/;"	m	struct:chkpt_xct_lock_t
filler	logrec.h	/^    fill4            filler;$/;"	m	struct:chkpt_xct_tab_t
filler	pmap.h	/^    fill1    filler;    \/\/ keep purify happy$/;"	m	class:Pmap_Align4
filler	pmap.h	/^    fill2    filler;    \/\/ keep purify happy$/;"	m	class:Pmap_Align4
filler	sm_s.h	/^    fill2        filler;  \/\/ for initialization of last 2 unused bytes$/;"	m	class:rid_t
filler	sm_s.h	/^    fill2        filler; \/\/ because page, snum_t are 4 bytes, slotid_t is 2$/;"	m	class:shrid_t
filler1	pmap.h	/^    fill1    filler1;    \/\/ keep purify happy$/;"	m	class:Pmap_Align4
filler2	pmap.h	/^    fill2    filler2;    \/\/ keep purify happy$/;"	m	class:Pmap_Align4
find	bf_hashtable.cpp	/^bool bf_hashbucket<T>::find(uint64_t key, T& value) {$/;"	f	class:bf_hashbucket
find	logbuf_hashtable.cpp	/^logbuf_seg* logbuf_hashbucket::find(uint64_t key) { $/;"	f	class:logbuf_hashbucket
findEntry	logarchiver.cpp	/^size_t LogArchiver::ArchiveIndex::findEntry(RunInfo* run,$/;"	f	class:LogArchiver::ArchiveIndex
findRun	logarchiver.cpp	/^size_t LogArchiver::ArchiveIndex::findRun(lsn_t lsn)$/;"	f	class:LogArchiver::ArchiveIndex
find_assoc	smindex.cpp	/^rc_t ss_m::find_assoc(stid_t stid, const w_keystr_t& key,$/;"	f	class:ss_m
find_dependent	xct.cpp	/^xct_t::find_dependent(xct_dependent_t* ptr)$/;"	f	class:xct_t
find_lock_queue	lock_bucket.h	/^inline lock_queue_t* bucket_t::find_lock_queue(uint32_t hash) {$/;"	f	class:bucket_t
find_lock_queue_create	lock_bucket.h	/^inline lock_queue_t* bucket_t::find_lock_queue_create(uint32_t hash) {$/;"	f	class:bucket_t
find_lock_queue_nocreate	lock_bucket.h	/^inline lock_queue_t* bucket_t::find_lock_queue_nocreate(uint32_t hash) {$/;"	f	class:bucket_t
find_page_id_slot	bf_tree.cpp	/^general_recordid_t bf_tree_m::find_page_id_slot(generic_page* page, shpid_t shpid) const {$/;"	f	class:bf_tree_m
find_partition	log_storage.cpp	/^log_storage::find_partition(lsn_t& ll, bool existing, bool recovery, bool forward)$/;"	f	class:log_storage
find_predecessor	lock_raw.cpp	/^RawLock* RawLockQueue::find_predecessor(RawLock* lock) const {$/;"	f	class:RawLockQueue
find_vol_table	lock_lil.cpp	/^lil_private_vol_table* lil_private_table::find_vol_table(uint16_t vid)$/;"	f	class:lil_private_table
finish	backup_reader.cpp	/^void BackupPrefetcher::finish()$/;"	f	class:BackupPrefetcher
finish	backup_reader.h	/^    virtual void finish()$/;"	f	class:BackupReader
finish	logarchiver.cpp	/^void LogArchiver::BlockAssembly::finish()$/;"	f	class:LogArchiver::BlockAssembly
finishRun	logarchiver.cpp	/^rc_t LogArchiver::ArchiveIndex::finishRun(lsn_t first, lsn_t last, int fd,$/;"	f	class:LogArchiver::ArchiveIndex
finishSegment	restore.cpp	/^void RestoreMgr::finishSegment(char* workspace, unsigned segment, size_t count)$/;"	f	class:RestoreMgr
finished	plog.h	/^        bool finished;$/;"	m	class:plog_t::iter_t
finished	restore.h	/^    bool finished()$/;"	f	class:RestoreMgr
finished	ringbuffer.h	/^    bool finished;$/;"	m	class:AsyncRingBuffer
firstDataPid	backup_reader.h	/^    shpid_t firstDataPid;$/;"	m	class:BackupReader
firstDataPid	restore.h	/^    shpid_t firstDataPid;$/;"	m	class:RestoreMgr
firstDataPid	restore.h	/^    shpid_t firstDataPid;$/;"	m	class:RestoreScheduler
firstLSN	logarchiver.h	/^            lsn_t firstLSN;$/;"	m	struct:LogArchiver::ArchiveIndex::RunInfo
firstNotRestored	logrec.h	/^    shpid_t firstNotRestored;$/;"	m	struct:chkpt_restore_tab_t
firstNotRestored	restore.h	/^    shpid_t firstNotRestored;$/;"	m	class:RestoreScheduler
firstPID	logarchiver.h	/^            const lpid_t firstPID;$/;"	m	struct:LogArchiver::ArchiveScanner::RunScanner
firstPID	logarchiver.h	/^        lpid_t firstPID;$/;"	m	class:LogArchiver::BlockAssembly
first_clear	pmap.h	/^    inline    int    first_clear(int start) const {$/;"	f	struct:Pmap
first_data_pageid	vol.h	/^    shpid_t     first_data_pageid() const { return _first_data_pageid; }$/;"	f	class:vol_t
first_lsn	log.h	/^    static lsn_t        first_lsn(uint32_t pnum) { return lsn_t(pnum, 0); }$/;"	f	class:log_m
first_lsn	logrec.h	/^    lsn_t                first_lsn;$/;"	m	struct:chkpt_xct_tab_t::xrec_t
first_lsn	partition.h	/^    lsn_t              first_lsn() const { return$/;"	f	class:partition_t
first_lsn	partition.h	/^    lsn_t            first_lsn(uint32_t pnum) const { return lsn_t( pnum, 0); }$/;"	f	class:partition_t
first_lsn	xct.h	/^xct_t::first_lsn() const$/;"	f	class:xct_t
first_set	pmap.h	/^    inline    int    first_set(int start) const {$/;"	f	struct:Pmap
first_used_body	btree_page.h	/^    body_offset_t first_used_body;                 \/\/ +2 -> 30$/;"	m	class:btree_page_data
fix	backup_reader.cpp	/^char* BackupOnDemandReader::fix(unsigned segment)$/;"	f	class:BackupOnDemandReader
fix	backup_reader.cpp	/^char* BackupPrefetcher::fix(unsigned segment)$/;"	f	class:BackupPrefetcher
fix	backup_reader.h	/^    virtual char* fix(unsigned)$/;"	f	class:DummyBackupReader
fixChildren	bf_tree.cpp	/^void WarmupThread::fixChildren(btree_page_h& parent, size_t& fixed, size_t max)$/;"	f	class:WarmupThread
fixWaiting	backup_reader.h	/^    bool fixWaiting;$/;"	m	class:BackupPrefetcher
fix_direct	bf_tree.cpp	/^w_rc_t bf_tree_m::fix_direct (generic_page*& page, vid_t vol, shpid_t shpid, latch_mode_t mode, bool conditional, bool virgin_page) {$/;"	f	class:bf_tree_m
fix_direct	fixable_page_h.cpp	/^w_rc_t fixable_page_h::fix_direct(vid_t vol, shpid_t shpid,$/;"	f	class:fixable_page_h
fix_nonbufferpool_page	fixable_page_h.cpp	/^void fixable_page_h::fix_nonbufferpool_page(generic_page* s) {$/;"	f	class:fixable_page_h
fix_nonroot	bf_tree.cpp	/^w_rc_t bf_tree_m::fix_nonroot(generic_page*& page, generic_page *parent,$/;"	f	class:bf_tree_m
fix_nonroot	fixable_page_h.cpp	/^w_rc_t fixable_page_h::fix_nonroot(const fixable_page_h &parent, vid_t vol,$/;"	f	class:fixable_page_h
fix_recovery_redo	fixable_page_h.cpp	/^w_rc_t fixable_page_h::fix_recovery_redo(bf_idx idx, lpid_t page_updated,$/;"	f	class:fixable_page_h
fix_recovery_redo_managed	fixable_page_h.cpp	/^w_rc_t fixable_page_h::fix_recovery_redo_managed()$/;"	f	class:fixable_page_h
fix_root	bf_tree.cpp	/^w_rc_t bf_tree_m::fix_root (generic_page*& page, stid_t store,$/;"	f	class:bf_tree_m
fix_root	fixable_page_h.cpp	/^w_rc_t fixable_page_h::fix_root (stid_t store, latch_mode_t mode,$/;"	f	class:fixable_page_h
fix_unsafely_nonroot	bf_tree.cpp	/^w_rc_t bf_tree_m::fix_unsafely_nonroot(generic_page*& page, shpid_t shpid, latch_mode_t mode, bool conditional, q_ticket_t& ticket) {$/;"	f	class:bf_tree_m
fix_virgin_root	bf_tree.cpp	/^w_rc_t bf_tree_m::fix_virgin_root (generic_page*& page, stid_t store, shpid_t shpid) {$/;"	f	class:bf_tree_m
fix_virgin_root	fixable_page_h.cpp	/^w_rc_t fixable_page_h::fix_virgin_root (stid_t store, shpid_t shpid) {$/;"	f	class:fixable_page_h
fix_with_Q_root	bf_tree.cpp	/^w_rc_t bf_tree_m::fix_with_Q_root(generic_page*& page, stid_t store, q_ticket_t& ticket) {$/;"	f	class:bf_tree_m
fixable_page_h	fixable_page_h.h	/^    fixable_page_h() : generic_page_h(NULL), _bufferpool_managed(false), _mode(LATCH_NL) {}$/;"	f	class:fixable_page_h
fixable_page_h	fixable_page_h.h	/^class fixable_page_h : public generic_page_h {$/;"	c
fixedSegment	backup_reader.h	/^    int fixedSegment;$/;"	m	class:BackupOnDemandReader
fixed_lists_mem_t	mem_mgmt.cpp	/^fixed_lists_mem_t::fixed_lists_mem_t(size_t bufsize, size_t incr, size_t max)$/;"	f	class:fixed_lists_mem_t
fixed_lists_mem_t	mem_mgmt.h	/^class fixed_lists_mem_t : public mem_mgmt_t {$/;"	c
flags	stnode_page.h	/^    uint16_t        flags;     \/\/ +2 -> 6$/;"	m	struct:stnode_t
floor2	log_storage.h	/^    static long         floor2(long offset, long block_size)$/;"	f	class:log_storage
flush	bf_fixed.cpp	/^w_rc_t bf_fixed_m::flush(bool toBackup)$/;"	f	class:bf_fixed_m
flush	log_core.cpp	/^rc_t log_core::flush(const lsn_t &to_lsn, bool block, bool signal, bool *ret_flushed)$/;"	f	class:log_core
flush	logbuf_core.cpp	/^rc_t logbuf_core::flush($/;"	f	class:logbuf_core
flush	partition.cpp	/^partition_t::flush($/;"	f	class:partition_t
flush	partition.cpp	/^partition_t::flush(int fd)$/;"	f	class:partition_t
flush	partition.cpp	/^partition_t::flush(int fd, lsn_t lsn, int64_t size, int64_t write_size,$/;"	f	class:partition_t
flushReqLSN	logarchiver.h	/^    lsn_t flushReqLSN;$/;"	m	class:LogArchiver
flush_all	log.h	/^    rc_t    flush_all(bool block=true) {$/;"	f	class:log_m
flush_daemon	log_core.cpp	/^void log_common::flush_daemon()$/;"	f	class:log_common
flush_daemon_thread_t	log_core.cpp	/^    flush_daemon_thread_t(log_common* log) :$/;"	f	class:flush_daemon_thread_t
flush_daemon_thread_t	log_core.cpp	/^class flush_daemon_thread_t : public smthread_t {$/;"	c	file:
flush_daemon_work	log_core.cpp	/^lsn_t log_core::flush_daemon_work(lsn_t old_mark)$/;"	f	class:log_core
flush_daemon_work	logbuf_core.cpp	/^lsn_t logbuf_core::flush_daemon_work(lsn_t old_mark) $/;"	f	class:logbuf_core
flush_until	sm.cpp	/^ss_m::flush_until(lsn_t& anlsn, bool block)$/;"	f	class:ss_m
flushlog	sm.cpp	/^rc_t ss_m::flushlog() {$/;"	f	class:ss_m
footer	mem_mgmt.h	/^        uint16_t footer() {$/;"	f	class:fixed_lists_mem_t::list_header_t
for_each_smthread	smthread.cpp	/^smthread_t::for_each_smthread(SmthreadFunc& f)$/;"	f	class:smthread_t
force_Q_fixing	fixable_page_h.cpp	/^int fixable_page_h::force_Q_fixing = 0;  \/\/ <<<>>>$/;"	m	class:fixable_page_h	file:
force_Q_fixing	fixable_page_h.h	/^    static int force_Q_fixing; \/\/ converts S mode to Q when: 0=no (default), 1=root only, 2=all <<<>>>$/;"	m	class:fixable_page_h
force_a_flush	logbuf_core.cpp	/^void logbuf_core::force_a_flush() {$/;"	f	class:logbuf_core
force_all	bf_tree.cpp	/^w_rc_t bf_tree_m::force_all() {$/;"	f	class:bf_tree_m
force_all	bf_tree_cleaner.cpp	/^w_rc_t bf_tree_cleaner::force_all()$/;"	f	class:bf_tree_cleaner
force_buffers	sm.cpp	/^rc_t ss_m::force_buffers() {$/;"	f	class:ss_m
force_fixed_buffers	vol.cpp	/^rc_t vol_m::force_fixed_buffers()$/;"	f	class:vol_m
force_nonblocking	xct.cpp	/^xct_t::force_nonblocking()$/;"	f	class:xct_t
force_until_lsn	bf_tree.cpp	/^w_rc_t bf_tree_m::force_until_lsn(lsndata_t lsn) {$/;"	f	class:bf_tree_m
force_until_lsn	bf_tree.h	/^    w_rc_t force_until_lsn (const lsn_t &lsn) {$/;"	f	class:bf_tree_m
force_until_lsn	bf_tree_cleaner.cpp	/^w_rc_t bf_tree_cleaner::force_until_lsn(lsndata_t lsn)$/;"	f	class:bf_tree_cleaner
force_volume	bf_tree.cpp	/^w_rc_t bf_tree_m::force_volume(vid_t vol) {$/;"	f	class:bf_tree_m
force_volume	bf_tree_cleaner.cpp	/^w_rc_t bf_tree_cleaner::force_volume(vid_t vol)$/;"	f	class:bf_tree_cleaner
force_volume	sm.cpp	/^rc_t ss_m::force_volume(vid_t vol) {$/;"	f	class:ss_m
format_foster_child	btree_page_h.cpp	/^rc_t btree_page_h::format_foster_child(btree_page_h& parent,$/;"	f	class:btree_page_h
format_steal	btree_page_h.cpp	/^rc_t btree_page_h::format_steal(lsn_t            new_lsn,         \/\/ LSN of the operation that creates this new page$/;"	f	class:btree_page_h
format_vol_log	logrec.cpp	/^format_vol_log::format_vol_log(const char* path, shpid_t num_pages, vid_t vid)$/;"	f	class:format_vol_log
forward	plog.h	/^        bool forward;$/;"	m	class:plog_t::iter_t
forward_scan	log.h	/^    bool                         forward_scan;$/;"	m	class:log_i
fpos	logarchiver.h	/^        size_t fpos;$/;"	m	class:LogArchiver::BlockAssembly
free	mem_mgmt.cpp	/^rc_t fixed_lists_mem_t::free(slot_t slot)$/;"	f	class:fixed_lists_mem_t
func_helper	smthread.h	/^    func_helper(const char *name, $/;"	f	class:func_helper
func_helper	smthread.h	/^class func_helper {$/;"	c
g_check_deadlock_impl	lock_core.cpp	/^w_error_codes (*g_check_deadlock_impl)(xct_t* xd, lock_request_t *myreq);$/;"	v
g_deadlock_dreadlock_interval_ms	lock_core.cpp	/^int g_deadlock_dreadlock_interval_ms = 10;$/;"	v
g_deadlock_use_waitmap_obsolete	lock_core.cpp	/^bool g_deadlock_use_waitmap_obsolete = true;$/;"	v
g_me	smthread.h	/^inline smthread_t* g_me() $/;"	f
g_xct	smthread.h	/^inline xct_t* g_xct() $/;"	f
g_xct_does_ex_lock_for_select	xct.h	/^g_xct_does_ex_lock_for_select()$/;"	f
g_xct_does_need_lock	xct.h	/^g_xct_does_need_lock()$/;"	f
gather_stats	sm.cpp	/^ss_m::gather_stats(sm_stats_info_t& _stats)$/;"	f	class:ss_m
gather_xct_stats	sm.cpp	/^ss_m::gather_xct_stats(sm_stats_info_t& _stats, bool reset)$/;"	f	class:ss_m
ge	sm_base.h	/^                 gt=gtOp, ge=geOp, lt=ltOp, le=leOp };$/;"	e	enum:smlevel_0::cmp_t
generate_log_warnings	smthread.h	/^    bool            generate_log_warnings()const{return _gen_log_warnings;}$/;"	f	class:smthread_t
generic_page	generic_page.h	/^class generic_page : public generic_page_header {$/;"	c
generic_page_h	generic_page.h	/^    generic_page_h(generic_page* s) : _pp(s) {}$/;"	f	class:generic_page_h
generic_page_h	generic_page.h	/^    generic_page_h(generic_page* s, const lpid_t& pid, page_tag_t tag,$/;"	f	class:generic_page_h
generic_page_h	generic_page.h	/^class generic_page_h {$/;"	c
generic_page_header	generic_page.h	/^class generic_page_header {$/;"	c
get	bf_transit_bucket.h	/^    static  transit_bucket_t & get(bfpid_t const &pid) $/;"	f	class:transit_bucket_t
get	plog.cpp	/^char* plog_t::get()$/;"	f	class:plog_t
get	restore.cpp	/^bool RestoreBitmap::get(unsigned i)$/;"	f	class:RestoreBitmap
get	stnode_page.h	/^    const stnode_t& get(size_t index) const {$/;"	f	class:stnode_page_h
get	stnode_page.h	/^    stnode_t& get(size_t index) {$/;"	f	class:stnode_page_h
get	vol.cpp	/^vol_t* vol_m::get(const char* path)$/;"	f	class:vol_m
get	vol.cpp	/^vol_t* vol_m::get(vid_t vid)$/;"	f	class:vol_m
getArchDir	logarchiver.h	/^        std::string getArchDir() { return archdir; }$/;"	f	class:LogArchiver::ArchiveDirectory
getBackup	restore.h	/^    BackupReader* getBackup() { return backup; }$/;"	f	class:RestoreMgr
getBitmap	restore.h	/^    RestoreBitmap* getBitmap() { return bitmap; }$/;"	f	class:RestoreMgr
getBlockCount	ringbuffer.h	/^    size_t getBlockCount() { return blockCount; }$/;"	f	class:AsyncRingBuffer
getBlockCounts	logarchiver.cpp	/^rc_t LogArchiver::ArchiveIndex::getBlockCounts(int fd, size_t* indexBlocks,$/;"	f	class:LogArchiver::ArchiveIndex
getBlockSize	logarchiver.h	/^        size_t getBlockSize() { return blockSize; }$/;"	f	class:LogArchiver::ArchiveDirectory
getBlockSize	logarchiver.h	/^        size_t getBlockSize() { return blockSize; }$/;"	f	class:LogArchiver::BaseThread
getBlockSize	logarchiver.h	/^    size_t getBlockSize() {$/;"	f	class:LogScanner
getBlockSize	ringbuffer.h	/^    size_t getBlockSize() { return blockSize; }$/;"	f	class:AsyncRingBuffer
getBoundaries	restore.cpp	/^void RestoreBitmap::getBoundaries(size_t& lowestFalse, size_t& highestTrue)$/;"	f	class:RestoreBitmap
getBucketSize	logarchiver.h	/^        size_t getBucketSize() { return bucketSize; }$/;"	f	class:LogArchiver::ArchiveIndex
getDirectory	logarchiver.h	/^        ArchiveDirectory* getDirectory() { return directory; }$/;"	f	class:LogArchiver::WriterThread
getDirectory	logarchiver.h	/^    ArchiveDirectory* getDirectory() { return directory; }$/;"	f	class:LogArchiver
getEager	logarchiver.h	/^    bool getEager() const { return eager; }$/;"	f	class:LogArchiver
getEndOfBlock	logarchiver.cpp	/^size_t LogArchiver::BlockAssembly::getEndOfBlock(const char* b)$/;"	f	class:LogArchiver::BlockAssembly
getEndPID	logarchiver.h	/^            lpid_t getEndPID() { return endPID; }$/;"	f	struct:LogArchiver::ArchiveScanner::RunMerger
getFileSize	logarchiver.cpp	/^size_t LogArchiver::ArchiveDirectory::getFileSize(int fd)$/;"	f	class:LogArchiver::ArchiveDirectory
getFirstDataPid	restore.h	/^    shpid_t getFirstDataPid() { return firstDataPid; }$/;"	f	class:RestoreMgr
getIndex	logarchiver.h	/^        ArchiveIndex* getIndex() { return archIndex; }$/;"	f	class:LogArchiver::ArchiveDirectory
getLSNFromBlock	logarchiver.cpp	/^lsn_t LogArchiver::BlockAssembly::getLSNFromBlock(const char* b)$/;"	f	class:LogArchiver::BlockAssembly
getLastLSN	logarchiver.h	/^        lsn_t getLastLSN() { return lastLSN; }$/;"	f	class:LogArchiver::ArchiveDirectory
getLastMountLSN	log_core.h	/^    virtual lsn_t getLastMountLSN() const { return _lastMountLSN; }$/;"	f	class:log_common
getLastUsedPid	restore.h	/^    shpid_t getLastUsedPid() { return lastUsedPid; }$/;"	f	class:RestoreMgr
getNextConsumedLSN	logarchiver.h	/^    lsn_t getNextConsumedLSN() { return consumer->getNextLSN(); }$/;"	f	class:LogArchiver
getNextLSN	logarchiver.h	/^        lsn_t getNextLSN() { return nextLSN; }$/;"	f	class:LogArchiver::LogConsumer
getPidForSegment	restore.h	/^inline shpid_t RestoreMgr::getPidForSegment(unsigned segment)$/;"	f	class:RestoreMgr
getPrefetchWindow	restore.h	/^    unsigned getPrefetchWindow() { return prefetchWindow; }$/;"	f	class:RestoreMgr
getRunFromBlock	logarchiver.cpp	/^int LogArchiver::BlockAssembly::getRunFromBlock(const char* b)$/;"	f	class:LogArchiver::BlockAssembly
getSegmentForPid	restore.h	/^inline unsigned RestoreMgr::getSegmentForPid(const shpid_t& pid)$/;"	f	class:RestoreMgr
getSegmentSize	restore.h	/^    size_t getSegmentSize() { return segmentSize; }$/;"	f	class:RestoreMgr
getSize	restore.h	/^    size_t getSize() { return bits.size(); }$/;"	f	class:RestoreBitmap
getStartLSN	logarchiver.h	/^        lsn_t getStartLSN() { return startLSN; }$/;"	f	class:LogArchiver::ArchiveDirectory
get_1thread_xct_me	smthread.h	/^    queue_based_lock_t::ext_qnode& get_1thread_xct_me() {$/;"	f	class:smthread_t
get_all_used_store_ID	stnode_page.cpp	/^std::vector<snum_t> stnode_cache_t::get_all_used_store_ID() const {$/;"	f	class:stnode_cache_t
get_alloc_cache	vol.h	/^    alloc_cache_t*           get_alloc_cache() {return _alloc_cache;}$/;"	f	class:vol_t
get_backup_folder	backup.h	/^inline const string& BackupManager::get_backup_folder() const { return _backup_folder; }$/;"	f	class:BackupManager
get_backup_lsn	vol.cpp	/^lsn_t vol_t::get_backup_lsn()$/;"	f	class:vol_t
get_backup_path	backup.cpp	/^std::string BackupManager::get_backup_path(vid_t vid) const {$/;"	f	class:BackupManager
get_best_fit	mem_mgmt.h	/^        static size_t get_best_fit(size_t length, size_t incr) {$/;"	f	class:fixed_lists_mem_t::list_header_t
get_block_cnt	bf_tree.h	/^    inline bf_idx get_block_cnt() const {return _block_cnt;}$/;"	f	class:bf_tree_m
get_bool_option	sm_options.h	/^inline bool sm_options::get_bool_option(const std::string& option_name, bool default_value) const {$/;"	f	class:sm_options
get_buffer	backup.h	/^inline char* AlignedMemory::get_buffer() { return _buffer; }$/;"	f	class:AlignedMemory
get_cb	bf_tree.cpp	/^bf_tree_cb_t& bf_tree_m::get_cb(bf_idx idx) const {$/;"	f	class:bf_tree_m
get_cb	bf_tree.cpp	/^bf_tree_cb_t* bf_tree_m::get_cb(const generic_page *page) {$/;"	f	class:bf_tree_m
get_cbp	bf_tree.cpp	/^bf_tree_cb_t* bf_tree_m::get_cbp(bf_idx idx) const {$/;"	f	class:bf_tree_m
get_chain_fence_high_key	btree_page_h.h	/^inline const char* btree_page_h::get_chain_fence_high_key() const {$/;"	f	class:btree_page_h
get_chain_fence_high_length	btree_page_h.h	/^inline int16_t btree_page_h::get_chain_fence_high_length() const {$/;"	f	class:btree_page_h
get_checkpoint_lock	bf_fixed.h	/^inline srwlock_t& bf_fixed_m::get_checkpoint_lock() {$/;"	f	class:bf_fixed_m
get_cleaner_for_vol	bf_tree_cleaner.cpp	/^unsigned bf_tree_cleaner::get_cleaner_for_vol(vid_t vid)$/;"	f	class:bf_tree_cleaner
get_consecutive_free_page_count	alloc_cache.cpp	/^size_t alloc_cache_t::get_consecutive_free_page_count () const$/;"	f	class:alloc_cache_t
get_context	btree_impl_verify.cpp	/^verification_context* verify_volume_result::get_context (snum_t store_id)$/;"	f	class:verify_volume_result
get_curr_lsn	sm.cpp	/^ss_m::get_curr_lsn(lsn_t& anlsn)$/;"	f	class:ss_m
get_data	plog.h	/^    char* get_data() { return data; }$/;"	f	class:plog_t
get_device_quota	sm.cpp	/^ss_m::get_device_quota(const char* device, size_t& quota_KB, size_t& quota_used_KB)$/;"	f	class:ss_m
get_dirty_flags	bf_fixed.h	/^inline bool* bf_fixed_m::get_dirty_flags () {$/;"	f	class:bf_fixed_m
get_du_statistics	btree.cpp	/^btree_m::get_du_statistics($/;"	f	class:btree_m
get_du_statistics	sm.cpp	/^ss_m::get_du_statistics(const stid_t& stid, sm_du_stats_t& du, bool audit)$/;"	f	class:ss_m
get_du_statistics	sm.cpp	/^ss_m::get_du_statistics(vid_t vid, sm_du_stats_t& du, bool audit)$/;"	f	class:ss_m
get_durable_lsn	sm.cpp	/^ss_m::get_durable_lsn(lsn_t& anlsn)$/;"	f	class:ss_m
get_elr_mode	xct.h	/^    elr_mode_t                  get_elr_mode() const { return _elr_mode; }$/;"	f	class:xct_t
get_emlsn_general	btree_page_h.h	/^inline const lsn_t& btree_page_h::get_emlsn_general(general_recordid_t pos) const {$/;"	f	class:btree_page_h
get_expected_childrens	btree_impl.h	/^    inline static uint8_t get_expected_childrens (shpid_t pid) {$/;"	f	class:btree_impl
get_fence_high_key_noprefix	btree_page_h.h	/^inline const char* btree_page_h::get_fence_high_key_noprefix() const {$/;"	f	class:btree_page_h
get_fence_high_length	btree_page_h.h	/^inline int16_t btree_page_h::get_fence_high_length() const {$/;"	f	class:btree_page_h
get_fence_high_length_noprefix	btree_page_h.h	/^    int16_t           get_fence_high_length_noprefix() const {$/;"	f	class:btree_page_h
get_fence_low_key	btree_page_h.h	/^inline const char* btree_page_h::get_fence_low_key() const {$/;"	f	class:btree_page_h
get_fence_low_length	btree_page_h.h	/^inline int16_t btree_page_h::get_fence_low_length() const {$/;"	f	class:btree_page_h
get_fingerprint_map	smthread.h	/^    const atomic_thread_map_t&  get_fingerprint_map() const$/;"	f	class:smthread_t
get_finished	ringbuffer.h	/^    bool* get_finished() { return &finished; } \/\/ not thread-safe$/;"	f	class:AsyncRingBuffer
get_fixed_bf	vol.h	/^    bf_fixed_m*              get_fixed_bf() {return _fixed_bf;}$/;"	f	class:vol_t
get_foster	btree_page_h.cpp	/^shpid_t btree_page_h::get_foster() const {$/;"	f	class:btree_page_h
get_foster_emlsn	btree_page_h.h	/^inline const lsn_t& btree_page_h::get_foster_emlsn() const {$/;"	f	class:btree_page_h
get_foster_opaqueptr	btree_page_h.h	/^inline shpid_t btree_page_h::get_foster_opaqueptr() const {$/;"	f	class:btree_page_h
get_generic_page	generic_page.h	/^    generic_page* get_generic_page() const { return _pp; }$/;"	f	class:generic_page_h
get_granted_mode	lock.cpp	/^okvl_mode lock_m::get_granted_mode(const lockid_t& lock_id) {$/;"	f	class:lock_m
get_granted_mode	lock.cpp	/^okvl_mode lock_m::get_granted_mode(uint32_t hash) {$/;"	f	class:lock_m
get_granted_mode	lock_bucket.h	/^    const okvl_mode& get_granted_mode() const { return _granted_mode; }$/;"	f	class:lock_queue_entry_t
get_granted_mode	lock_raw.cpp	/^okvl_mode RawXctLockHashMap::get_granted_mode(uint32_t lock_id) const {$/;"	f	class:RawXctLockHashMap
get_granted_mode	lock_x.cpp	/^const okvl_mode& XctLockHashMap::get_granted_mode(uint32_t lock_id) const {$/;"	f	class:XctLockHashMap
get_idx	bf_tree.cpp	/^bf_idx bf_tree_m::get_idx(const bf_tree_cb_t* cb) const {$/;"	f	class:bf_tree_m
get_int_option	sm_options.h	/^inline int64_t sm_options::get_int_option(const std::string& option_name, int64_t default_value) const {$/;"	f	class:sm_options
get_key	btree_logrec.cpp	/^w_keystr_t btree_ghost_t::get_key (size_t i) const {$/;"	f	class:btree_ghost_t
get_key	btree_page_h.cpp	/^void btree_page_h::get_key(slotid_t slot,  w_keystr_t &key) const {$/;"	f	class:btree_page_h
get_keys	btree_logrec.h	/^    void get_keys(w_keystr_t& new_high_fence, w_keystr_t& new_chain)$/;"	f	struct:btree_bulk_delete_t
get_last_lsns	log_storage.cpp	/^int log_storage::get_last_lsns(lsn_t *array)$/;"	f	class:log_storage
get_last_rc	log.h	/^log_i::get_last_rc()$/;"	f	class:log_i
get_left_neighbor	mem_mgmt.h	/^        list_header_t* get_left_neighbor() {$/;"	f	class:fixed_lists_mem_t::list_header_t
get_lil_global_table	lock.cpp	/^lil_global_table* lock_m::get_lil_global_table() {$/;"	f	class:lock_m
get_lil_global_table	lock_core.h	/^    lil_global_table*   get_lil_global_table() { return _lil_global_table; }$/;"	f	class:lock_core_m
get_lil_global_table	sm.cpp	/^lil_global_table* ss_m::get_lil_global_table() {$/;"	f	class:ss_m
get_log_features	sm.cpp	/^char const* ss_m::get_log_features()$/;"	f	class:ss_m
get_log_me_node	smthread.h	/^    queue_based_block_lock_t::ext_qnode& get_log_me_node() { $/;"	f	class:smthread_t
get_log_space_used	xct.cpp	/^xct_t::get_log_space_used() const$/;"	f	class:xct_t
get_logbuf	plog_xct.cpp	/^rc_t plog_xct_t::get_logbuf(logrec_t*& lr, int \/* type *\/)$/;"	f	class:plog_xct_t
get_logbuf	xct.cpp	/^xct_t::get_logbuf(logrec_t*& ret, int t)$/;"	f	class:xct_t
get_lsn_ck	logrec.h	/^    const lsn_t          get_lsn_ck() const {$/;"	f	class:logrec_t
get_me1	smthread.h	/^    queue_based_lock_t::ext_qnode& get_me1() { return tcb()._me1; }$/;"	f	class:smthread_t
get_me2	smthread.h	/^    queue_based_lock_t::ext_qnode& get_me2() { return tcb()._me2; }$/;"	f	class:smthread_t
get_me3	smthread.h	/^    queue_based_lock_t::ext_qnode& get_me3() { return tcb()._me3; }$/;"	f	class:smthread_t
get_min_unused_store_ID	stnode_page.cpp	/^snum_t stnode_cache_t::get_min_unused_store_ID() const {$/;"	f	class:stnode_cache_t
get_next_vid	vol.h	/^    vid_t get_next_vid() {$/;"	f	class:vol_m
get_observed_release_version	lock_bucket.h	/^    uint32_t get_observed_release_version() const { return _observed_release_version; }$/;"	f	class:lock_queue_entry_t
get_oldest_active_lsn	log_lsn_tracker.cpp	/^lsn_t PoorMansOldestLsnTracker::get_oldest_active_lsn(lsn_t curr_lsn) {$/;"	f	class:PoorMansOldestLsnTracker
get_oldest_active_lsn_cache	log_lsn_tracker.h	/^    lsn_t               get_oldest_active_lsn_cache() const { return _cache; }$/;"	f	class:PoorMansOldestLsnTracker
get_oldest_lsn_tracker	log_core.h	/^    PoorMansOldestLsnTracker* get_oldest_lsn_tracker()$/;"	f	class:log_common
get_oldest_lsn_tracker	log_resv.h	/^    PoorMansOldestLsnTracker* get_oldest_lsn_tracker() { return _oldest_lsn_tracker; }$/;"	f	class:log_resv
get_option_with_default	sm_options.h	/^const V& get_option_with_default ($/;"	f
get_options	sm.h	/^    static const sm_options& get_options() { return _options; }$/;"	f	class:ss_m
get_or_create_context	btree_impl_verify.cpp	/^verify_volume_result::get_or_create_context ($/;"	f	class:verify_volume_result
get_page	bf_tree.cpp	/^generic_page* bf_tree_m::get_page(const bf_idx& idx) {$/;"	f	class:bf_tree_m
get_page	bf_tree.cpp	/^generic_page* bf_tree_m::get_page(const bf_tree_cb_t *cb) {$/;"	f	class:bf_tree_m
get_page_cnt	bf_fixed.h	/^inline uint32_t bf_fixed_m::get_page_cnt() const {$/;"	f	class:bf_fixed_m
get_pages	bf_fixed.h	/^inline generic_page* bf_fixed_m::get_pages () {$/;"	f	class:bf_fixed_m
get_partition	log_storage.cpp	/^partition_t * log_storage::get_partition(partition_number_t n) const$/;"	f	class:log_storage
get_partition_for_flush	log_storage.cpp	/^log_storage::get_partition_for_flush(lsn_t start_lsn,$/;"	f	class:log_storage
get_pid0_emlsn	btree_page_h.h	/^inline const lsn_t& btree_page_h::get_pid0_emlsn() const {$/;"	f	class:btree_page_h
get_pid_highwatermark	alloc_page.h	/^    shpid_t get_pid_highwatermark() const { return page()->pid_highwatermark; }$/;"	f	class:alloc_page_h
get_pid_offset	alloc_page.h	/^    shpid_t get_pid_offset() const { return page()->pid_offset; }$/;"	f	class:alloc_page_h
get_prefix_key	btree_page_h.h	/^inline const char* btree_page_h::get_prefix_key() const {$/;"	f	class:btree_page_h
get_prefix_length	btree_page_h.h	/^inline int16_t btree_page_h::get_prefix_length() const {$/;"	f	class:btree_page_h
get_private_hashmap	lock_x.h	/^    XctLockHashMap&     get_private_hashmap() { return _hashmap; }$/;"	f	class:xct_lock_info_t
get_query_concurrency	xct.h	/^    concurrency_t                get_query_concurrency() const { return _query_concurrency; }$/;"	f	class:xct_t
get_query_exlock_for_select	xct.h	/^    bool                         get_query_exlock_for_select() const {return _query_exlock_for_select;}$/;"	f	class:xct_t
get_read_watermark	xct.h	/^    const lsn_t&                get_read_watermark() const { return _read_watermark; }$/;"	f	class:xct_t
get_rec_lsn	bf_tree.cpp	/^void bf_tree_m::get_rec_lsn(bf_idx &start, uint32_t &count, lpid_t *pid, snum_t* stores,$/;"	f	class:bf_tree_m
get_rec_space	btree_page_h.h	/^inline size_t btree_page_h::get_rec_space(int slot) const {$/;"	f	class:btree_page_h
get_requested_mode	lock_bucket.h	/^    const okvl_mode& get_requested_mode() const { return _requested_mode; }$/;"	f	class:lock_queue_entry_t
get_right_neighbor	mem_mgmt.h	/^        list_header_t* get_right_neighbor() {$/;"	f	class:fixed_lists_mem_t::list_header_t
get_root_page_id	bf_tree.cpp	/^shpid_t bf_tree_m::get_root_page_id(stid_t store) {$/;"	f	class:bf_tree_m
get_root_page_idx	bf_tree.cpp	/^bf_idx bf_tree_m::get_root_page_idx(stid_t store) {$/;"	f	class:bf_tree_m
get_root_pid	stnode_page.cpp	/^shpid_t stnode_cache_t::get_root_pid(snum_t store) const {$/;"	f	class:stnode_cache_t
get_size	backup.h	/^inline size_t AlignedMemory::get_size() const { return _size; }$/;"	f	class:AlignedMemory
get_size	bf_tree.h	/^    size_t get_size() { return _block_cnt; }$/;"	f	class:bf_tree_m
get_skip_log	log_storage.h	/^    skip_log*       get_skip_log()  { return _skip_log; }$/;"	f	class:log_storage
get_stnode	stnode_page.cpp	/^void stnode_cache_t::get_stnode(snum_t store, stnode_t &stnode) const {$/;"	f	class:stnode_cache_t
get_stnode_cache	vol.h	/^    stnode_cache_t*          get_stnode_cache() {return _stnode_cache;}$/;"	f	class:vol_t
get_store_flags	vol.cpp	/^rc_t vol_t::get_store_flags(snum_t snum, smlevel_0::store_flag_t& flags,$/;"	f	class:vol_t
get_store_info	sm.cpp	/^ss_m::get_store_info($/;"	f	class:ss_m
get_store_property	smfile.cpp	/^ss_m::get_store_property(stid_t stid, store_property_t& property)$/;"	f	class:ss_m
get_store_root	vol.cpp	/^shpid_t vol_t::get_store_root(snum_t f) const$/;"	f	class:vol_t
get_string_option	sm_options.h	/^inline const std::string& sm_options::get_string_option(const std::string& option_name, const std::string& default_value) const {$/;"	f	class:sm_options
get_tcb_depth	smthread.h	/^    inline size_t get_tcb_depth() const {$/;"	f	class:smthread_t
get_total_free_page_count	alloc_cache.cpp	/^size_t alloc_cache_t::get_total_free_page_count () const$/;"	f	class:alloc_cache_t
get_type_str	logrec.cpp	/^logrec_t::get_type_str(kind_t type)$/;"	f	class:logrec_t
get_vid	backup.h	/^inline vid_t BackupFile::get_vid() const { return _vid; }$/;"	f	class:BackupFile
get_wait_map	lock_x.h	/^    atomic_thread_map_t const &get_wait_map() const { return _wait_map; }$/;"	f	class:xct_lock_info_t
get_workload_priority	smthread.h	/^    int get_workload_priority() { return _replacement_priority; }$/;"	f	class:smthread_t
get_xct_chain_len	xct.h	/^    uint32_t                    get_xct_chain_len() const { return _xct_chain_len;}$/;"	f	class:xct_t
get_xlist_mutex_node	smthread.h	/^    queue_based_lock_t::ext_qnode& get_xlist_mutex_node() { $/;"	f	class:smthread_t
getdebuginfo	crash.cpp	/^getdebuginfo( $/;"	f
give	plog.cpp	/^void plog_t::give(logrec_t* lr)$/;"	f	class:plog_t
give_logbuf	plog_xct.cpp	/^rc_t plog_xct_t::give_logbuf(logrec_t* lr, const fixable_page_h* p,$/;"	f	class:plog_xct_t
give_logbuf	xct.cpp	/^xct_t::give_logbuf(logrec_t* l, const fixable_page_h *page, const fixable_page_h *page2)$/;"	f	class:xct_t
give_permission_to_violate	lock.cpp	/^void lock_m::give_permission_to_violate(lsn_t commit_lsn) {$/;"	f	class:lock_m
give_stats	xct.h	/^    void                        give_stats(sm_stats_info_t* s) {$/;"	f	class:xct_t
global_min_lsn	log.h	/^    lsn_t               global_min_lsn() const {$/;"	f	class:log_m
global_min_lsn	log.h	/^    lsn_t               global_min_lsn(lsn_t const &a) const {$/;"	f	class:log_m
global_min_lsn	log.h	/^    lsn_t               global_min_lsn(lsn_t const &a, lsn_t const &b) const {$/;"	f	class:log_m
global_min_lsn	log_storage.h	/^    lsn_t               global_min_lsn() const$/;"	f	class:log_storage
grab_delegated_expose	log_carray.cpp	/^CArraySlot* ConsolidationArray::grab_delegated_expose(CArraySlot* info) {$/;"	f	class:ConsolidationArray
group_commit	xct.cpp	/^xct_t::group_commit(const xct_t *list[], int listlen)$/;"	f	class:xct_t
gt	logarchiver.cpp	/^bool LogArchiver::ArchiverHeap::Cmp::gt(const HeapEntry& a,$/;"	f	class:LogArchiver::ArchiverHeap::Cmp
gt	logarchiver.h	/^            bool gt(const MergeHeapEntry& a, const MergeHeapEntry& b) const$/;"	f	struct:LogArchiver::ArchiveScanner::MergeHeapCmp
gt	restart.h	/^CmpMountLsns::gt(const comp_mount_log_t* x, const comp_mount_log_t* y) const$/;"	f	class:CmpMountLsns
gt	restart.h	/^CmpXctLockTids::gt(const comp_lock_info_t* x, const comp_lock_info_t* y) const$/;"	f	class:CmpXctLockTids
gt	restart.h	/^CmpXctUndoLsns::gt(const xct_t* x, const xct_t* y) const$/;"	f	class:CmpXctUndoLsns
gt	sm_base.h	/^                 gt=gtOp, ge=geOp, lt=ltOp, le=leOp };$/;"	e	enum:smlevel_0::cmp_t
handle_pool	lock_raw.cpp	/^void handle_pool(bool &more_work,$/;"	f
hasPartialLogrec	logarchiver.cpp	/^bool LogScanner::hasPartialLogrec()$/;"	f	class:LogScanner
hasPendingBlocks	logarchiver.cpp	/^bool LogArchiver::BlockAssembly::hasPendingBlocks()$/;"	f	class:LogArchiver::BlockAssembly
hasWaitingRequest	restore.cpp	/^bool RestoreScheduler::hasWaitingRequest()$/;"	f	class:RestoreScheduler
has_any_lock	lock_lil.cpp	/^inline bool has_any_lock(const bool *lock_taken, bool read_lock_only = false) {$/;"	f
has_children	fixable_page_h.cpp	/^bool fixable_page_h::has_children() const {$/;"	f	class:fixable_page_h
has_locks	lock_raw.h	/^    bool                        has_locks() const { return private_first != NULL; }$/;"	f	struct:RawXct
has_swizzled_child	bf_tree.cpp	/^bool bf_tree_m::has_swizzled_child(bf_idx node_idx) {$/;"	f	class:bf_tree_m
hash	lock_bucket.h	/^    inline uint32_t hash()       const { return _hash;}$/;"	f	class:lock_queue_t
hash	lock_raw.h	/^    uint32_t                    hash;$/;"	m	struct:RawLock
hash	lock_s.h	/^inline uint32_t lockid_t::hash() const$/;"	f	class:lockid_t
hdr_bs	sm_du_stats.h	/^    base_stat_t        hdr_bs;            \/* page header (overhead) *\/$/;"	m	struct:btree_lf_stats_t
hdr_ext_cnt	sm_du_stats.h	/^    base_stat_t        hdr_ext_cnt;        \/* header & extent maps *\/$/;"	m	struct:volume_hdr_stats_t
hdr_non_ssx_sz	logrec.h	/^        hdr_non_ssx_sz = sizeof(baseLogHeader) + sizeof(xidChainLogHeader),$/;"	e	enum:logrec_t::__anon18
hdr_single_sys_xct_sz	logrec.h	/^        hdr_single_sys_xct_sz = sizeof(baseLogHeader),$/;"	e	enum:logrec_t::__anon18
hdr_sz	btree_page.h	/^        hdr_sz  = sizeof(generic_page_header) + 48,$/;"	e	enum:btree_page_data::__anon4
hdr_sz	btree_page_h.h	/^        hdr_sz  = btree_page::hdr_sz,$/;"	e	enum:btree_page_h::__anon12
head	btree_page.h	/^        item_head head[max_heads];$/;"	m	union:btree_page_data::__anon11
head	lock_raw.h	/^    mutable RawLock             head;$/;"	m	struct:RawLockQueue
header	logrec.h	/^    baseLogHeader header;$/;"	m	class:logrec_t
header	mem_mgmt.h	/^        uint16_t header() {$/;"	f	class:fixed_lists_mem_t::list_header_t
header_size	logrec.h	/^inline smsize_t logrec_t::header_size() const$/;"	f	class:logrec_t
heap	logarchiver.h	/^            Heap<MergeHeapEntry, MergeHeapCmp> heap;$/;"	m	struct:LogArchiver::ArchiveScanner::RunMerger
heap	logarchiver.h	/^    ArchiverHeap* heap;$/;"	m	class:LogArchiver
heapCmp	logarchiver.h	/^        Cmp heapCmp;$/;"	m	class:LogArchiver::ArchiverHeap
heapSize	logarchiver.h	/^            size_t heapSize() { return heap.NumElements(); }$/;"	f	struct:LogArchiver::ArchiveScanner::RunMerger
hit_count	lock_bucket.h	/^    inline uint32_t hit_count () const { return _hit_counts;}$/;"	f	class:lock_queue_t
hits	logbuf_core.h	/^    uint64_t hits;$/;"	m	class:logbuf_core
i	btree_page_h.h	/^        shpid_t i;$/;"	m	union:btree_page_h::record_info_shpid_convert
idx	bf_tree.h	/^    bf_idx idx() const { return _idx;}$/;"	f	class:pin_for_refix_holder
ignore	logarchiver.h	/^    bitset<logrec_t::t_max_logrec> ignore;$/;"	m	class:LogScanner
ignoreAll	logarchiver.h	/^    void ignoreAll() {$/;"	f	class:LogScanner
in_REDO	sm.cpp	/^restart_phase_t ss_m::in_REDO()$/;"	f	class:ss_m
in_UNDO	sm.cpp	/^restart_phase_t ss_m::in_UNDO()$/;"	f	class:ss_m
in_doubt_count	sm.cpp	/^uint32_t     smlevel_0::in_doubt_count = 0;$/;"	m	class:smlevel_0	file:
in_doubt_count	sm_base.h	/^    static uint32_t     in_doubt_count;  \/\/ in_doubt_count is used to child thread during the REDO phase$/;"	m	class:smlevel_0
in_doubt_to_dirty	bf_tree.cpp	/^void bf_tree_m::in_doubt_to_dirty(const bf_idx idx) {$/;"	f	class:bf_tree_m
in_log_analysis	sm.cpp	/^restart_phase_t ss_m::in_log_analysis()$/;"	f	class:ss_m
in_recovery	sm_base.h	/^    static bool in_recovery() {$/;"	f	class:smlevel_0
in_recovery_analysis	sm_base.h	/^    static bool in_recovery_analysis() {$/;"	f	class:smlevel_0
in_recovery_redo	sm_base.h	/^    static bool in_recovery_redo() {$/;"	f	class:smlevel_0
in_recovery_undo	sm_base.h	/^    static bool in_recovery_undo() {$/;"	f	class:smlevel_0
in_restart	restart.h	/^    smlevel_0::concurrent_restart_mode_t in_restart() { return working; }$/;"	f	class:restart_thread_t
in_restart	sm.cpp	/^bool ss_m::in_restart()$/;"	f	class:ss_m
in_sm	smthread.h	/^    void             in_sm(bool in)    { tcb()._in_sm = in; }$/;"	f	class:smthread_t
in_xct	prologue.h	/^        in_xct,          \/\/ must be active and not prepared$/;"	e	enum:prologue_rc_t::xct_state_t
incr_pin_count	smthread.h	/^smthread_t::incr_pin_count(int amount) $/;"	f	class:smthread_t
increase_ex_need	btree_impl.h	/^    inline static void increase_ex_need (shpid_t real_parent_pid) {$/;"	f	class:btree_impl
increase_forster_child	btree_impl.h	/^    inline static void increase_forster_child (shpid_t new_foster_parent_pid) {$/;"	f	class:btree_impl
increase_hit_count	lock_bucket.h	/^    inline void increase_hit_count () {++_hit_counts;}$/;"	f	class:lock_queue_t
increment	ringbuffer.h	/^    void increment(int& p, bool& parity) { $/;"	f	class:AsyncRingBuffer
index	partition.h	/^    partition_index_t  index() const {  return _index; }$/;"	f	class:partition_t
indir	logarchiver.h	/^        ArchiveDirectory* indir;$/;"	m	class:LogArchiver::MergerDaemon
init	bf_fixed.cpp	/^w_rc_t bf_fixed_m::init()$/;"	f	class:bf_fixed_m
init	bf_tree.cpp	/^w_rc_t bf_tree_m::init ()$/;"	f	class:bf_tree_m
init	lock_bucket.h	/^        void init (const atomic_thread_map_t &fingerprint) {$/;"	f	struct:lock_queue_t::check_grant_result
init	lock_raw.cpp	/^void RawXct::init(gc_thread_id thread_id_arg,$/;"	f	class:RawXct
init	logarchiver.cpp	/^void LogArchiver::ArchiveIndex::init()$/;"	f	class:LogArchiver::ArchiveIndex
init	mem_mgmt.h	/^        void init(size_t block_size) {$/;"	f	class:fixed_lists_mem_t::list_header_t
init	partition.cpp	/^partition_t::init(log_storage *owner)$/;"	f	class:partition_t
init	stnode_page.cpp	/^void stnode_cache_t::init()$/;"	f	class:stnode_cache_t
initLogScanner	logarchiver.cpp	/^void LogArchiver::initLogScanner(LogScanner* logScanner)$/;"	f	class:LogArchiver
init_fence_keys	btree_page_h.cpp	/^rc_t btree_page_h::init_fence_keys($/;"	f	class:btree_page_h
init_fingerprint_map	smthread.cpp	/^void smthread_t::init_fingerprint_map() $/;"	f	class:smthread_t
init_index	partition.h	/^    void               init_index(partition_index_t i) { _index=i; }$/;"	f	class:partition_t
init_items	btree_page.cpp	/^void btree_page_data::init_items() {$/;"	f	class:btree_page_data
init_locked	xct.h	/^    static bool init_locked(bool lockit)$/;"	f	class:xct_i
init_metadata	vol.cpp	/^rc_t vol_t::init_metadata()$/;"	f	class:vol_t
init_wait_map	lock_x.h	/^    void              init_wait_map(smthread_t *thr) {$/;"	f	class:xct_lock_info_t
initialized	crash.cpp	/^        bool          initialized;$/;"	m	struct:debuginfo	file:
inquery_verify_context	xct.h	/^    const inquery_verify_context_t& inquery_verify_context() const { return _inquery_verify_context;}$/;"	f	class:xct_t
inquery_verify_context	xct.h	/^    inquery_verify_context_t& inquery_verify_context() { return _inquery_verify_context;}$/;"	f	class:xct_t
inquery_verify_context_t	xct.h	/^    inquery_verify_context_t() : pages_checked(0), next_pid(0), next_level(0) {$/;"	f	class:inquery_verify_context_t
inquery_verify_context_t	xct.h	/^class inquery_verify_context_t {$/;"	c
inquery_verify_expect	btree_impl_verify.cpp	/^void btree_impl::inquery_verify_expect(btree_page_h &page, slot_follow_t next_follow)$/;"	f	class:btree_impl
inquery_verify_fact	btree_impl_verify.cpp	/^void btree_impl::inquery_verify_fact(btree_page_h &page)$/;"	f	class:btree_impl
inquery_verify_init	btree_impl_verify.cpp	/^void btree_impl::inquery_verify_init(stid_t store)$/;"	f	class:btree_impl
insert	btree.cpp	/^rc_t btree_m::insert(stid_t store, const w_keystr_t &key, const cvec_t &el) {$/;"	f	class:btree_m
insert	log_core.cpp	/^rc_t log_core::insert(logrec_t &rec, lsn_t* rlsn)$/;"	f	class:log_core
insert	logbuf_core.cpp	/^rc_t logbuf_core::insert($/;"	f	class:logbuf_core
insert_if_not_exists	bf_hashtable.cpp	/^bool bf_hashtable<T>::insert_if_not_exists(uint64_t key, T value) {$/;"	f	class:bf_hashtable
insert_if_not_exists	logbuf_hashtable.cpp	/^bool logbuf_hashtable::insert_if_not_exists(uint64_t key, logbuf_seg *value) {$/;"	f	class:logbuf_hashtable
insert_item	btree_page.cpp	/^bool btree_page_data::insert_item(int item, bool ghost, poor_man_key poor,$/;"	f	class:btree_page_data
insert_node	btree_page_h.cpp	/^rc_t btree_page_h::insert_node(const w_keystr_t &key, slotid_t slot, shpid_t child,$/;"	f	class:btree_page_h
insert_nonghost	btree_page_h.cpp	/^void btree_page_h::insert_nonghost(const w_keystr_t &key, const cvec_t &elem) {$/;"	f	class:btree_page_h
insert_records_dest_redo	btree_page_h.cpp	/^rc_t btree_page_h::insert_records_dest_redo($/;"	f	class:btree_page_h
insertions_bwd	logrec.cpp	/^    static __thread uint64_t insertions_bwd [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
insertions_bwd	logrec.cpp	/^__thread uint64_t logrec_accounting_impl_t::insertions_bwd [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
insertions_bwd_cxt	logrec.cpp	/^    static __thread uint64_t insertions_bwd_cxt [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
insertions_bwd_cxt	logrec.cpp	/^__thread uint64_t logrec_accounting_impl_t::insertions_bwd_cxt [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
insertions_fwd	logrec.cpp	/^    static __thread uint64_t insertions_fwd [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
insertions_fwd	logrec.cpp	/^__thread uint64_t logrec_accounting_impl_t::insertions_fwd [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
install_volume	bf_tree.cpp	/^w_rc_t bf_tree_m::install_volume(vol_t* volume) {$/;"	f	class:bf_tree_m
instantRestore	restore.h	/^    bool instantRestore;$/;"	m	class:RestoreMgr
int_pg	sm_du_stats.h	/^    btree_int_stats_t    int_pg;   \/\/ byte counts for interior pages$/;"	m	struct:btree_stats_t
int_pg_cnt	sm_du_stats.h	/^    base_stat_t     int_pg_cnt;  \/\/ level>1 pages found by tree traversal$/;"	m	struct:btree_stats_t
int_stats	btree_page_h.cpp	/^btree_page_h::int_stats(btree_int_stats_t& _stats) {$/;"	f	class:btree_page_h
intent_store_lock	lock.cpp	/^rc_t lock_m::intent_store_lock(const stid_t &stid, okvl_mode::element_lock_mode m)$/;"	f	class:lock_m
intent_vol_lock	lock.cpp	/^rc_t lock_m::intent_vol_lock(vid_t vid, okvl_mode::element_lock_mode m)$/;"	f	class:lock_m
intent_vol_store_lock	lock.cpp	/^rc_t lock_m::intent_vol_store_lock(const stid_t &stid, okvl_mode::element_lock_mode m)$/;"	f	class:lock_m
interior	btree_page.h	/^            } interior;$/;"	m	union:btree_page_data::__anon6::__anon7	typeref:struct:btree_page_data::__anon6::__anon7::__anon9
interior_overhead	btree_page.h	/^        interior_overhead = sizeof(item_length_t) + sizeof(shpid_t),$/;"	e	enum:btree_page_data::__anon10
interval_usec	sm.cpp	/^    int interval_usec;$/;"	m	class:ticker_thread_t	file:
invalid_fhdl	log_core.h	/^    enum { invalid_fhdl = -1 };$/;"	e	enum:log_common::__anon17
invalid_fhdl	partition.h	/^    enum { invalid_fhdl = -1 };$/;"	e	enum:partition_t::__anon32
ios_fmtflags	logrec.cpp	/^typedef        ios::fmtflags        ios_fmtflags;$/;"	t	file:
isActive	logarchiver.h	/^        bool isActive() { return control.activated; }$/;"	f	class:LogArchiver::ReaderThread
isEmpty	ringbuffer.h	/^    bool isEmpty() { return begin == end && bparity == eparity; }$/;"	f	class:AsyncRingBuffer
isFinished	ringbuffer.h	/^inline bool AsyncRingBuffer::isFinished()$/;"	f	class:AsyncRingBuffer
isFull	ringbuffer.h	/^    bool isFull() { return begin == end && bparity != eparity; }$/;"	f	class:AsyncRingBuffer
isIgnored	logarchiver.h	/^    bool isIgnored(logrec_t::kind_t type) {$/;"	f	class:LogScanner
isLogTooSlow	logarchiver.cpp	/^bool LogArchiver::isLogTooSlow()$/;"	f	class:LogArchiver
isOnDemand	restore.h	/^    bool isOnDemand() { return onDemand; }$/;"	f	class:RestoreScheduler
isRestored	restore.h	/^inline bool RestoreMgr::isRestored(const shpid_t& pid)$/;"	f	class:RestoreMgr
isSinglePass	restore.h	/^    bool isSinglePass() { return trySinglePass; }$/;"	f	class:RestoreScheduler
is_1thread_log_mutex_mine	xct.h	/^    bool                         is_1thread_log_mutex_mine() const {$/;"	f	class:xct_t
is_1thread_xct_mutex_mine	xct.cpp	/^xct_t::is_1thread_xct_mutex_mine() const$/;"	f	class:xct_t
is_alloc_store	vol.cpp	/^bool vol_t::is_alloc_store(snum_t f) const$/;"	f	class:vol_t
is_allocated	stnode_page.cpp	/^bool stnode_cache_t::is_allocated(snum_t store) const {$/;"	f	class:stnode_cache_t
is_allocated	stnode_page.h	/^    bool is_allocated() const  { return flags != smlevel_0::st_unallocated; }$/;"	f	struct:stnode_t
is_allocated_page	alloc_cache.cpp	/^bool alloc_cache_t::is_allocated_page (shpid_t pid) const {$/;"	f	class:alloc_cache_t
is_allocated_page	vol.cpp	/^bool vol_t::is_allocated_page(shpid_t pid) const$/;"	f	class:vol_t
is_bf_page	bf_tree.h	/^    inline bool  is_bf_page (const generic_page *page) const {$/;"	f	class:bf_tree_m
is_bit_set	alloc_page.h	/^inline bool alloc_page_h::is_bit_set(shpid_t pid) const {$/;"	f	class:alloc_page_h
is_bitmap_clean	btree_impl_verify.cpp	/^bool verification_context::is_bitmap_clean () const$/;"	f	class:verification_context
is_bufferpool_managed	fixable_page_h.h	/^    bool is_bufferpool_managed() const { return _bufferpool_managed; }$/;"	f	class:fixable_page_h
is_clear	pmap.h	/^    inline    bool    is_clear(int bit) const { return bm_is_clr(bits, bit);}$/;"	f	struct:Pmap
is_consistent	btree_page_h.cpp	/^bool btree_page_h::is_consistent (bool check_keyorder, bool check_space) const {$/;"	f	class:btree_page_h
is_cpsn	logrec.h	/^logrec_t::is_cpsn() const$/;"	f	class:logrec_t
is_current	partition.cpp	/^partition_t::is_current()  const$/;"	f	class:partition_t
is_deadlocked	lock_raw.cpp	/^bool RawXct::is_deadlocked(RawXct* first_blocker) {$/;"	f	class:RawXct
is_dirty	bf_tree.cpp	/^bool bf_tree_m::is_dirty(const bf_idx idx) const {$/;"	f	class:bf_tree_m
is_dirty	bf_tree.cpp	/^bool bf_tree_m::is_dirty(const generic_page* p) const {$/;"	f	class:bf_tree_m
is_dirty	fixable_page_h.cpp	/^bool fixable_page_h::is_dirty() const {$/;"	f	class:fixable_page_h
is_empty	btree.cpp	/^btree_m::is_empty($/;"	f	class:btree_m
is_empty	pmap.h	/^    inline    bool    is_empty() const {$/;"	f	struct:Pmap
is_ex_recommended	btree_impl.h	/^    inline static bool is_ex_recommended (shpid_t pid) {$/;"	f	class:btree_impl
is_failed	vol.h	/^    bool is_failed() const$/;"	f	class:vol_t
is_fence_high_supremum	btree_page_h.h	/^    bool              is_fence_high_supremum() const { return get_prefix_length() == 0 && get_fence_high_key_noprefix()[0] == SIGN_POSINF;}$/;"	f	class:btree_page_h
is_fence_low_infimum	btree_page_h.h	/^    bool              is_fence_low_infimum() const { return get_fence_low_key()[0] == SIGN_NEGINF;}$/;"	f	class:btree_page_h
is_fixed	fixable_page_h.h	/^    bool is_fixed() const { return _pp != 0; }$/;"	f	class:fixable_page_h
is_forward	btcursor.h	/^    bool          is_forward() const { return _forward; }$/;"	f	class:bt_cursor_t
is_free	mem_mgmt.h	/^        bool is_free() {$/;"	f	class:fixed_lists_mem_t::list_header_t
is_ghost	btree_page.h	/^inline bool btree_page_data::is_ghost(int item) const {$/;"	f	class:btree_page_data
is_ghost	btree_page_h.h	/^inline bool btree_page_h::is_ghost(slotid_t slot) const {$/;"	f	class:btree_page_h
is_ghost_record	btree_page_h.h	/^    bool               is_ghost_record() const { return _ghost_record; }$/;"	f	class:btrec_t
is_in_doubt	bf_tree.cpp	/^bool bf_tree_m::is_in_doubt(const bf_idx idx) const {$/;"	f	class:bf_tree_m
is_in_sm	smthread.h	/^    bool             is_in_sm() const { return tcb()._in_sm; }$/;"	f	class:smthread_t
is_inquery_verify	xct.h	/^    bool                        is_inquery_verify() const { return _inquery_verify; }$/;"	f	class:xct_t
is_inquery_verify_keyorder	xct.h	/^    bool                        is_inquery_verify_keyorder() const { return _inquery_verify_keyorder; }$/;"	f	class:xct_t
is_inquery_verify_space	xct.h	/^    bool                        is_inquery_verify_space() const { return _inquery_verify_space; }$/;"	f	class:xct_t
is_insertion_extremely_skewed_right	btree_page_h.h	/^inline bool btree_page_h::is_insertion_extremely_skewed_right() const {$/;"	f	class:btree_page_h
is_insertion_skewed_left	btree_page_h.h	/^inline bool btree_page_h::is_insertion_skewed_left() const {$/;"	f	class:btree_page_h
is_insertion_skewed_right	btree_page_h.h	/^inline bool btree_page_h::is_insertion_skewed_right() const {$/;"	f	class:btree_page_h
is_instrumented	xct.h	/^    bool                        is_instrumented() {$/;"	f	class:xct_t
is_latched	fixable_page_h.h	/^    bool         is_latched() const { return _mode == LATCH_SH || _mode == LATCH_EX; }$/;"	f	class:fixable_page_h
is_leaf	btree_page.h	/^    bool is_leaf() const { return btree_level == 1; }$/;"	f	class:btree_page_data
is_leaf	btree_page_h.h	/^inline bool btree_page_h::is_leaf() const {$/;"	f	class:btree_page_h
is_leaf_parent	btree_page_h.h	/^inline bool btree_page_h::is_leaf_parent() const {$/;"	f	class:btree_page_h
is_list_empty	mem_mgmt.cpp	/^bool inline fixed_lists_mem_t::is_list_empty(size_t block_size)$/;"	f	class:fixed_lists_mem_t
is_log_on	xct.h	/^bool xct_t::is_log_on() const {$/;"	f	class:xct_t
is_logical	logrec.h	/^logrec_t::is_logical() const$/;"	f	class:logrec_t
is_loser_xct	xct.h	/^    bool                        is_loser_xct() const$/;"	f	class:xct_t
is_loser_xct_in_undo	xct.h	/^    bool                        is_loser_xct_in_undo() const$/;"	f	class:xct_t
is_mounted	vol.h	/^    bool is_mounted(vid_t vid) { return get(vid) != NULL; }$/;"	f	class:vol_m
is_multi_page	logrec.h	/^inline bool logrec_t::is_multi_page() const {$/;"	f	class:logrec_t
is_node	btree_page_h.h	/^inline bool btree_page_h::is_node() const {$/;"	f	class:btree_page_h
is_null	lock_raw.h	/^        bool is_null() const { return current.is_null(); }$/;"	f	struct:RawLockQueue::Iterator
is_null	sm_s.h	/^    bool        is_null() const { return page == 0 && _vol == 0; }$/;"	f	class:lpid_t
is_open_for_append	partition.h	/^    bool               is_open_for_append() const {$/;"	f	class:partition_t
is_open_for_read	partition.h	/^    bool               is_open_for_read() const {$/;"	f	class:partition_t
is_opened	backup.h	/^inline bool BackupFile::is_opened() const { return _fd != -1; }$/;"	f	class:BackupFile
is_page_update	logrec.h	/^logrec_t::is_page_update() const$/;"	f	class:logrec_t
is_piggy_backed_single_log_sys_xct	xct.h	/^    bool                        is_piggy_backed_single_log_sys_xct() const { return _piggy_backed_single_log_sys_xct;}$/;"	f	class:xct_t
is_private_list_consistent	lock_raw.cpp	/^bool is_private_list_consistent(RawXct *xct) {$/;"	f
is_recovery_access	bf_tree.cpp	/^bool bf_tree_m::is_recovery_access(const generic_page* p) const {$/;"	f	class:bf_tree_m
is_recovery_access	fixable_page_h.cpp	/^bool fixable_page_h::is_recovery_access() const$/;"	f	class:fixable_page_h
is_redo	logrec.h	/^logrec_t::is_redo() const$/;"	f	class:logrec_t
is_retired	chkpt.cpp	/^    bool                is_retired() {return _retire;}$/;"	f	class:chkpt_thread_t
is_rollback	logrec.h	/^logrec_t::is_rollback() const$/;"	f	class:logrec_t
is_set	pmap.h	/^    inline    bool    is_set(int bit) const { return bm_is_set(bits, bit); }$/;"	f	struct:Pmap
is_single_log_sys_xct	xct.h	/^    bool                        is_single_log_sys_xct() const{ return _single_log_sys_xct || _piggy_backed_single_log_sys_xct;}$/;"	f	class:xct_t
is_single_sys_xct	logrec.h	/^logrec_t::is_single_sys_xct() const$/;"	f	class:logrec_t
is_skip	logrec.h	/^logrec_t::is_skip() const$/;"	f	class:logrec_t
is_swizzled	bf_tree.cpp	/^bool bf_tree_m::is_swizzled(const generic_page* page) const$/;"	f	class:bf_tree_m
is_swizzled_pointer	bf_tree.h	/^inline bool is_swizzled_pointer (shpid_t shpid) {$/;"	f
is_swizzling_enabled	bf_tree.h	/^    inline bool is_swizzling_enabled() const {return _enable_swizzling;}$/;"	f	class:bf_tree_m
is_sys_xct	xct.h	/^    bool                        is_sys_xct () const { return _sys_xct || _piggy_backed_single_log_sys_xct; }$/;"	f	class:xct_t
is_to_be_deleted	fixable_page_h.cpp	/^bool fixable_page_h::is_to_be_deleted() {$/;"	f	class:fixable_page_h
is_undo	logrec.h	/^logrec_t::is_undo() const$/;"	f	class:logrec_t
is_undoable_clr	logrec.h	/^logrec_t::is_undoable_clr() const$/;"	f	class:logrec_t
is_update_thread	smthread.h	/^    bool             is_update_thread() const { $/;"	f	class:smthread_t
is_used	bf_tree.cpp	/^bool bf_tree_m::is_used (bf_idx idx) const {$/;"	f	class:bf_tree_m
is_valid	btcursor.h	/^    bool          is_valid() const { return _first_time || !_eof; }$/;"	f	class:bt_cursor_t
is_valid_store	vol.h	/^inline bool vol_t::is_valid_store(snum_t f) const$/;"	f	class:vol_t
item_body	btree_page.h	/^    } item_body;$/;"	t	class:btree_page_data	typeref:struct:btree_page_data::__anon6
item_child	btree_page.h	/^inline shpid_t& btree_page_data::item_child(int item) {$/;"	f	class:btree_page_data
item_data	btree_page.h	/^                char          item_data[2];$/;"	m	struct:btree_page_data::__anon6::__anon7::__anon9
item_data	btree_page.h	/^                char          item_data[6];$/;"	m	struct:btree_page_data::__anon6::__anon7::__anon8
item_data	btree_page.h	/^inline char* btree_page_data::item_data(int item) {$/;"	f	class:btree_page_data
item_head	btree_page.h	/^    } item_head;$/;"	t	class:btree_page_data	typeref:struct:btree_page_data::__anon5
item_index_t	btree_page.h	/^    typedef uint16_t item_index_t;$/;"	t	class:btree_page_data
item_len	btree_page.h	/^                item_length_t item_len;$/;"	m	struct:btree_page_data::__anon6::__anon7::__anon8
item_len	btree_page.h	/^                item_length_t item_len;$/;"	m	struct:btree_page_data::__anon6::__anon7::__anon9
item_length	btree_page.h	/^inline size_t btree_page_data::item_length(int item) const {$/;"	f	class:btree_page_data
item_length_t	btree_page.h	/^    typedef uint16_t item_length_t;$/;"	t	class:btree_page_data
item_poor	btree_page.h	/^inline btree_page_data::poor_man_key btree_page_data::item_poor(int item) const {$/;"	f	class:btree_page_data
item_poor	btree_page.h	/^inline btree_page_data::poor_man_key& btree_page_data::item_poor(int item) {$/;"	f	class:btree_page_data
item_space	btree_page.h	/^inline size_t btree_page_data::item_space(int item) const {$/;"	f	class:btree_page_data
iter_t	plog.h	/^        iter_t(plog_t* plog, bool forward) :$/;"	f	class:plog_t::iter_t
iter_t	plog.h	/^    class iter_t {$/;"	c	class:plog_t
iterate_backwards	plog.h	/^    iter_t* iterate_backwards()$/;"	f	class:plog_t
iterate_forwards	plog.h	/^    iter_t* iterate_forwards()$/;"	f	class:plog_t
join	smthread.cpp	/^smthread_t::join(timeout_in_ms timeout)$/;"	f	class:smthread_t
join_carray_status	log_carray.h	/^    static carray_status_t join_carray_status (carray_status_t current_status, int32_t size) {$/;"	f	class:ConsolidationArray
join_cleaners	bf_tree_cleaner.cpp	/^w_rc_t bf_tree_cleaner::join_cleaners(uint32_t max_wait_millisec)$/;"	f	class:bf_tree_cleaner
join_expose	log_carray.cpp	/^void ConsolidationArray::join_expose(CArraySlot* info) {$/;"	f	class:ConsolidationArray
join_slot	log_carray.cpp	/^CArraySlot* ConsolidationArray::join_slot($/;"	f	class:ConsolidationArray
key	btcursor.h	/^    const w_keystr_t& key()     { return _key; }$/;"	f	class:bt_cursor_t
key	btree_page_h.h	/^    const w_keystr_t&  key() const    { return _key; }$/;"	f	class:btrec_t
key_bs	sm_du_stats.h	/^    base_stat_t        key_bs;            \/* space used for keys      *\/$/;"	m	struct:btree_lf_stats_t
key_length_t	btree_page_h.h	/^    typedef uint16_t key_length_t;$/;"	t	class:btree_page_h
key_ranges_map	key_ranges_map.h	/^class key_ranges_map$/;"	c
keys	bf_hashtable.cpp	/^    uint64_t keys[HASHBUCKET_INITIAL_CHUNK_SIZE];$/;"	m	struct:bf_hashbucket_chunk	file:
keys	bf_hashtable.cpp	/^    uint64_t* keys;$/;"	m	struct:bf_hashbucket_chunk_linked	file:
keys	logbuf_hashtable.cpp	/^    uint64_t *keys;$/;"	m	struct:logbuf_hashbucket_chunk_linked	file:
keys	logbuf_hashtable.cpp	/^    uint64_t keys[HASHBUCKET_INITIAL_CHUNK_SIZE];$/;"	m	struct:logbuf_hashbucket_chunk	file:
kind	crash.cpp	/^        debuginfo_enum kind;$/;"	m	struct:debuginfo	file:
klen	btree_logrec.h	/^    uint16_t      klen;$/;"	m	struct:btree_ghost_reserve_t
klen	btree_logrec.h	/^    uint16_t    klen;$/;"	m	struct:btree_insert_t
l	lock_s.h	/^        uint64_t l[2]; $/;"	m	union:lockid_t::__anon13
large	sm_du_stats.h	/^    SmStoreMetaStats    large;$/;"	m	class:SmFileMetaStats
largeSnum	sm_du_stats.h	/^    snum_t            largeSnum;$/;"	m	class:SmFileMetaStats
lastEvicted	backup_reader.h	/^    size_t lastEvicted;$/;"	m	class:BackupPrefetcher
lastFinished	logarchiver.h	/^        int lastFinished;$/;"	m	class:LogArchiver::ArchiveIndex
lastLSN	logarchiver.h	/^            lsn_t lastLSN;$/;"	m	struct:LogArchiver::ArchiveIndex::RunInfo
lastLSN	logarchiver.h	/^        lsn_t lastLSN;$/;"	m	class:LogArchiver::ArchiveDirectory
lastPID	logarchiver.h	/^            const lpid_t lastPID;$/;"	m	struct:LogArchiver::ArchiveScanner::RunScanner
lastPID	logarchiver.h	/^            lpid_t lastPID;$/;"	m	struct:LogArchiver::ArchiveIndex::RunInfo
lastRun	logarchiver.h	/^        int lastRun;$/;"	m	class:LogArchiver::BlockAssembly
lastUsedPid	restore.h	/^    shpid_t lastUsedPid;$/;"	m	class:RestoreMgr
lastUsedPid	restore.h	/^    shpid_t lastUsedPid;$/;"	m	class:RestoreScheduler
last_clear	pmap.h	/^    inline    int    last_clear(int start) const {$/;"	f	struct:Pmap
last_log	xct.h	/^xct_t::last_log() const$/;"	f	class:xct_t
last_lsn	logrec.h	/^    lsn_t                last_lsn;$/;"	m	struct:chkpt_xct_tab_t::xrec_t
last_lsn	sm.cpp	/^lsn_t        smlevel_0::last_lsn = lsn_t::null;$/;"	m	class:smlevel_0	file:
last_lsn	sm_base.h	/^    static lsn_t        last_lsn;        \/\/ last_lsn is used by page driven REDO operation Single-Page-Recovery emlsn if encounter$/;"	m	class:smlevel_0
last_lsn	xct.h	/^xct_t::last_lsn() const$/;"	f	class:xct_t
last_lsn_in_partition	log_storage.cpp	/^rc_t log_storage::last_lsn_in_partition(partition_number_t pnum, lsn_t& lsn)$/;"	f	class:log_storage
last_rc	log.h	/^    w_rc_t                       last_rc;$/;"	m	class:log_i
last_set	pmap.h	/^    inline    int    last_set(int start) const {$/;"	f	struct:Pmap
last_skip_lsn	partition.h	/^    const lsn_t&       last_skip_lsn() const { return _last_skip_lsn; }$/;"	f	class:partition_t
last_used_pageid	alloc_cache.h	/^    shpid_t last_used_pageid()$/;"	f	class:alloc_cache_t
last_used_pageid	vol.cpp	/^shpid_t vol_t::last_used_pageid() const$/;"	f	class:vol_t
latch	bf_tree_cb.h	/^    latch_t &latch() {$/;"	f	struct:bf_tree_cb_t
latch	xct.h	/^    latch_t &latch()$/;"	f	class:xct_t
latch_auto_release	bf_tree.cpp	/^    latch_auto_release (latch_t &latch) : _latch(latch) {}$/;"	f	struct:latch_auto_release
latch_auto_release	bf_tree.cpp	/^struct latch_auto_release {$/;"	s	file:
latch_mode	bf_tree.cpp	/^latch_mode_t bf_tree_m::latch_mode(const generic_page* p) {$/;"	f	class:bf_tree_m
latch_mode	fixable_page_h.h	/^    latch_mode_t latch_mode() const { return _mode; }$/;"	f	class:fixable_page_h
latchp	bf_tree_cb.h	/^    latch_t* latchp() const {$/;"	f	struct:bf_tree_cb_t
latchp	xct.h	/^    latch_t* latchp() const$/;"	f	class:xct_t
le	sm_base.h	/^                 gt=gtOp, ge=geOp, lt=ltOp, le=leOp };$/;"	e	enum:smlevel_0::cmp_t
leaf	btree_page.h	/^            } leaf;$/;"	m	union:btree_page_data::__anon6::__anon7	typeref:struct:btree_page_data::__anon6::__anon7::__anon8
leaf_overhead	btree_page.h	/^        leaf_overhead = sizeof(item_length_t),$/;"	e	enum:btree_page_data::__anon10
leaf_pg	sm_du_stats.h	/^    btree_lf_stats_t    leaf_pg;  \/\/ byte counts for leaf pages$/;"	m	struct:btree_stats_t
leaf_pg_cnt	sm_du_stats.h	/^    base_stat_t     leaf_pg_cnt; \/\/ level-1 pages found by tree traversal$/;"	m	struct:btree_stats_t
leaf_stats	btree_page_h.cpp	/^btree_page_h::leaf_stats(btree_lf_stats_t& _stats) {$/;"	f	class:btree_page_h
leave	log_lsn_tracker.cpp	/^void PoorMansOldestLsnTracker::leave(uint64_t xct_id) {$/;"	f	class:PoorMansOldestLsnTracker
length	logrec.h	/^    size_t length()$/;"	f	struct:chkpt_restore_tab_t
length	logrec.h	/^logrec_t::length() const$/;"	f	class:logrec_t
length	mem_mgmt.h	/^        size_t length;$/;"	m	struct:mem_mgmt_t::slot_t
level	btree_page_h.h	/^inline int btree_page_h::level() const {$/;"	f	class:btree_page_h
level_cnt	sm_du_stats.h	/^    base_stat_t     level_cnt;    \/* number of levels in btree *\/$/;"	m	struct:btree_stats_t
lg_rec_page_space	smstats.h	/^    u_long lg_rec_page_space;    $/;"	m	struct:sm_config_info_t
lil_global_store_table	lock_lil.h	/^    lil_global_store_table() {}$/;"	f	class:lil_global_store_table
lil_global_store_table	lock_lil.h	/^class lil_global_store_table : public lil_global_table_base {$/;"	c
lil_global_table	lock_lil.h	/^    lil_global_table() {$/;"	f	class:lil_global_table
lil_global_table	lock_lil.h	/^class lil_global_table {$/;"	c
lil_global_table_base	lock_lil.h	/^class lil_global_table_base {$/;"	c
lil_global_vol_table	lock_lil.h	/^    lil_global_vol_table() {$/;"	f	class:lil_global_vol_table
lil_global_vol_table	lock_lil.h	/^class lil_global_vol_table : public lil_global_table_base {$/;"	c
lil_lock_info	xct.cpp	/^lil_private_table* xct_t::lil_lock_info() const$/;"	f	class:xct_t
lil_lock_info_ptr	xct.cpp	/^    lil_lock_info_ptr() : _ptr(0) { }$/;"	f	struct:lil_lock_info_ptr
lil_lock_info_ptr	xct.cpp	/^struct lil_lock_info_ptr {$/;"	s	file:
lil_lock_modes_t	lock_lil.h	/^enum lil_lock_modes_t {$/;"	g
lil_private_store_table	lock_lil.h	/^    lil_private_store_table() {$/;"	f	class:lil_private_store_table
lil_private_store_table	lock_lil.h	/^class lil_private_store_table {$/;"	c
lil_private_table	lock_lil.h	/^    lil_private_table() {$/;"	f	class:lil_private_table
lil_private_table	lock_lil.h	/^class lil_private_table {$/;"	c
lil_private_vol_table	lock_lil.h	/^    lil_private_vol_table() {$/;"	f	class:lil_private_vol_table
lil_private_vol_table	lock_lil.h	/^class lil_private_vol_table {$/;"	c
limit	log_core.h	/^    virtual smlevel_0::fileoff_t limit() const$/;"	f	class:log_common
limit	log_storage.h	/^    fileoff_t limit() const { return _partition_size; }$/;"	f	class:log_storage
line	smthread.h	/^    int line;$/;"	m	class:func_helper
link_offset	xct.h	/^    static uint32_t    link_offset()$/;"	f	class:stid_list_elem_t
link_to_new_request	lock_x.cpp	/^xct_lock_entry_t* xct_lock_info_t::link_to_new_request (lock_queue_t *queue,$/;"	f	class:xct_lock_info_t
listFileStats	logarchiver.cpp	/^rc_t LogArchiver::ArchiveDirectory::listFileStats(list<RunFileStats>& list)$/;"	f	class:LogArchiver::ArchiveDirectory
listFiles	logarchiver.cpp	/^rc_t LogArchiver::ArchiveDirectory::listFiles(std::vector<std::string>& list)$/;"	f	class:LogArchiver::ArchiveDirectory
list_backups	vol.cpp	/^rc_t vol_m::list_backups($/;"	f	class:vol_m
list_header_t	mem_mgmt.h	/^    class list_header_t {$/;"	c	class:fixed_lists_mem_t
list_volumes	vol.cpp	/^rc_t vol_m::list_volumes($/;"	f	class:vol_m
listening	logarchiver.h	/^    bool listening;$/;"	m	struct:ArchiverControl
lm	sm.cpp	/^lock_m* smlevel_0::lm = 0;$/;"	m	class:smlevel_0	file:
lm	sm_base.h	/^    static lock_m* lm;$/;"	m	class:smlevel_0
loadRunInfo	logarchiver.cpp	/^rc_t LogArchiver::ArchiveIndex::loadRunInfo(const char* fname)$/;"	f	class:LogArchiver::ArchiveIndex
load_by_scan	alloc_cache.cpp	/^rc_t alloc_cache_t::load_by_scan (shpid_t max_pid)$/;"	f	class:alloc_cache_t
load_for_redo	bf_tree.cpp	/^w_rc_t bf_tree_m::load_for_redo(bf_idx idx, vid_t vid,$/;"	f	class:bf_tree_m
local_ns	smstats.cpp	/^namespace local_ns {$/;"	n	file:
lock	lock.cpp	/^rc_t lock_m::lock(const lockid_t &n, const okvl_mode &m, bool conditional, bool check_only,$/;"	f	class:lock_m
lock	lock.cpp	/^rc_t lock_m::lock(uint32_t hash, const okvl_mode &m, bool check_only, xct_t* xd,$/;"	f	class:lock_m
lock	lock.cpp	/^rc_t lock_m::lock(uint32_t hash, const okvl_mode &m, bool conditional, bool check_only,$/;"	f	class:lock_m
lock	plog.h	/^    void lock()$/;"	f	class:plog_t
lock	sm.cpp	/^rc_t ss_m::lock(const lockid_t& n, const okvl_mode& m,$/;"	f	class:ss_m
lock_caching_default	sm.cpp	/^bool        smlevel_0::lock_caching_default = true;$/;"	m	class:smlevel_0	file:
lock_caching_default	sm_base.h	/^    static bool         lock_caching_default;$/;"	m	class:smlevel_0
lock_collect	vtable_sm.cpp	/^ss_m::lock_collect( vtable_t& res, bool names_too) $/;"	f	class:ss_m
lock_core_m	lock_core.cpp	/^lock_core_m::lock_core_m(const sm_options &options) : _htab(NULL), _htabsz(0) {$/;"	f	class:lock_core_m
lock_core_m	lock_core.h	/^class lock_core_m {$/;"	c
lock_dump_locks	lock.cpp	/^void lock_dump_locks() { $/;"	f
lock_hash	logrec.h	/^    uint32_t             lock_hash;$/;"	m	struct:chkpt_xct_lock_t::lockrec_t
lock_hash	restart.h	/^    uint32_t   lock_hash;    \/\/ lock hash$/;"	m	struct:comp_lock_info_t
lock_info	xct.cpp	/^xct_t::lock_info() const {$/;"	f	class:xct_t
lock_info_ptr	xct.cpp	/^    lock_info_ptr() : _ptr(0) { }$/;"	f	struct:lock_info_ptr
lock_info_ptr	xct.cpp	/^struct lock_info_ptr {$/;"	s	file:
lock_last	lock_vtable.cpp	/^    lock_last $/;"	e	enum:__anon14	file:
lock_m	lock.cpp	/^lock_m::lock_m(const sm_options &options)$/;"	f	class:lock_m
lock_m	lock.h	/^class lock_m : public smlevel_0 {$/;"	c
lock_mode	logrec.h	/^    okvl_mode            lock_mode;$/;"	m	struct:chkpt_xct_lock_t::lockrec_t
lock_mode	restart.h	/^    okvl_mode  lock_mode;    \/\/ lock mode$/;"	m	struct:comp_lock_info_t
lock_mode_attr	lock_vtable.cpp	/^    lock_mode_attr,$/;"	e	enum:__anon14	file:
lock_name_attr	lock_vtable.cpp	/^    lock_name_attr,$/;"	e	enum:__anon14	file:
lock_pool	lock_raw.h	/^    GcPoolForest<RawLock>*      lock_pool;$/;"	m	struct:RawXct
lock_pool_next	lock_raw.h	/^    gc_pointer_raw*             lock_pool_next;$/;"	m	struct:RawXct
lock_queue_entry_t	lock_bucket.h	/^    lock_queue_entry_t (xct_t& xct, smthread_t& thr, xct_lock_info_t& li,$/;"	f	class:lock_queue_entry_t
lock_queue_entry_t	lock_bucket.h	/^class lock_queue_entry_t {$/;"	c
lock_queue_t	lock_bucket.h	/^    lock_queue_t(uint32_t hash) : _hash(hash), _hit_counts(0), _release_version(1), _next (NULL),$/;"	f	class:lock_queue_t
lock_queue_t	lock_bucket.h	/^class lock_queue_t {$/;"	c
lock_status_attr	lock_vtable.cpp	/^    lock_status_attr,$/;"	e	enum:__anon14	file:
lock_table	chkpt.h	/^  chkpt_xct_lock_t lock_table[];  \/\/one per transaction$/;"	m	struct:chkpt_t
lock_tid_attr	lock_vtable.cpp	/^    lock_tid_attr,$/;"	e	enum:__anon14	file:
lock_timeout	smthread.h	/^        timeout_in_ms lock_timeout;    \/\/ timeout to use for lock acquisitions$/;"	m	struct:smthread_t::tcb_t
lock_timeout	smthread.h	/^    timeout_in_ms        lock_timeout() { $/;"	f	class:smthread_t
lock_timeout	smthread.h	/^    void             lock_timeout(timeout_in_ms i) { $/;"	f	class:smthread_t
lock_vtable_attr_names	lock_vtable.cpp	/^const char *lock_vtable_attr_names[] =$/;"	v
lock_wait_cond	lock_raw.h	/^    pthread_cond_t              lock_wait_cond;$/;"	m	struct:RawXct
lock_wait_mutex	lock_raw.h	/^    pthread_mutex_t             lock_wait_mutex;$/;"	m	struct:RawXct
locked_by_me	xct.h	/^    bool locked_by_me() const {$/;"	f	class:xct_i
lockid_t	lock_s.h	/^class lockid_t {$/;"	c
lockid_t	lock_s.h	/^inline NORET lockid_t::lockid_t()$/;"	f	class:lockid_t
lockid_t	lock_s.h	/^lockid_t::lockid_t(const lockid_t& i)$/;"	f	class:lockid_t
lockid_t	lock_s.h	/^lockid_t::lockid_t(const stid_t &stid, const unsigned char *keystr, int16_t keylen)$/;"	f	class:lockid_t
lockid_t	lock_s.h	/^lockid_t::lockid_t(const stid_t &stid, const w_keystr_t &key)$/;"	f	class:lockid_t
lockrec_t	logrec.h	/^    struct lockrec_t {$/;"	s	struct:chkpt_xct_lock_t
log	eventlog.cpp	/^void sysevent::log(logrec_t::kind_t kind)$/;"	f	class:sysevent
log	log.h	/^    log_m&                       log;$/;"	m	class:log_i
log	sm.cpp	/^log_m* smlevel_0::log = 0;$/;"	m	class:smlevel_0	file:
log	sm_base.h	/^    static log_m* log;$/;"	m	class:smlevel_0
logArchiver	sm.cpp	/^LogArchiver* smlevel_0::logArchiver = 0;$/;"	m	class:smlevel_0	file:
logArchiver	sm_base.h	/^    static LogArchiver* logArchiver;$/;"	m	class:smlevel_0
logReadSize	restore.h	/^    size_t logReadSize;$/;"	m	class:RestoreMgr
logScanner	logarchiver.h	/^        LogScanner* logScanner;$/;"	m	class:LogArchiver::LogConsumer
log_archived_callback	sm.cpp	/^                     smlevel_0::log_archived_callback = 0;$/;"	m	class:smlevel_0	file:
log_archived_callback	sm_base.h	/^    static LOG_ARCHIVED_CALLBACK_FUNC log_archived_callback;$/;"	m	class:smlevel_0
log_common	log_core.cpp	/^log_common::log_common(const sm_options& options)$/;"	f	class:log_common
log_common	log_core.h	/^class log_common : public log_m$/;"	c
log_core	log_core.cpp	/^log_core::log_core(const sm_options& options)$/;"	f	class:log_core
log_core	log_core.h	/^class log_core : public log_common$/;"	c
log_file_was_archived	sm.cpp	/^ss_m::log_file_was_archived(const char * logfile)$/;"	f	class:ss_m
log_i	log.h	/^class log_i {$/;"	c
log_i	log.h	/^log_i::log_i(log_m& l, const lsn_t& lsn, const bool forward)  \/\/ Default: true for forward scan$/;"	f	class:log_i
log_m	log.h	/^    log_m() {};$/;"	f	class:log_m
log_m	log.h	/^class log_m : public smlevel_0$/;"	c
log_message	sm.cpp	/^ss_m::log_message(const char * const msg)$/;"	f	class:ss_m
log_page_read	eventlog.cpp	/^void sysevent::log_page_read(shpid_t shpid)$/;"	f	class:sysevent
log_page_write	eventlog.cpp	/^void sysevent::log_page_write(shpid_t shpid, uint32_t count)$/;"	f	class:sysevent
log_prefix	log_storage.h	/^    static const char *log_prefix() { return _log_prefix; }$/;"	f	class:log_storage
log_resv	log_resv.cpp	/^log_resv::log_resv(log_storage* storage)$/;"	f	class:log_resv
log_resv	log_resv.h	/^class log_resv {$/;"	c
log_storage	log_storage.cpp	/^log_storage::log_storage(const char* path, bool reformat, lsn_t& curr_lsn,$/;"	f	class:log_storage
log_storage	log_storage.h	/^class log_storage {$/;"	c
log_warn_callback	sm.cpp	/^                     smlevel_0::log_warn_callback = 0;$/;"	m	class:smlevel_0	file:
log_warn_callback	sm_base.h	/^    static LOG_WARN_CALLBACK_FUNC log_warn_callback;$/;"	m	class:smlevel_0
log_warn_disable	xct.cpp	/^xct_t::log_warn_disable()$/;"	f	class:xct_t
log_warn_exceed_percent	sm.cpp	/^int                  smlevel_0::log_warn_exceed_percent =$/;"	m	class:smlevel_0	file:
log_warn_exceed_percent	sm_base.h	/^    static int                    log_warn_exceed_percent;$/;"	m	class:smlevel_0
log_warn_is_on	xct.cpp	/^xct_t::log_warn_is_on() const$/;"	f	class:xct_t
log_warn_resume	xct.cpp	/^xct_t::log_warn_resume()$/;"	f	class:xct_t
log_warn_trigger	sm.cpp	/^smlevel_0::fileoff_t smlevel_0::log_warn_trigger = 0;$/;"	m	class:smlevel_0	file:
log_warn_trigger	sm_base.h	/^    static fileoff_t              log_warn_trigger;$/;"	m	class:smlevel_0
logbuf_archive	logbuf_core.cpp	/^void logbuf_core::logbuf_archive() {$/;"	f	class:logbuf_core
logbuf_core	logbuf_core.cpp	/^logbuf_core::logbuf_core(const sm_options& options)$/;"	f	class:logbuf_core
logbuf_core	logbuf_core.h	/^class logbuf_core : public log_common {$/;"	c
logbuf_fake_logrec	logbuf_core.cpp	/^logrec_t *logbuf_core::logbuf_fake_logrec(uint32_t recsize) {$/;"	f	class:logbuf_core
logbuf_fetch	logbuf_core.cpp	/^int logbuf_core::logbuf_fetch(lsn_t lsn) {$/;"	f	class:logbuf_core
logbuf_flush	logbuf_core.cpp	/^rc_t logbuf_core::logbuf_flush(const lsn_t &to_lsn, bool block, bool signal, bool$/;"	f	class:logbuf_core
logbuf_hash	logbuf_hashtable.cpp	/^inline uint32_t logbuf_hash(uint64_t x) {$/;"	f
logbuf_hashbucket	logbuf_hashtable.cpp	/^class logbuf_hashbucket {$/;"	c	file:
logbuf_hashbucket_chunk	logbuf_hashtable.cpp	/^struct logbuf_hashbucket_chunk {$/;"	s	file:
logbuf_hashbucket_chunk_linked	logbuf_hashtable.cpp	/^    logbuf_hashbucket_chunk_linked (uint32_t size_)$/;"	f	struct:logbuf_hashbucket_chunk_linked
logbuf_hashbucket_chunk_linked	logbuf_hashtable.cpp	/^struct logbuf_hashbucket_chunk_linked {$/;"	s	file:
logbuf_hashtable	logbuf_hashtable.cpp	/^logbuf_hashtable::logbuf_hashtable(uint32_t size) : _size(size) {$/;"	f	class:logbuf_hashtable
logbuf_hashtable	logbuf_hashtable.h	/^class logbuf_hashtable {$/;"	c
logbuf_insert	logbuf_core.cpp	/^rc_t logbuf_core::logbuf_insert(long recsize) {$/;"	f	class:logbuf_core
logbuf_print	logbuf_core.cpp	/^void logbuf_core::logbuf_print(const char *string, int level) {$/;"	f	class:logbuf_core
logbuf_print_nolock	logbuf_core.cpp	/^void logbuf_core::logbuf_print_nolock(const char *string, int level) {$/;"	f	class:logbuf_core
logbuf_seg	logbuf_seg.cpp	/^logbuf_seg::logbuf_seg(uint32_t size$/;"	f	class:logbuf_seg
logbuf_seg	logbuf_seg.h	/^class logbuf_seg {$/;"	c
logbuf_seg_list_t	logbuf_core.h	/^typedef w_list_t<logbuf_seg, tatas_lock> logbuf_seg_list_t;$/;"	t
logging	smstats.h	/^    bool   logging; $/;"	m	struct:sm_config_info_t
logging_enabled	sm.cpp	/^bool        smlevel_0::logging_enabled = true;$/;"	m	class:smlevel_0	file:
logging_enabled	sm_base.h	/^    static bool         logging_enabled;$/;"	m	class:smlevel_0
logrec_accounting_impl_t	logrec.cpp	/^    logrec_accounting_impl_t() {  reinit(); }$/;"	f	class:logrec_accounting_impl_t
logrec_accounting_impl_t	logrec.cpp	/^class logrec_accounting_impl_t {$/;"	c	file:
logrec_accounting_t	logrec.h	/^class logrec_accounting_t {$/;"	c
logrec_t	logrec.cpp	/^DEFINE_SM_ALLOC(logrec_t);$/;"	v
logrec_t	logrec.h	/^class logrec_t {$/;"	c
look_up	xct.cpp	/^xct_t::look_up(const tid_t& tid)$/;"	f	class:xct_t
lookup	bf_hashtable.cpp	/^bool bf_hashtable<T>::lookup(uint64_t key, T& value) const {$/;"	f	class:bf_hashtable
lookup	btree.cpp	/^rc_t btree_m::lookup($/;"	f	class:btree_m
lookup	logbuf_hashtable.cpp	/^logbuf_seg *logbuf_hashtable::lookup(uint64_t key) const {$/;"	f	class:logbuf_hashtable
lookup_in_doubt	bf_tree.cpp	/^bf_idx bf_tree_m::lookup_in_doubt(const int64_t key) const$/;"	f	class:bf_tree_m
loser_count	lock_raw.cpp	/^int RawLockQueue::loser_count = HAS_LOSER_COUNT;$/;"	m	class:RawLockQueue	file:
loser_count	lock_raw.h	/^    static int                  loser_count;$/;"	m	struct:RawLockQueue
loser_false	xct.h	/^                 loser_false = 0x0,      \/\/ Not a loser transaction$/;"	e	enum:xct_t::loser_xct_state_t
loser_true	xct.h	/^                 loser_true = 0x1,       \/\/ A loser transaction$/;"	e	enum:xct_t::loser_xct_state_t
loser_undoing	xct.h	/^                 loser_undoing = 0x2};   \/\/ Loser transaction is being rolled back currently$/;"	e	enum:xct_t::loser_xct_state_t
loser_xct_state_t	xct.h	/^    enum loser_xct_state_t {$/;"	g	class:xct_t
lpid_t	sm_s.h	/^class lpid_t {$/;"	c
lpid_t	sm_s.h	/^inline lpid_t::lpid_t() : page(0) {}$/;"	f	class:lpid_t
lpid_t	sm_s.h	/^inline lpid_t::lpid_t(const stid_t& s, shpid_t p) : _vol(s.vol), page(p)$/;"	f	class:lpid_t
lpid_t	sm_s.h	/^inline lpid_t::lpid_t(vid_t v, shpid_t p) :$/;"	f	class:lpid_t
lr	logarchiver.h	/^            logrec_t* lr;$/;"	m	struct:LogArchiver::ArchiveScanner::MergeHeapEntry
lrbuf	sm.cpp	/^    char lrbuf[80];$/;"	m	class:ticker_thread_t	file:
lsn	generic_page.h	/^    const lsn_t&  lsn()   const { return _pp->lsn; }$/;"	f	class:generic_page_h
lsn	generic_page.h	/^    lsn_t            lsn;          \/\/ +8 -> 24$/;"	m	class:generic_page_header
lsn	log_carray.h	/^    lsn_t lsn;                          \/\/ +8 -> 24$/;"	m	struct:CArraySlot
lsn	logarchiver.h	/^            lsn_t lsn;$/;"	m	struct:LogArchiver::ArchiveScanner::MergeHeapEntry
lsn	logarchiver.h	/^            lsn_t lsn;$/;"	m	struct:LogArchiver::ArchiverHeap::HeapEntry
lsn	logarchiver.h	/^            lsn_t lsn;$/;"	m	struct:LogArchiver::BlockAssembly::BlockHeader
lsn	logrec.h	/^    const lsn_t&         lsn() const {  return *_lsn_ck(); }$/;"	f	class:logrec_t
lsn	restart.h	/^    lsn_t      lsn;                 \/\/ LSN of the log record$/;"	m	struct:comp_mount_log_t
lsn_ck	logrec.h	/^    const lsn_t&         lsn_ck() const {  return *_lsn_ck(); }$/;"	f	class:logrec_t
lt	sm_base.h	/^                 gt=gtOp, ge=geOp, lt=ltOp, le=leOp };$/;"	e	enum:smlevel_0::cmp_t
m1_default_restart	sm_external.h	/^const int32_t m1_default_restart =          \/\/ sm_restart, serial and default (if caller did not specify mode)$/;"	v
m2_alt_rebalance_restart	sm_external.h	/^const int32_t m2_alt_rebalance_restart =    \/\/ sm_restart, M2 minimal logging$/;"	v
m2_both_delay_restart	sm_external.h	/^const int32_t m2_both_delay_restart =       \/\/ sm_restart, concurrent testing purpose$/;"	v
m2_both_fl_delay_restart	sm_external.h	/^const int32_t m2_both_fl_delay_restart =     \/\/ sm_restart, concurrent testing purpose$/;"	v
m2_default_restart	sm_external.h	/^const int32_t m2_default_restart =          \/\/ sm_restart, M2 minimal logging$/;"	v
m2_full_logging_restart	sm_external.h	/^const int32_t m2_full_logging_restart =      \/\/ sm_restart, M2 full logging$/;"	v
m2_redo_delay_restart	sm_external.h	/^const int32_t m2_redo_delay_restart =       \/\/ sm_restart, concurrent testing purpose$/;"	v
m2_redo_fl_delay_restart	sm_external.h	/^const int32_t m2_redo_fl_delay_restart =     \/\/ sm_restart, concurrent testing purpose$/;"	v
m2_undo_delay_restart	sm_external.h	/^const int32_t m2_undo_delay_restart =       \/\/ sm_restart, concurrent testing purpose$/;"	v
m2_undo_fl_delay_restart	sm_external.h	/^const int32_t m2_undo_fl_delay_restart =     \/\/ sm_restart, concurrent testing purpose$/;"	v
m3_alt_rebalance_restart	sm_external.h	/^const int32_t m3_alt_rebalance_restart =    \/\/ sm_restart, M3 minimal logging$/;"	v
m3_default_restart	sm_external.h	/^const int32_t m3_default_restart =          \/\/ sm_restart, M3$/;"	v
m4_alt_rebalance_restart	sm_external.h	/^const int32_t m4_alt_rebalance_restart =    \/\/ sm_restart, M4$/;"	v
m4_both_delay_restart	sm_external.h	/^const int32_t m4_both_delay_restart =       \/\/ sm_restart, concurrent testing purpose$/;"	v
m4_default_restart	sm_external.h	/^const int32_t m4_default_restart =          \/\/ sm_restart, M4$/;"	v
m4_redo_delay_restart	sm_external.h	/^const int32_t m4_redo_delay_restart =       \/\/ sm_restart, concurrent testing purpose$/;"	v
m4_undo_delay_restart	sm_external.h	/^const int32_t m4_undo_delay_restart =       \/\/ sm_restart, concurrent testing purpose$/;"	v
m5_alt_rebalance_restart	sm_external.h	/^const int32_t m5_alt_rebalance_restart =    \/\/ sm_restart, M3$/;"	v
m5_default_restart	sm_external.h	/^const int32_t m5_default_restart =          \/\/ sm_restart, M3$/;"	v
m_exists	partition.h	/^    m_exists=0x2,$/;"	e	enum:__anon29
m_flushed	partition.h	/^    m_flushed=0x10    \/\/ has no data cached$/;"	e	enum:__anon29
m_open_for_append	partition.h	/^    m_open_for_append=0x8,$/;"	e	enum:__anon29
m_open_for_read	partition.h	/^    m_open_for_read=0x4,$/;"	e	enum:__anon29
make_in_transit_out	bf_transit_bucket.h	/^    void make_in_transit_out(const bfpid_t &pid) {$/;"	f	class:transit_bucket_t
make_log_name	log_core.h	/^    virtual const char* make_log_name(uint32_t n, char* buf, int bufsz)$/;"	f	class:log_common
make_log_name	log_storage.cpp	/^log_storage::make_log_name(uint32_t idx, char* buf, int bufsz)$/;"	f	class:log_storage
make_not_in_transit_out	bf_transit_bucket.h	/^    void make_not_in_transit_out(const bfpid_t &pid) $/;"	f	class:transit_bucket_t
markSegmentRestored	restore.cpp	/^void RestoreMgr::markSegmentRestored(unsigned segment, bool redo)$/;"	f	class:RestoreMgr
mark_failed	vol.cpp	/^rc_t vol_t::mark_failed(bool evict, bool redo)$/;"	f	class:vol_t
mark_ghost	btree_page_h.cpp	/^void btree_page_h::mark_ghost(slotid_t slot) {$/;"	f	class:btree_page_h
mark_pin_count	smthread.h	/^smthread_t::mark_pin_count()$/;"	f	class:smthread_t
master_lsn	log_core.h	/^    virtual lsn_t master_lsn() const$/;"	f	class:log_common
master_lsn	log_storage.h	/^    lsn_t               master_lsn() const {$/;"	f	class:log_storage
master_prefix	log_storage.h	/^    static const char *master_prefix() { return _master_prefix; }$/;"	f	class:log_storage
matches	crash.cpp	/^        int           matches;$/;"	m	struct:debuginfo	file:
max	logrec.h	/^        max = (logrec_t::max_data_sz - 2 * sizeof(uint32_t))$/;"	e	enum:chkpt_dev_tab_t::__anon23
max	logrec.h	/^        max = (logrec_t::max_data_sz - sizeof(uint32_t) - sizeof(uint16_t))$/;"	e	enum:chkpt_backup_tab_t::__anon24
max	logrec.h	/^    enum {     max = ((logrec_t::max_data_sz - sizeof(tid_t) -$/;"	e	enum:chkpt_xct_lock_t::__anon22
max	logrec.h	/^    enum {     max = ((logrec_t::max_data_sz - sizeof(tid_t) -$/;"	e	enum:chkpt_xct_tab_t::__anon21
max	logrec.h	/^    enum {     max = ((logrec_t::max_data_sz - sizeof(tid_t) -$/;"	e	enum:xct_list_t::__anon26
max	logrec.h	/^    enum { max = (logrec_t::max_data_sz - 2 * sizeof(uint32_t)) \/ sizeof(brec_t) };$/;"	e	enum:chkpt_bf_tab_t::__anon19
max	logrec.h	/^    enum { max = (logrec_t::max_data_sz - sizeof(uint32_t)) \/ sizeof(stid_t) };$/;"	e	enum:prepare_stores_to_free_t::__anon20
max	stnode_page.h	/^    static const size_t max = (page_sz - sizeof(generic_page_header)) \/ sizeof(stnode_t);$/;"	m	class:stnode_page
max	stnode_page.h	/^    static const size_t max = stnode_page::max;$/;"	m	class:stnode_page_h
maxBitmapSize	logrec.h	/^        maxBitmapSize = logrec_t::max_data_sz - 2*sizeof(shpid_t)$/;"	e	enum:chkpt_restore_tab_t::__anon25
maxLSNInBlock	logarchiver.h	/^        lsn_t maxLSNInBlock;$/;"	m	class:LogArchiver::BlockAssembly
maxLSNInRun	logarchiver.h	/^        lsn_t maxLSNInRun;$/;"	m	class:LogArchiver::WriterThread
maxLSNLength	logarchiver.h	/^        int maxLSNLength;$/;"	m	class:LogArchiver::BlockAssembly
maxSegments	logrec.h	/^        maxSegments = maxBitmapSize * 8$/;"	e	enum:chkpt_restore_tab_t::__anon25
max_bodies	btree_page.h	/^        max_bodies = data_sz\/sizeof(item_body),$/;"	e	enum:btree_page_data::__anon10
max_btree_entry_size	smstats.h	/^    u_long max_btree_entry_size;$/;"	m	struct:sm_config_info_t
max_child_slot	fixable_page_h.cpp	/^int fixable_page_h::max_child_slot() const {$/;"	f	class:fixable_page_h
max_chkpt_size	log_resv.cpp	/^long log_resv::max_chkpt_size() const$/;"	f	class:log_resv
max_data_sz	logrec.h	/^        max_data_sz = max_sz - hdr_non_ssx_sz - sizeof(lsn_t)$/;"	e	enum:logrec_t::__anon18
max_devname	sm_base.h	/^        max_devname = _POSIX_PATH_MAX,        \/\/ max length of unix path name$/;"	e	enum:smlevel_0::sm_constant_t
max_entry_size	btree.cpp	/^btree_m::max_entry_size() {$/;"	f	class:btree_m
max_entry_size	btree_page_h.cpp	/^btree_page_h::max_entry_size =$/;"	m	class:btree_page_h	file:
max_entry_size	btree_page_h.h	/^    static smsize_t         max_entry_size;$/;"	m	class:btree_page_h
max_heads	btree_page.h	/^        max_heads  = data_sz\/sizeof(item_head),$/;"	e	enum:btree_page_data::__anon10
max_item_overhead	btree_page.cpp	/^const size_t btree_page_data::max_item_overhead = sizeof(item_head) + sizeof(item_length_t) + sizeof(shpid_t) + _item_align(1)-1;$/;"	m	class:btree_page_data	file:
max_item_overhead	btree_page.h	/^    static const size_t max_item_overhead;$/;"	m	class:btree_page_data
max_key_length	btree_page_h.h	/^        max_key_length = (1 << (sizeof(key_length_t) * 8 - 1)) - 1,$/;"	e	enum:btree_page_h::_internal
max_keycomp	sm_base.h	/^        max_keycomp = 20,        \/\/ max key component (for btree)$/;"	e	enum:smlevel_0::sm_constant_t
max_logsz	log_core.cpp	/^fileoff_t log_common::max_logsz = 0;$/;"	m	class:log_common	file:
max_logsz	log_core.h	/^    static fileoff_t max_logsz;$/;"	m	class:log_common
max_many_pages	sm_base.h	/^        max_many_pages = 64,$/;"	e	enum:smlevel_0::sm_constant_t
max_openlog	sm_base.h	/^        max_openlog = SM_LOG_PARTITIONS,        \/\/ max # log partitions$/;"	e	enum:smlevel_0::sm_constant_t
max_partition_size	log_storage.cpp	/^fileoff_t log_storage::max_partition_size()$/;"	f	class:log_storage
max_rec_len	sm_base.h	/^        max_rec_len = max_uint4$/;"	e	enum:smlevel_0::__anon39
max_servers	sm_base.h	/^        max_servers = 15,       \/\/ max servers to be connected with$/;"	e	enum:smlevel_0::sm_constant_t
max_small_rec	smstats.h	/^    u_long max_small_rec;      \/\/ maximum number of bytes in a "small"$/;"	m	struct:sm_config_info_t
max_sz	logrec.h	/^        max_sz = 3 * sizeof(generic_page),$/;"	e	enum:logrec_t::__anon18
max_xct_thread	sm_base.h	/^        max_xct_thread = 20,        \/\/ max threads in a xct$/;"	e	enum:smlevel_0::sm_constant_t
me	log_carray.h	/^    mcs_lock::qnode me;                 \/\/ +16 -> 88$/;"	m	struct:CArraySlot
me	smthread.h	/^    static smthread_t*         me() { return (smthread_t*) sthread_t::me(); }$/;"	f	class:smthread_t
me	smthread.h	/^me() $/;"	f
me2	log_carray.h	/^    mcs_lock::qnode me2;                \/\/ +16 -> 16$/;"	m	struct:CArraySlot
mem_mgmt_t	mem_mgmt.h	/^class mem_mgmt_t {$/;"	c
mergeFd	logarchiver.h	/^        int mergeFd;$/;"	m	class:LogArchiver::ArchiveDirectory
metadataRestored	restore.h	/^    bool metadataRestored;$/;"	m	class:RestoreMgr
min_chkpt_rec_lsn	log_core.h	/^    virtual lsn_t min_chkpt_rec_lsn() const$/;"	f	class:log_common
min_chkpt_rec_lsn	log_storage.h	/^    lsn_t               min_chkpt_rec_lsn() const {$/;"	f	class:log_storage
min_partition_size	log_storage.cpp	/^fileoff_t log_storage::min_partition_size()$/;"	f	class:log_storage
mode	lock_raw.h	/^    okvl_mode                   mode;$/;"	m	struct:RawLock
mount	vol.cpp	/^rc_t vol_t::mount(const char* devname)$/;"	f	class:vol_t
mount_log_rec_buf	restart.h	/^    logrec_t*  mount_log_rec_buf;   \/\/ log record of mount\/un-mount$/;"	m	struct:comp_mount_log_t
mount_vol	sm.cpp	/^ss_m::mount_vol(const char* path, vid_t& vid)$/;"	f	class:ss_m
mount_vol_log	logrec.cpp	/^mount_vol_log::mount_vol_log(const char* dev_name)$/;"	f	class:mount_vol_log
moveToNext	logarchiver.cpp	/^void LogArchiver::ArchiveScanner::MergeHeapEntry::moveToNext()$/;"	f	class:LogArchiver::ArchiveScanner::MergeHeapEntry
move_count	btree_logrec.h	/^    uint16_t move_count;$/;"	m	struct:btree_bulk_delete_t
move_pos_backwards	plog.cpp	/^void plog_t::iter_t::move_pos_backwards(uint32_t& pos)$/;"	f	class:plog_t::iter_t
msec	sm.cpp	/^    bool msec;$/;"	m	class:ticker_thread_t	file:
multi_page_log_t	logrec.h	/^    multi_page_log_t(shpid_t page2_pid) : _page2_prv(lsn_t::null), _page2_pid(page2_pid) {$/;"	f	struct:multi_page_log_t
multi_page_log_t	logrec.h	/^struct multi_page_log_t {$/;"	s
mutex	backup_reader.h	/^    pthread_mutex_t mutex;$/;"	m	class:BackupPrefetcher
mutex	logarchiver.h	/^        pthread_mutex_t mutex;$/;"	m	class:LogArchiver::ArchiveDirectory
mutex	logarchiver.h	/^        pthread_mutex_t mutex;$/;"	m	class:LogArchiver::ArchiveIndex
mutex	logarchiver.h	/^    pthread_mutex_t mutex;$/;"	m	struct:ArchiverControl
mutex	plog.h	/^    mutex_t     mutex;$/;"	m	class:plog_t
mutex	restore.h	/^    srwlock_t mutex;$/;"	m	class:RestoreBitmap
mutex	restore.h	/^    srwlock_t mutex;$/;"	m	class:RestoreScheduler
mutex	ringbuffer.h	/^    pthread_mutex_t mutex;$/;"	m	class:AsyncRingBuffer
mutex_for_high_contention	btree_impl.h	/^    inline static queue_based_lock_t* mutex_for_high_contention (shpid_t pid) {$/;"	f	class:btree_impl
mutex_t	plog.h	/^    typedef pthread_mutex_t mutex_t;$/;"	t	class:plog_t
name	crash.cpp	/^        char*         name;$/;"	m	struct:debuginfo	file:
needed	log_resv.h	/^        fileoff_t* needed;$/;"	m	struct:log_resv::waiting_xct
never_mind	xct.h	/^    void never_mind() {$/;"	f	class:xct_i
newBlock	logarchiver.cpp	/^void LogArchiver::ArchiveIndex::newBlock(const vector<pair<lpid_t, size_t> >&$/;"	f	class:LogArchiver::ArchiveIndex
newBlock	logarchiver.cpp	/^void LogArchiver::ArchiveIndex::newBlock(lpid_t firstPID)$/;"	f	class:LogArchiver::ArchiveIndex
new_base	log_carray.h	/^    int64_t new_base;                   \/\/ +8 -> 64$/;"	m	struct:CArraySlot
new_chain_len	btree_logrec.h	/^    uint16_t new_chain_len;$/;"	m	struct:btree_bulk_delete_t
new_deleting_value	stnode_page.h	/^        store_deleting_t new_deleting_value()  const {$/;"	f	class:store_operation_param
new_end	log_carray.h	/^    int64_t new_end;                    \/\/ +8 -> 56$/;"	m	struct:CArraySlot
new_foster_child	btree_logrec.h	/^    shpid_t new_foster_child;$/;"	m	struct:btree_bulk_delete_t
new_high_fence_len	btree_logrec.h	/^    uint16_t new_high_fence_len;$/;"	m	struct:btree_bulk_delete_t
new_store_flags	stnode_page.h	/^        store_flag_t new_store_flags()  const {$/;"	f	class:store_operation_param
new_xct	smthread.cpp	/^smthread_t::new_xct(xct_t *x)$/;"	f	class:smthread_t
new_xct_log_t	xct.cpp	/^xct_t::new_xct_log_t()$/;"	f	class:xct_t
next	btcursor.cpp	/^rc_t bt_cursor_t::next()$/;"	f	class:bt_cursor_t
next	lock_bucket.h	/^    inline lock_queue_t* next () { return _next; }$/;"	f	class:lock_queue_t
next	lock_raw.cpp	/^void RawLockQueue::Iterator::next(bool& must_retry) {$/;"	f	class:RawLockQueue::Iterator
next	lock_raw.h	/^    MarkablePointer<RawLock>    next;$/;"	m	struct:RawLock
next	lock_x.h	/^    xct_lock_entry_t   *next;$/;"	m	class:xct_lock_entry_t
next	logarchiver.cpp	/^bool LogArchiver::ArchiveScanner::RunMerger::next(logrec_t*& lr)$/;"	f	class:LogArchiver::ArchiveScanner::RunMerger
next	logarchiver.cpp	/^bool LogArchiver::ArchiveScanner::RunScanner::next(logrec_t*& lr)$/;"	f	class:LogArchiver::ArchiveScanner::RunScanner
next	logarchiver.cpp	/^bool LogArchiver::LogConsumer::next(logrec_t*& lr)$/;"	f	class:LogArchiver::LogConsumer
next	mem_mgmt.h	/^        list_header_t* next;$/;"	m	class:fixed_lists_mem_t::list_header_t
next	plog.cpp	/^bool plog_t::iter_t::next(logrec_t*& lr)$/;"	f	class:plog_t::iter_t
next	restore.cpp	/^shpid_t RestoreScheduler::next(bool peek)$/;"	f	class:RestoreScheduler
next	xct.h	/^    xct_t* next() { return unsafe_iterator.next(); }$/;"	f	class:xct_i
nextActLSN	logarchiver.h	/^    lsn_t nextActLSN;$/;"	m	class:LogArchiver
nextBlock	logarchiver.cpp	/^bool LogArchiver::ArchiveScanner::RunScanner::nextBlock()$/;"	f	class:LogArchiver::ArchiveScanner::RunScanner
nextBlock	logarchiver.cpp	/^bool LogArchiver::LogConsumer::nextBlock()$/;"	f	class:LogArchiver::LogConsumer
nextBucket	logarchiver.h	/^        size_t nextBucket;$/;"	m	class:LogArchiver::BlockAssembly
nextLSN	logarchiver.h	/^        lsn_t nextLSN;$/;"	m	class:LogArchiver::LogConsumer
nextLogrec	logarchiver.cpp	/^bool LogScanner::nextLogrec(char* src, size_t& pos, logrec_t*& lr, lsn_t* nextLSN,$/;"	f	class:LogScanner
nextPartition	logarchiver.h	/^        uint nextPartition;$/;"	m	class:LogArchiver::ReaderThread
next_chunk	bf_hashtable.cpp	/^    bf_hashbucket_chunk_linked* next_chunk;$/;"	m	struct:bf_hashbucket_chunk_linked	file:
next_chunk	bf_hashtable.cpp	/^    bf_hashbucket_chunk_linked<T>* next_chunk;$/;"	m	struct:bf_hashbucket_chunk	file:
next_chunk	logbuf_hashtable.cpp	/^    logbuf_hashbucket_chunk_linked *next_chunk;$/;"	m	struct:logbuf_hashbucket_chunk_linked	file:
next_chunk	logbuf_hashtable.cpp	/^    logbuf_hashbucket_chunk_linked* next_chunk;$/;"	m	struct:logbuf_hashbucket_chunk	file:
next_high_key	xct.h	/^    w_keystr_t next_high_key;$/;"	m	class:inquery_verify_context_t
next_level	xct.h	/^    int16_t next_level;$/;"	m	class:inquery_verify_context_t
next_low_key	xct.h	/^    w_keystr_t next_low_key;$/;"	m	class:inquery_verify_context_t
next_pid	xct.h	/^    shpid_t next_pid;$/;"	m	class:inquery_verify_context_t
next_vid	logrec.h	/^    uint16_t next_vid;$/;"	m	struct:chkpt_dev_tab_t
nghosts	btree_page.h	/^    item_index_t  nghosts;                         \/\/ +2 -> 28$/;"	m	class:btree_page_data
nghosts	btree_page_h.h	/^inline int btree_page_h::nghosts() const {$/;"	f	class:btree_page_h
nitems	btree_page.h	/^    item_index_t  nitems;                          \/\/ +2 -> 26$/;"	m	class:btree_page_data
no_lock_section_t	xct.h	/^    no_lock_section_t () {$/;"	f	class:no_lock_section_t
no_lock_section_t	xct.h	/^class no_lock_section_t {$/;"	c
no_longer_in_xct	prologue.h	/^prologue_rc_t::no_longer_in_xct()$/;"	f	class:prologue_rc_t
no_xct	smthread.cpp	/^smthread_t::no_xct(xct_t *x)$/;"	f	class:smthread_t
norecord_split	btree_page_h.cpp	/^rc_t btree_page_h::norecord_split (shpid_t foster, lsn_t foster_emlsn,$/;"	f	class:btree_page_h
normalize_shpid	bf_tree.cpp	/^shpid_t bf_tree_m::normalize_shpid(shpid_t shpid) const {$/;"	f	class:bf_tree_m
nosize	partition.h	/^    enum { nosize = -1 };$/;"	e	enum:partition_t::__anon33
notEmpty	ringbuffer.h	/^    pthread_cond_t notEmpty;$/;"	m	class:AsyncRingBuffer
notFull	ringbuffer.h	/^    pthread_cond_t notFull;$/;"	m	class:AsyncRingBuffer
not_in_xct	prologue.h	/^        not_in_xct,     \/\/ may not have tx, regardless of state$/;"	e	enum:prologue_rc_t::xct_state_t
nrecs	btree_page_h.h	/^inline int btree_page_h::nrecs() const {$/;"	f	class:btree_page_h
null	sm_s.cpp	/^const lpid_t lpid_t::null;$/;"	m	class:lpid_t	file:
null	sm_s.cpp	/^const rid_t  rid_t::null;$/;"	m	class:rid_t	file:
null	sm_s.h	/^    static const lpid_t null;$/;"	m	class:lpid_t
null	sm_s.h	/^    static const rid_t null;$/;"	m	class:rid_t
null_pid	logrec.h	/^logrec_t::null_pid() const$/;"	f	class:logrec_t
num	logrec.h	/^    uint32_t            num;$/;"	m	struct:prepare_stores_to_free_t
num	partition.h	/^    partition_number_t num() const   { return _num; }$/;"	f	class:partition_t
numAllocPages	sm_du_stats.h	/^    base_stat_t        numAllocPages;        \/\/ total num pages allocated to stores$/;"	m	class:SmVolumeMetaStats
numAllocPages	sm_du_stats.h	/^    base_stat_t        numAllocPages;    \/\/ pages with alloc bit set$/;"	m	class:SmStoreMetaStats
numAllocStores	sm_du_stats.h	/^    base_stat_t        numAllocStores;        \/\/ total num of stores allocated$/;"	m	class:SmVolumeMetaStats
numPages	sm_du_stats.h	/^    base_stat_t        numPages;        \/\/ total num pages on volume$/;"	m	class:SmVolumeMetaStats
numReservedPages	sm_du_stats.h	/^    base_stat_t        numReservedPages;    \/\/ total num pages in allocated exts$/;"	m	class:SmVolumeMetaStats
numReservedPages	sm_du_stats.h	/^    base_stat_t        numReservedPages; \/\/ extents * pages-per-extent$/;"	m	class:SmStoreMetaStats
numRestoredPages	restore.h	/^    size_t numRestoredPages;$/;"	m	class:RestoreMgr
numSegments	backup_reader.h	/^    size_t numSegments;$/;"	m	class:BackupPrefetcher
numStores	sm_du_stats.h	/^    base_stat_t        numStores;        \/\/ total max num of stores in volume$/;"	m	class:SmVolumeMetaStats
numSystemPages	sm_du_stats.h	/^    base_stat_t        numSystemPages;        \/\/ total num header pages on volume$/;"	m	class:SmVolumeMetaStats
num_active_xcts	sm.cpp	/^ss_m::num_active_xcts()$/;"	f	class:ss_m
num_active_xcts	xct.cpp	/^xct_t::num_active_xcts()$/;"	f	class:xct_t
num_alloc_pages	alloc_page.h	/^    static size_t num_alloc_pages(shpid_t max_pid)$/;"	f	class:alloc_page
num_backups	vol.cpp	/^unsigned vol_t::num_backups() const$/;"	f	class:vol_t
num_clear	pmap.h	/^    inline    int    num_clear() const { return bm_num_clr(bits, _count); }$/;"	f	struct:Pmap
num_pages	vol.h	/^    uint32_t    num_pages() const { return _num_pages; }$/;"	f	class:vol_t
num_pages	vol.h	/^    uint32_t   num_pages;$/;"	m	class:volhdr_t
num_set	pmap.h	/^    inline    int    num_set() const { return bm_num_set(bits, _count); }$/;"	f	struct:Pmap
num_threads	xct.cpp	/^xct_t::num_threads()$/;"	f	class:xct_t
num_used_pages	vol.cpp	/^uint32_t vol_t::num_used_pages() const$/;"	f	class:vol_t
num_vols	vol.h	/^    int num_vols() { return vol_cnt; }$/;"	f	class:vol_m
number_of_ghosts	btree_page.h	/^    int           number_of_ghosts() const { return nghosts;}$/;"	f	class:btree_page_data
number_of_items	btree_page.h	/^    int           number_of_items()  const { return nitems;}$/;"	f	class:btree_page_data
o	xct.cpp	/^        ostream&        o;$/;"	m	class:PrintSmthreadById	file:
observed	lock_bucket.h	/^        lsn_t observed;$/;"	m	struct:lock_queue_t::check_grant_result
offset	btree_page.h	/^        body_offset_t offset;$/;"	m	struct:btree_page_data::__anon5
offset	logarchiver.h	/^            size_t offset;$/;"	m	struct:LogArchiver::ArchiveIndex::BlockEntry
offset	logarchiver.h	/^            size_t offset;$/;"	m	struct:LogArchiver::ArchiveIndex::ProbeResult
offset	logarchiver.h	/^            size_t offset;$/;"	m	struct:LogArchiver::ArchiveScanner::RunScanner
ok	xct.h	/^    void ok() { _roll = false; }$/;"	f	class:auto_rollback_t
old_deleting_value	stnode_page.h	/^        store_deleting_t old_deleting_value()  const {$/;"	f	class:store_operation_param
old_end	log_carray.h	/^    int64_t old_end;                    \/\/ +8 -> 32$/;"	m	struct:CArraySlot
old_state	xct.h	/^    switch_t old_state;$/;"	m	class:xct_log_switch_t
old_store_flags	stnode_page.h	/^        store_flag_t old_store_flags()  const {$/;"	f	class:store_operation_param
oldest_tid	xct.cpp	/^xct_t::oldest_tid()$/;"	f	class:xct_t
onDemand	restore.h	/^    bool onDemand;$/;"	m	class:RestoreScheduler
one_thread_attached	xct.cpp	/^xct_t::one_thread_attached() const$/;"	f	class:xct_t
op	stnode_page.h	/^        store_operation_t op()  const { return (store_operation_t)_op; };$/;"	f	class:store_operation_param
open	backup.cpp	/^void BackupFile::open() {$/;"	f	class:BackupFile
open	logarchiver.cpp	/^LogArchiver::ArchiveScanner::open(lpid_t startPID, lpid_t endPID,$/;"	f	class:LogArchiver::ArchiveScanner
open	logarchiver.cpp	/^void LogArchiver::LogConsumer::open(lsn_t endLSN, bool readWholeBlocks)$/;"	f	class:LogArchiver::LogConsumer
openForScan	logarchiver.cpp	/^rc_t LogArchiver::ArchiveDirectory::openForScan(int& fd, lsn_t runBegin,$/;"	f	class:LogArchiver::ArchiveDirectory
openNewRun	logarchiver.cpp	/^rc_t LogArchiver::ArchiveDirectory::openNewRun()$/;"	f	class:LogArchiver::ArchiveDirectory
openPartition	logarchiver.cpp	/^rc_t LogArchiver::ReaderThread::openPartition()$/;"	f	class:LogArchiver::ReaderThread
open_backup	vol.cpp	/^rc_t vol_t::open_backup()$/;"	f	class:vol_t
open_for_append	partition.cpp	/^partition_t::open_for_append(partition_number_t __num,$/;"	f	class:partition_t
open_for_read	partition.cpp	/^partition_t::open_for_read($/;"	f	class:partition_t
open_store	smindex.cpp	/^rc_t ss_m::open_store (const stid_t &stid, lpid_t &root_pid, bool for_update)$/;"	f	class:ss_m
open_store_nolock	smindex.cpp	/^rc_t ss_m::open_store_nolock (const stid_t &stid, lpid_t &root_pid)$/;"	f	class:ss_m
operating_mode	sm.cpp	/^            smlevel_0::operating_mode = smlevel_0::t_not_started;$/;"	m	class:smlevel_0	file:
operating_mode	sm_base.h	/^    static operating_mode_t operating_mode;$/;"	m	class:smlevel_0
operating_mode_t	sm_base.h	/^    enum operating_mode_t {$/;"	g	class:smlevel_0
operator !=	lock_s.h	/^lockid_t::operator!=(const lockid_t& i) const$/;"	f	class:lockid_t
operator !=	sm_s.h	/^inline bool lpid_t::operator!=(const lpid_t& p) const$/;"	f	class:lpid_t
operator !=	sm_s.h	/^inline bool rid_t::operator!=(const rid_t& r) const$/;"	f	class:rid_t
operator ()	smthread.cpp	/^        void                operator()(const sthread_t& thread)$/;"	f	class:PrintBlockedThread
operator ()	smthread.cpp	/^    void operator()(const sthread_t& thread) {$/;"	f	class:SelectSmthreadsFunc
operator ()	xct.cpp	/^void PrintSmthreadById::operator()(const smthread_t& smthread)$/;"	f	class:PrintSmthreadById
operator +=	sm_du_stats.h	/^inline SmFileMetaStats& SmFileMetaStats::operator+=(const SmFileMetaStats& fileStats)$/;"	f	class:SmFileMetaStats
operator +=	sm_du_stats.h	/^inline SmStoreMetaStats& SmStoreMetaStats::operator+=(const SmStoreMetaStats& storeStats)$/;"	f	class:SmStoreMetaStats
operator +=	sm_du_stats.h	/^inline SmVolumeMetaStats& SmVolumeMetaStats::operator+=(const SmVolumeMetaStats& volumeStats)$/;"	f	class:SmVolumeMetaStats
operator +=	smstats.cpp	/^sm_stats_info_t &operator+=(sm_stats_info_t &s, const sm_stats_info_t &t)$/;"	f
operator -=	smstats.cpp	/^sm_stats_info_t &operator-=(sm_stats_info_t &s, const sm_stats_info_t &t)$/;"	f
operator <	lock_s.h	/^lockid_t::operator<(lockid_t const &i) const$/;"	f	class:lockid_t
operator <	logarchiver.h	/^            bool operator<(const RunInfo& other) const$/;"	f	struct:LogArchiver::ArchiveIndex::RunInfo
operator <	sm_s.h	/^inline bool lpid_t::operator<(const lpid_t& p) const$/;"	f	class:lpid_t
operator <<	btree_page.cpp	/^std::ostream& operator<<(std::ostream& os, btree_page_data& b)$/;"	f
operator <<	btree_page_h.cpp	/^std::ostream& operator<<(std::ostream& os, btree_page_h& b)$/;"	f
operator <<	generic_page.cpp	/^std::ostream& operator<<(std::ostream& os, generic_page_header& p)$/;"	f
operator <<	lock_dump.cpp	/^operator<<(ostream& o, const lockid_t& i)$/;"	f
operator <<	lock_raw.cpp	/^std::ostream& operator<<(std::ostream& o, const RawLock& v) {$/;"	f
operator <<	lock_raw.cpp	/^std::ostream& operator<<(std::ostream& o, const RawLockQueue& v) {$/;"	f
operator <<	lock_raw.cpp	/^std::ostream& operator<<(std::ostream& o, const RawXct &v) {$/;"	f
operator <<	logarchiver.cpp	/^std::ostream& operator<< (ostream& os,$/;"	f
operator <<	logarchiver.h	/^            friend std::ostream& operator<<(std::ostream& os,$/;"	f	struct:LogArchiver::ArchiveScanner::MergeHeapEntry
operator <<	logarchiver.h	/^            friend std::ostream& operator<<(std::ostream& os,$/;"	f	struct:LogArchiver::ArchiverHeap::HeapEntry
operator <<	logrec.cpp	/^operator<<(ostream& o, const logrec_t& l)$/;"	f
operator <<	pmap.cpp	/^ostream    &operator<<(ostream &s, const Pmap &pmap)$/;"	f
operator <<	sm.cpp	/^operator<<(ostream &o, const sm_stats_info_t &s)$/;"	f
operator <<	sm.cpp	/^operator<<(ostream& o, const smlevel_0::store_deleting_t value)$/;"	f
operator <<	sm.cpp	/^operator<<(ostream& o, const smlevel_0::store_operation_t op)$/;"	f
operator <<	sm.cpp	/^operator<<(ostream& o, smlevel_0::sm_store_property_t p)$/;"	f
operator <<	sm.cpp	/^operator<<(ostream& o, smlevel_0::store_flag_t flag) {$/;"	f
operator <<	sm.cpp	/^ostream& operator<<(ostream& o, const lpid_t& pid)$/;"	f
operator <<	sm.cpp	/^ostream& operator<<(ostream& o, const smlevel_0::xct_state_t& xct_state)$/;"	f
operator <<	sm.h	/^    friend ostream& operator<<(ostream& o, const sm_save_point_t& p) {$/;"	f	class:sm_save_point_t
operator <<	sm.h	/^ostream& operator<<(ostream& o, const sm_config_info_t& s)$/;"	f
operator <<	sm_du_stats.cpp	/^ostream& operator<<(ostream& o, const btree_int_stats_t& s)$/;"	f
operator <<	sm_du_stats.cpp	/^ostream& operator<<(ostream& o, const btree_lf_stats_t& s)$/;"	f
operator <<	sm_du_stats.cpp	/^ostream& operator<<(ostream& o, const btree_stats_t& s)$/;"	f
operator <<	sm_du_stats.cpp	/^ostream& operator<<(ostream& o, const sm_du_stats_t& s)$/;"	f
operator <<	sm_du_stats.cpp	/^ostream& operator<<(ostream& o, const volume_hdr_stats_t& s)$/;"	f
operator <<	sm_du_stats.cpp	/^ostream& operator<<(ostream& o, const volume_map_stats_t& s)$/;"	f
operator <<	vol.cpp	/^ostream& operator<<(ostream& o, const store_operation_param& param)$/;"	f
operator <<	xct.cpp	/^operator<<(ostream& o, const xct_t& x)$/;"	f
operator <=	sm_s.h	/^inline bool lpid_t::operator<=(const lpid_t& p) const$/;"	f	class:lpid_t
operator =	bf_tree.h	/^    pin_for_refix_holder& operator=(pin_for_refix_holder& h) {$/;"	f	class:pin_for_refix_holder
operator =	btree_page_h.h	/^    btree_page_h& operator=(btree_page_h& p) {$/;"	f	class:btree_page_h
operator =	fixable_page_h.h	/^    fixable_page_h& operator=(fixable_page_h& p) {$/;"	f	class:fixable_page_h
operator =	lock_s.h	/^lockid_t::operator=(const lockid_t& i)$/;"	f	class:lockid_t
operator =	pmap.h	/^    inline    Pmap_Align4    &operator=(const Pmap &from) {$/;"	f	class:Pmap_Align4
operator ==	lock_s.h	/^lockid_t::operator==(const lockid_t& i) const$/;"	f	class:lockid_t
operator ==	sm_s.h	/^inline bool lpid_t::operator==(const lpid_t& p) const$/;"	f	class:lpid_t
operator ==	sm_s.h	/^inline bool rid_t::operator==(const rid_t& r) const$/;"	f	class:rid_t
operator >	sm_s.h	/^inline bool lpid_t::operator>(const lpid_t& p) const$/;"	f	class:lpid_t
operator >	xct.h	/^operator>(const xct_t& x1, const xct_t& x2)$/;"	f
operator >=	sm_s.h	/^inline bool lpid_t::operator>=(const lpid_t& p) const$/;"	f	class:lpid_t
operator >>	sm.cpp	/^istream& operator>>(istream& i, lpid_t& pid)$/;"	f
operator >>	sm.h	/^    friend istream& operator>>(istream& i, sm_save_point_t& p) {$/;"	f	class:sm_save_point_t
operator new	logrec.h	/^    void* operator new(size_t, void* p) { return p; }$/;"	f	class:logrec_t
org_cc	xct.h	/^    smlevel_0::concurrency_t org_cc;$/;"	m	class:no_lock_section_t
out	smthread.cpp	/^        ostream&        out;$/;"	m	class:PrintBlockedThread	file:
outdir	logarchiver.h	/^        ArchiveDirectory* outdir;$/;"	m	class:LogArchiver::MergerDaemon
overwrite	btree.cpp	/^rc_t btree_m::overwrite($/;"	f	class:btree_m
overwrite_as_undo	btree.cpp	/^rc_t btree_m::overwrite_as_undo(stid_t store, const w_keystr_t &key,$/;"	f	class:btree_m
overwrite_assoc	smindex.cpp	/^rc_t ss_m::overwrite_assoc(stid_t stid, const w_keystr_t &key,$/;"	f	class:ss_m
overwrite_el_nolog	btree_page_h.cpp	/^void btree_page_h::overwrite_el_nolog(slotid_t slot, smsize_t offset,$/;"	f	class:btree_page_h
owner_xct	lock_raw.h	/^    RawXct*                     owner_xct;$/;"	m	struct:RawLock
p	btree_logrec.h	/^    generic_page* p;$/;"	m	struct:SprScratchSpace
pack_scratch_t	btree_page_h.h	/^    typedef key_length_t pack_scratch_t;$/;"	t	class:btree_page_h
padding	btree_page.h	/^    uint16_t      padding;                         \/\/ +2 -> 32$/;"	m	class:btree_page_data
padding	log_carray.h	/^    char            padding[32-sizeof(w_error_codes)]; \/\/ +32-sizeof(w_error_codes) -> 128$/;"	m	struct:CArraySlot
page	alloc_page.h	/^    alloc_page *page() const { return reinterpret_cast<alloc_page*>(_pp); }$/;"	f	class:alloc_page_h
page	btree_page_h.h	/^    btree_page* page() const { return reinterpret_cast<btree_page*>(_pp); }$/;"	f	class:btree_page_h
page	sm_s.h	/^    shpid_t        page;$/;"	m	class:lpid_t
page	sm_s.h	/^    shpid_t        page;$/;"	m	class:shrid_t
page	stnode_page.h	/^            shpid_t page;$/;"	m	union:store_operation_param::__anon44
page	stnode_page.h	/^    stnode_page *page() const { return reinterpret_cast<stnode_page*>(_pp); }$/;"	f	class:stnode_page_h
page2_prev_lsn	logrec.h	/^logrec_t::page2_prev_lsn() const$/;"	f	class:logrec_t
page_evict_log	log_spr.cpp	/^page_evict_log::page_evict_log (const btree_page_h& p,$/;"	f	class:page_evict_log
page_evict_t	log_spr.h	/^    page_evict_t(const lsn_t &child_lsn, general_recordid_t child_slot)$/;"	f	struct:page_evict_t
page_evict_t	log_spr.h	/^struct page_evict_t {$/;"	s
page_exists	backup.cpp	/^bool BackupManager::page_exists(vid_t vid, shpid_t shpid) {$/;"	f	class:BackupManager
page_flag_t	generic_page.h	/^enum page_flag_t {$/;"	g
page_flags	generic_page.h	/^    uint16_t         page_flags;   \/\/  +2 -> 36$/;"	m	class:generic_page_header
page_img_format_log	logrec.cpp	/^page_img_format_log::page_img_format_log(const btree_page_h &page) {$/;"	f	class:page_img_format_log
page_img_format_t	logrec.cpp	/^page_img_format_t::page_img_format_t (const btree_page_h& page)$/;"	f	class:page_img_format_t
page_img_format_t	logrec.h	/^struct page_img_format_t {$/;"	s
page_lsn	logrec.h	/^    lsn_t    page_lsn;  \/\/ +8 -> 32, this is the latest (page) LSN$/;"	m	struct:chkpt_bf_tab_t::brec_t
page_pointer_address	btree_page_h.h	/^inline shpid_t* btree_page_h::page_pointer_address(int offset) {$/;"	f	class:btree_page_h
page_prev_lsn	logrec.h	/^logrec_t::page_prev_lsn() const$/;"	f	class:logrec_t
page_set_to_be_deleted_log	logrec.cpp	/^page_set_to_be_deleted_log::page_set_to_be_deleted_log(const fixable_page_h& p)$/;"	f	class:page_set_to_be_deleted_log
page_set_to_be_deleted_t	logrec.cpp	/^    page_set_to_be_deleted_t(){}$/;"	f	class:page_set_to_be_deleted_t
page_set_to_be_deleted_t	logrec.cpp	/^class page_set_to_be_deleted_t {$/;"	c	file:
page_size	smstats.h	/^    u_long page_size;         \/\/ bytes in page, including all headers$/;"	m	struct:sm_config_info_t
page_sz	alloc_page.h	/^BOOST_STATIC_ASSERT(sizeof(alloc_page) == generic_page_header::page_sz);$/;"	m	class:generic_page_header
page_sz	generic_page.h	/^    static const size_t page_sz = SM_PAGESIZE;$/;"	m	class:generic_page_header
page_sz	generic_page.h	/^BOOST_STATIC_ASSERT(sizeof(generic_page) == generic_page_header::page_sz);$/;"	m	class:generic_page_header
page_sz	sm_base.h	/^        page_sz = SM_PAGESIZE,        \/\/ page size (SM_PAGESIZE is set by makemake)$/;"	e	enum:smlevel_0::sm_constant_t
page_sz	stnode_page.h	/^BOOST_STATIC_ASSERT(sizeof(stnode_page) == generic_page_header::page_sz);$/;"	m	class:generic_page_header
page_tag_t	generic_page.h	/^enum page_tag_t {$/;"	g
pages_checked	xct.h	/^    int32_t pages_checked;$/;"	m	class:inquery_verify_context_t
pages_per_ext	smstats.h	/^    u_long pages_per_ext; $/;"	m	struct:sm_config_info_t
parseLSN	logarchiver.cpp	/^lsn_t LogArchiver::ArchiveDirectory::parseLSN(const char* str, bool end)$/;"	f	class:LogArchiver::ArchiveDirectory
partition_data_size	log_storage.h	/^    fileoff_t           partition_data_size() const {$/;"	f	class:log_storage
partition_index	log_storage.h	/^    partition_index_t   partition_index() const { return _curr_index; }$/;"	f	class:log_storage
partition_index_t	log_storage.h	/^typedef    int    partition_index_t;$/;"	t
partition_index_t	partition.h	/^    typedef int                           partition_index_t;$/;"	t	class:partition_t
partition_mask_values	partition.h	/^} partition_mask_values;$/;"	t	typeref:enum:__anon29
partition_num	log_core.h	/^    virtual partition_number_t partition_num() const$/;"	f	class:log_common
partition_num	log_storage.h	/^    virtual partition_number_t  partition_num() const { return _curr_num; }$/;"	f	class:log_storage
partition_number_t	log.h	/^    typedef    smlevel_0::partition_number_t partition_number_t;$/;"	t	class:log_m
partition_number_t	log_storage.h	/^typedef    smlevel_0::partition_number_t partition_number_t;$/;"	t
partition_number_t	partition.h	/^    typedef smlevel_0::partition_number_t partition_number_t;$/;"	t	class:partition_t
partition_number_t	sm_base.h	/^    typedef    uint32_t partition_number_t;$/;"	t	class:smlevel_0
partition_size	log_storage.cpp	/^fileoff_t log_storage::partition_size(long psize)$/;"	f	class:log_storage
partition_t	partition.h	/^    NORET             partition_t() :$/;"	f	class:partition_t
partition_t	partition.h	/^class partition_t {$/;"	c
peek	partition.cpp	/^partition_t::peek($/;"	f	class:partition_t
peek_compatiblity	lock_raw.cpp	/^bool RawLockQueue::peek_compatiblity(RawXct* xct, uint32_t hash, const okvl_mode &mode) const {$/;"	f	class:RawLockQueue
pg_policy_t	sm_base.h	/^    enum pg_policy_t {$/;"	g	class:smlevel_0
pid	generic_page.h	/^    const lpid_t& pid() const { return _pp->pid; }$/;"	f	class:generic_page_h
pid	generic_page.h	/^    lpid_t           pid;          \/\/ +4+4 (= +8) -> 12$/;"	m	class:generic_page_header
pid	logarchiver.h	/^            lpid_t pid;$/;"	m	struct:LogArchiver::ArchiveIndex::BlockEntry
pid	logarchiver.h	/^            lpid_t pid;$/;"	m	struct:LogArchiver::ArchiveScanner::MergeHeapEntry
pid	logarchiver.h	/^            lpid_t pid;$/;"	m	struct:LogArchiver::ArchiverHeap::HeapEntry
pid	logrec.h	/^    lpid_t    pid;      \/\/ +8 -> 8$/;"	m	struct:chkpt_bf_tab_t::brec_t
pid	logrec.h	/^logrec_t::pid() const$/;"	f	class:logrec_t
pid	sm_s.h	/^    lpid_t        pid;$/;"	m	class:rid_t
pid0	btree_page_h.cpp	/^shpid_t btree_page_h::pid0() const$/;"	f	class:btree_page_h
pid0_opaqueptr	btree_page_h.h	/^inline shpid_t btree_page_h::pid0_opaqueptr() const {$/;"	f	class:btree_page_h
pidBegin	logarchiver.h	/^            lpid_t pidBegin;$/;"	m	struct:LogArchiver::ArchiveIndex::ProbeResult
pidCmp	bf_tree.cpp	/^bool pidCmp(const shpid_t& a, const shpid_t& b) { return a < b; }$/;"	f
pidEnd	logarchiver.h	/^            lpid_t pidEnd;$/;"	m	struct:LogArchiver::ArchiveIndex::ProbeResult
pid_highwatermark	alloc_page.h	/^    shpid_t pid_highwatermark;$/;"	m	class:alloc_page
pid_offset	alloc_page.h	/^    shpid_t pid_offset;$/;"	m	class:alloc_page
pid_to_alloc_pid	alloc_page.h	/^    inline static shpid_t pid_to_alloc_pid (shpid_t pid) {$/;"	f	class:alloc_page_h
pids_inconsistent	xct.h	/^    std::set<shpid_t> pids_inconsistent;$/;"	m	class:inquery_verify_context_t
pin	bf_tree_cb.h	/^    void pin()$/;"	f	struct:bf_tree_cb_t
pin	restore.h	/^    bool pin() {$/;"	f	class:RestoreMgr
pinCount	restore.h	/^    int32_t pinCount;$/;"	m	class:RestoreMgr
pin_count	smthread.h	/^        int      pin_count;      \/\/ number of rsrc_m pins$/;"	m	struct:smthread_t::tcb_t
pin_count	smthread.h	/^smthread_t::pin_count() $/;"	f	class:smthread_t
pin_for_refix	bf_tree.cpp	/^bf_idx bf_tree_m::pin_for_refix(const generic_page* page) {$/;"	f	class:bf_tree_m
pin_for_refix	fixable_page_h.cpp	/^bf_idx fixable_page_h::pin_for_refix() {$/;"	f	class:fixable_page_h
pin_for_refix_holder	bf_tree.h	/^    pin_for_refix_holder() : _idx(0) {}$/;"	f	class:pin_for_refix_holder
pin_for_refix_holder	bf_tree.h	/^    pin_for_refix_holder(bf_idx idx) : _idx(idx) {}$/;"	f	class:pin_for_refix_holder
pin_for_refix_holder	bf_tree.h	/^    pin_for_refix_holder(pin_for_refix_holder &h) {$/;"	f	class:pin_for_refix_holder
pin_for_refix_holder	bf_tree.h	/^class pin_for_refix_holder {$/;"	c
plog	plog.h	/^        plog_t* plog;$/;"	m	class:plog_t::iter_t
plog	plog_xct.h	/^    plog_t plog;$/;"	m	class:plog_xct_t
plog_t	plog.cpp	/^plog_t::plog_t() :$/;"	f	class:plog_t
plog_t	plog.h	/^class plog_t$/;"	c
plog_xct_t	plog_xct.cpp	/^DEFINE_SM_ALLOC(plog_xct_t);$/;"	v
plog_xct_t	plog_xct.cpp	/^plog_xct_t::plog_xct_t($/;"	f	class:plog_xct_t
plog_xct_t	plog_xct.h	/^class plog_xct_t : public xct_t$/;"	c
poor	btree_page.h	/^        poor_man_key  poor;$/;"	m	struct:btree_page_data::__anon5
poor_man_key	btree_page.h	/^    typedef uint16_t poor_man_key;$/;"	t	class:btree_page_data
poor_man_key	btree_page_h.h	/^    typedef uint16_t poor_man_key;$/;"	t	class:btree_page_h
pop	logarchiver.cpp	/^void LogArchiver::ArchiverHeap::pop()$/;"	f	class:LogArchiver::ArchiverHeap
pos	log_carray.h	/^    int64_t pos;                        \/\/ +8 -> 48$/;"	m	struct:CArraySlot
pos	logarchiver.h	/^        off_t pos;$/;"	m	class:LogArchiver::BaseThread
pos	logarchiver.h	/^        size_t pos;$/;"	m	class:LogArchiver::BlockAssembly
pos	logarchiver.h	/^        size_t pos;$/;"	m	class:LogArchiver::LogConsumer
pos	plog.h	/^        uint32_t pos;$/;"	m	class:plog_t::iter_t
pred2	log_carray.h	/^    mcs_lock::qnode* pred2;             \/\/ +8 -> 96$/;"	m	struct:CArraySlot
predecessor	lock_raw.h	/^        RawLock*                    predecessor;$/;"	m	struct:RawLockQueue::Iterator
predict_item_space	btree_page.h	/^inline size_t btree_page_data::predict_item_space(size_t data_length) const {$/;"	f	class:btree_page_data
preemptive	restore.h	/^    bool preemptive;$/;"	m	class:RestoreMgr
prefetch	backup_reader.cpp	/^void BackupPrefetcher::prefetch(unsigned segment, int priority)$/;"	f	class:BackupPrefetcher
prefetch	backup_reader.h	/^    virtual void prefetch(unsigned \/* segment *\/, int \/* priority *\/ = 0)$/;"	f	class:BackupReader
prefetchWindow	restore.h	/^    unsigned prefetchWindow;$/;"	m	class:RestoreMgr
prefix_offset	btree_logrec.h	/^    uint16_t      prefix_offset;$/;"	m	struct:btree_ghost_t
prepare_stores_to_free_t	logrec.h	/^    prepare_stores_to_free_t(uint32_t theNum, const stid_t* theStids)$/;"	f	struct:prepare_stores_to_free_t
prepare_stores_to_free_t	logrec.h	/^struct prepare_stores_to_free_t$/;"	s
prev	lock_x.h	/^    xct_lock_entry_t   *prev;$/;"	m	class:xct_lock_entry_t
prev	mem_mgmt.h	/^        list_header_t* prev;$/;"	m	class:fixed_lists_mem_t::list_header_t
prev_pin_count	smthread.h	/^        int      prev_pin_count; \/\/ previous # of rsrc_m pins$/;"	m	struct:smthread_t::tcb_t
prime	log_storage.cpp	/^log_storage::prime(char* buf, lsn_t next, size_t block_size, bool read_whole_block)$/;"	f	class:log_storage
primes	lock_compt.h	/^static const uint32_t primes[] = {$/;"	v
print	btree.cpp	/^btree_m::print(const lpid_t& current,$/;"	f	class:btree_m
print	btree_page_h.cpp	/^btree_page_h::print(bool print_elem) {$/;"	f	class:btree_page_h
print	pmap.cpp	/^ostream    &Pmap::print(ostream &s) const$/;"	f	class:Pmap
print	sm_du_stats.cpp	/^void btree_int_stats_t::print(ostream& o, const char *pfx) const$/;"	f	class:btree_int_stats_t
print	sm_du_stats.cpp	/^void btree_lf_stats_t::print(ostream& o, const char *pfx) const$/;"	f	class:btree_lf_stats_t
print	sm_du_stats.cpp	/^void btree_stats_t::print(ostream& o, const char *pfx) const$/;"	f	class:btree_stats_t
print	sm_du_stats.cpp	/^void sm_du_stats_t::print(ostream& o, const char *pfx) const$/;"	f	class:sm_du_stats_t
print	sm_du_stats.cpp	/^void volume_hdr_stats_t::print(ostream& o, const char *pfx) const$/;"	f	class:volume_hdr_stats_t
print	sm_du_stats.cpp	/^void volume_map_stats_t::print(ostream& o, const char *pfx) const$/;"	f	class:volume_map_stats_t
print_account_and_clear	logrec.cpp	/^void logrec_accounting_impl_t::print_account_and_clear()$/;"	f	class:logrec_accounting_impl_t
print_account_and_clear	logrec.cpp	/^void logrec_accounting_t::print_account_and_clear()$/;"	f	class:logrec_accounting_t
print_index	smindex.cpp	/^rc_t ss_m::print_index(stid_t stid)$/;"	f	class:ss_m
private_first	lock_raw.h	/^    RawLock*                    private_first;$/;"	m	struct:RawXct
private_hash_map	lock_raw.h	/^    RawXctLockHashMap           private_hash_map;$/;"	m	struct:RawXct
private_hashmap_next	lock_x.h	/^    xct_lock_entry_t    *private_hashmap_next;$/;"	m	class:xct_lock_entry_t
private_hashmap_prev	lock_x.h	/^    xct_lock_entry_t    *private_hashmap_prev;$/;"	m	class:xct_lock_entry_t
private_last	lock_raw.h	/^    RawLock*                    private_last;$/;"	m	struct:RawXct
probe	logarchiver.cpp	/^void LogArchiver::ArchiveIndex::probe(std::vector<ProbeResult>& probes,$/;"	f	class:LogArchiver::ArchiveIndex
probeInRun	logarchiver.cpp	/^void LogArchiver::ArchiveIndex::probeInRun(ProbeResult& res)$/;"	f	class:LogArchiver::ArchiveIndex
processFlushRequest	logarchiver.cpp	/^bool LogArchiver::processFlushRequest()$/;"	f	class:LogArchiver
producerRelease	ringbuffer.h	/^inline void AsyncRingBuffer::producerRelease()$/;"	f	class:AsyncRingBuffer
producerRequest	ringbuffer.h	/^inline char* AsyncRingBuffer::producerRequest()$/;"	f	class:AsyncRingBuffer
prolog	vol.cpp	/^const char* volhdr_t::prolog[] = {$/;"	m	class:volhdr_t	file:
prolog	vol.h	/^    static const char*       prolog[]; \/\/ string array for volume hdr$/;"	m	class:volhdr_t
prologue_rc_t	prologue.h	/^class prologue_rc_t {$/;"	c
prologue_rc_t	prologue.h	/^prologue_rc_t::prologue_rc_t($/;"	f	class:prologue_rc_t
pthread_main	lock_raw.cpp	/^void* RawLockBackgroundThread::pthread_main(void* t) {$/;"	f	class:RawLockBackgroundThread
push	logarchiver.cpp	/^bool LogArchiver::ArchiverHeap::push(logrec_t* lr, bool duplicate)$/;"	f	class:LogArchiver::ArchiverHeap
pushIntoHeap	logarchiver.cpp	/^void LogArchiver::pushIntoHeap(logrec_t* lr, bool duplicate)$/;"	f	class:LogArchiver
push_front	lock_raw.cpp	/^void RawXctLockHashMap::push_front(RawLock* link) {$/;"	f	class:RawXctLockHashMap
push_front	lock_x.cpp	/^void XctLockHashMap::push_front(xct_lock_entry_t* link) {$/;"	f	class:XctLockHashMap
put	btree.cpp	/^rc_t btree_m::put($/;"	f	class:btree_m
put	xct.cpp	/^    void put(lil_private_table* ptr) {$/;"	f	struct:lil_lock_info_ptr
put	xct.cpp	/^    void put(xct_lock_info_t* ptr) {$/;"	f	struct:lock_info_ptr
put_assoc	smindex.cpp	/^rc_t ss_m::put_assoc(stid_t stid, const w_keystr_t& key, const vec_t& el)$/;"	f	class:ss_m
put_in_order	xct.cpp	/^xct_t::put_in_order() {$/;"	f	class:xct_t
queue	lock_x.h	/^    lock_queue_t       *queue;$/;"	m	class:xct_lock_entry_t
queue	restore.h	/^    std::queue<shpid_t> queue;$/;"	m	class:RestoreScheduler
ratio_bf	logrec.cpp	/^    static __thread double            ratio_bf       [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
ratio_bf	logrec.cpp	/^__thread double            logrec_accounting_impl_t::ratio_bf       [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
ratio_bf_cxt	logrec.cpp	/^    static __thread double            ratio_bf_cxt   [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
ratio_bf_cxt	logrec.cpp	/^__thread double            logrec_accounting_impl_t::ratio_bf_cxt   [t_max_logrec];$/;"	m	class:logrec_accounting_impl_t	file:
raw_lock_xct	xct.cpp	/^RawXct* xct_t::raw_lock_xct() const {$/;"	f	class:xct_t
rc	prologue.h	/^    rc_t   rc() {return _rc;}$/;"	f	class:prologue_rc_t
rc_t	sm_base.h	/^typedef   w_rc_t        rc_t;$/;"	t
read	logrec.cpp	/^void chkpt_backup_tab_t::read($/;"	f	class:chkpt_backup_tab_t
read	partition.cpp	/^partition_t::read(char* readbuf, logrec_t *&rp, lsn_t &ll,$/;"	f	class:partition_t
read	vol.cpp	/^rc_t volhdr_t::read(int fd)$/;"	f	class:volhdr_t
readBlock	logarchiver.cpp	/^rc_t LogArchiver::ArchiveDirectory::readBlock(int fd, char* buf,$/;"	f	class:LogArchiver::ArchiveDirectory
readBuffer	logarchiver.h	/^        char* readBuffer;$/;"	m	class:LogArchiver::ArchiveIndex
readSize	logarchiver.h	/^            size_t readSize;$/;"	m	struct:LogArchiver::ArchiveScanner::RunScanner
readWholeBlocks	logarchiver.h	/^        bool readWholeBlocks;$/;"	m	class:LogArchiver::LogConsumer
readWholeBlocks	logarchiver.h	/^    bool readWholeBlocks;$/;"	m	class:LogArchiver
read_acquire	chkpt_serial.cpp	/^chkpt_serial_m::read_acquire()$/;"	f	class:chkpt_serial_m
read_backup	vol.cpp	/^rc_t vol_t::read_backup(shpid_t first, size_t count, void* buf)$/;"	f	class:vol_t
read_devnames	logrec.cpp	/^void chkpt_dev_tab_t::read_devnames(std::vector<string>& devnames)$/;"	f	class:chkpt_dev_tab_t
read_logrec	partition.cpp	/^partition_t::read_logrec(char* readbuf, logrec_t *&rp, lsn_t &ll, int fd)$/;"	f	class:partition_t
read_only	prologue.h	/^        read_only,      \/\/ this method\/function is read-only and so can have$/;"	e	enum:prologue_rc_t::xct_constraint_t
read_page	backup.cpp	/^w_rc_t BackupFile::read_page(AlignedMemory& buffer, shpid_t shpid)$/;"	f	class:BackupFile
read_page	vol.cpp	/^rc_t vol_t::read_page(shpid_t pnum, generic_page& page)$/;"	f	class:vol_t
read_release	chkpt_serial.cpp	/^chkpt_serial_m::read_release()$/;"	f	class:chkpt_serial_m
read_seg	partition.cpp	/^partition_t::read_seg($/;"	f	class:partition_t
read_watermark	lock_raw.h	/^    lsn_t                       read_watermark;$/;"	m	struct:RawXct
read_write	prologue.h	/^        read_write      \/\/ this method\/function may perform updates$/;"	e	enum:prologue_rc_t::xct_constraint_t
readbuf	log_core.h	/^    char *          readbuf() { return _readbuf; }$/;"	f	class:log_common
readbuf	logarchiver.h	/^        AsyncRingBuffer* readbuf;$/;"	m	class:LogArchiver::LogConsumer
reader	logarchiver.h	/^        ReaderThread* reader;$/;"	m	class:LogArchiver::LogConsumer
reads	logbuf_core.h	/^    uint64_t reads;$/;"	m	class:logbuf_core
rec_lsn	logrec.h	/^    lsn_t    rec_lsn;   \/\/ +8 -> 24, this is the minimum (earliest) LSN$/;"	m	struct:chkpt_bf_tab_t::brec_t
recalculate_fence_for_split	btree_page_h.cpp	/^w_keystr_t btree_page_h::recalculate_fence_for_split(slotid_t right_begins_from) const {$/;"	f	class:btree_page_h
record_info_int16_convert	btree_page_h.h	/^    union record_info_int16_convert$/;"	u	class:btree_page_h
record_info_shpid_convert	btree_page_h.h	/^    union record_info_shpid_convert$/;"	u	class:btree_page_h
recover_single_page	log_spr.cpp	/^rc_t restart_m::recover_single_page(fixable_page_h &p, const lsn_t& emlsn,$/;"	f	class:restart_m
recoverable_space	log_storage.h	/^    size_t              recoverable_space(int pcount) const {$/;"	f	class:log_storage
recovery	sm.cpp	/^restart_m* smlevel_0::recovery = 0;$/;"	m	class:smlevel_0	file:
recovery	sm_base.h	/^    static restart_m*  recovery;$/;"	m	class:smlevel_0
redo	btree_logrec.cpp	/^btree_ghost_mark_log::redo(fixable_page_h *page)$/;"	f	class:btree_ghost_mark_log
redo	btree_logrec.cpp	/^btree_ghost_reclaim_log::redo(fixable_page_h* page)$/;"	f	class:btree_ghost_reclaim_log
redo	btree_logrec.cpp	/^btree_insert_log::redo(fixable_page_h* page) {$/;"	f	class:btree_insert_log
redo	btree_logrec.cpp	/^btree_update_log::redo(fixable_page_h* page)$/;"	f	class:btree_update_log
redo	btree_logrec.cpp	/^void btree_compress_page_log::redo(fixable_page_h* p)$/;"	f	class:btree_compress_page_log
redo	btree_logrec.cpp	/^void btree_foster_adopt_log::redo(fixable_page_h* p) {$/;"	f	class:btree_foster_adopt_log
redo	btree_logrec.cpp	/^void btree_foster_deadopt_log::redo(fixable_page_h* p) {$/;"	f	class:btree_foster_deadopt_log
redo	btree_logrec.cpp	/^void btree_foster_merge_log::redo(fixable_page_h* p) {$/;"	f	class:btree_foster_merge_log
redo	btree_logrec.cpp	/^void btree_foster_rebalance_log::redo(fixable_page_h* p) {$/;"	f	class:btree_foster_rebalance_log
redo	btree_logrec.cpp	/^void btree_foster_rebalance_norec_log::redo(fixable_page_h* p) {$/;"	f	class:btree_foster_rebalance_norec_log
redo	btree_logrec.cpp	/^void btree_ghost_reserve_log::redo(fixable_page_h* page) {$/;"	f	class:btree_ghost_reserve_log
redo	btree_logrec.cpp	/^void btree_insert_nonghost_log::redo(fixable_page_h* page) {$/;"	f	class:btree_insert_nonghost_log
redo	btree_logrec.cpp	/^void btree_norec_alloc_log::redo(fixable_page_h* p) {$/;"	f	class:btree_norec_alloc_log
redo	btree_logrec.cpp	/^void btree_overwrite_log::redo(fixable_page_h* page)$/;"	f	class:btree_overwrite_log
redo	btree_logrec.cpp	/^void btree_split_log::redo(fixable_page_h* p)$/;"	f	class:btree_split_log
redo	log_spr.cpp	/^void page_evict_log::redo(fixable_page_h* page) {$/;"	f	class:page_evict_log
redo	logrec.cpp	/^comment_log::redo(fixable_page_h *page)$/;"	f	class:comment_log
redo	logrec.cpp	/^void add_backup_log::redo(fixable_page_h*)$/;"	f	class:add_backup_log
redo	logrec.cpp	/^void alloc_a_page_log::redo(fixable_page_h*)$/;"	f	class:alloc_a_page_log
redo	logrec.cpp	/^void chkpt_backup_tab_log::redo(fixable_page_h*)$/;"	f	class:chkpt_backup_tab_log
redo	logrec.cpp	/^void chkpt_dev_tab_log::redo(fixable_page_h*)$/;"	f	class:chkpt_dev_tab_log
redo	logrec.cpp	/^void chkpt_restore_tab_log::redo(fixable_page_h*)$/;"	f	class:chkpt_restore_tab_log
redo	logrec.cpp	/^void dealloc_a_page_log::redo(fixable_page_h*)$/;"	f	class:dealloc_a_page_log
redo	logrec.cpp	/^void dismount_vol_log::redo(fixable_page_h*)$/;"	f	class:dismount_vol_log
redo	logrec.cpp	/^void format_vol_log::redo(fixable_page_h*)$/;"	f	class:format_vol_log
redo	logrec.cpp	/^void logrec_t::redo(fixable_page_h* page)$/;"	f	class:logrec_t
redo	logrec.cpp	/^void mount_vol_log::redo(fixable_page_h*)$/;"	f	class:mount_vol_log
redo	logrec.cpp	/^void page_img_format_log::redo(fixable_page_h* page) {$/;"	f	class:page_img_format_log
redo	logrec.cpp	/^void page_set_to_be_deleted_log::redo(fixable_page_h* page)$/;"	f	class:page_set_to_be_deleted_log
redo	logrec.cpp	/^void restore_begin_log::redo(fixable_page_h*)$/;"	f	class:restore_begin_log
redo	logrec.cpp	/^void restore_end_log::redo(fixable_page_h*)$/;"	f	class:restore_end_log
redo	logrec.cpp	/^void restore_segment_log::redo(fixable_page_h*)$/;"	f	class:restore_segment_log
redo	logrec.cpp	/^void store_operation_log::redo(fixable_page_h* \/*page*\/)$/;"	f	class:store_operation_log
redo_allocate_one_page	alloc_cache.cpp	/^rc_t alloc_cache_t::redo_allocate_one_page (shpid_t pid)$/;"	f	class:alloc_cache_t
redo_concurrent_pass	restart.cpp	/^void restart_m::redo_concurrent_pass()$/;"	f	class:restart_m
redo_deallocate_one_page	alloc_cache.cpp	/^rc_t alloc_cache_t::redo_deallocate_one_page (shpid_t pid)$/;"	f	class:alloc_cache_t
redo_in_progress	restart.h	/^    bool                        redo_in_progress()$/;"	f	class:restart_m
redo_log_pass	restart.cpp	/^restart_m::redo_log_pass($/;"	f	class:restart_m
redo_lsn	sm.cpp	/^lsn_t        smlevel_0::redo_lsn = lsn_t::null;$/;"	m	class:smlevel_0	file:
redo_lsn	sm_base.h	/^    static lsn_t        redo_lsn;        \/\/ redo_lsn is used by child thread as the start scanning point for redo$/;"	m	class:smlevel_0
redo_segment_restore	vol.cpp	/^void vol_t::redo_segment_restore(unsigned segment)$/;"	f	class:vol_t
refix_direct	bf_tree.cpp	/^w_rc_t bf_tree_m::refix_direct (generic_page*& page, bf_idx$/;"	f	class:bf_tree_m
refix_direct	fixable_page_h.cpp	/^w_rc_t fixable_page_h::refix_direct (bf_idx idx, latch_mode_t mode, bool conditional) {$/;"	f	class:fixable_page_h
refresh_wait_map	lock_x.h	/^    void              refresh_wait_map(atomic_thread_map_t const &new_map) {$/;"	f	class:xct_lock_info_t
refreshed_wait_map	lock_bucket.h	/^        atomic_thread_map_t  refreshed_wait_map;$/;"	m	struct:lock_queue_t::check_grant_result
register_and_mark	bf_tree.cpp	/^w_rc_t bf_tree_m::register_and_mark(bf_idx& ret,$/;"	f	class:bf_tree_m
register_me	xct.cpp	/^xct_dependent_t::register_me() {$/;"	f	class:xct_dependent_t
register_write_order_dependency	bf_tree.cpp	/^bool bf_tree_m::register_write_order_dependency(const generic_page* page, const generic_page* dependency) {$/;"	f	class:bf_tree_m
reinit	logrec.cpp	/^void logrec_accounting_impl_t::reinit()$/;"	f	class:logrec_accounting_impl_t
release	allocator.cpp	/^void sm_tls_allocator::release(T* p, size_t)$/;"	f	class:sm_tls_allocator
release	allocator.cpp	/^void sm_tls_allocator::release(logrec_t* p, size_t)$/;"	f	class:sm_tls_allocator
release	allocator.cpp	/^void sm_tls_allocator::release(plog_xct_t* p, size_t)$/;"	f	class:sm_tls_allocator
release	allocator.cpp	/^void sm_tls_allocator::release(xct_t* p, size_t)$/;"	f	class:sm_tls_allocator
release	allocator.cpp	/^void sm_tls_allocator::release(xct_t::xct_core* p, size_t)$/;"	f	class:sm_tls_allocator
release	allocator.h	/^    void release(void* p, size_t)$/;"	f	class:sm_naive_allocator
release	backup.cpp	/^void AlignedMemory::release() {$/;"	f	class:AlignedMemory
release	bf_tree.cpp	/^void pin_for_refix_holder::release() {$/;"	f	class:pin_for_refix_holder
release	lock_raw.cpp	/^void RawLockQueue::release(RawLock* lock, const lsn_t& commit_lsn) {$/;"	f	class:RawLockQueue
release	log_core.h	/^    virtual void release()$/;"	f	class:log_common
release_1thread_log_mutex	xct.h	/^    void                         release_1thread_log_mutex() {$/;"	f	class:xct_t
release_1thread_xct_mutex	xct.cpp	/^xct_t::release_1thread_xct_mutex() const$/;"	f	class:xct_t
release_all_locks	lock_lil.cpp	/^void lil_private_table::release_all_locks(lil_global_table *global_table, bool read_lock_only, lsn_t commit_lsn)$/;"	f	class:lil_private_table
release_anchor	xct.cpp	/^xct_t::release_anchor( bool and_compensate ADD_LOG_COMMENT_SIG )$/;"	f	class:xct_t
release_duration	lock_core.cpp	/^void lock_core_m::release_duration(bool read_lock_only, lsn_t commit_lsn) {$/;"	f	class:lock_core_m
release_lock	lock_core.cpp	/^void lock_core_m::release_lock(RawLock* lock, lsn_t commit_lsn) {$/;"	f	class:lock_core_m
release_locks	lock_lil.cpp	/^void lil_global_table_base::release_locks(bool *lock_taken, bool read_lock_only, lsn_t commit_lsn)$/;"	f	class:lil_global_table_base
release_partition_lock	log_storage.cpp	/^log_storage::release_partition_lock()$/;"	f	class:log_storage
release_scavenge_lock	log_storage.cpp	/^log_storage::release_scavenge_lock()$/;"	f	class:log_storage
release_space	log_core.h	/^    virtual void                release_space(fileoff_t howmuch)$/;"	f	class:log_common
release_space	log_resv.cpp	/^void log_resv::release_space(fileoff_t amt)$/;"	f	class:log_resv
release_vol_locks	lock_lil.cpp	/^void lil_private_vol_table::release_vol_locks(lil_global_table *global_table, bool read_lock_only, lsn_t commit_lsn)$/;"	f	class:lil_private_vol_table
release_xlist_mutex	xct.cpp	/^void  xct_t::release_xlist_mutex()$/;"	f	class:xct_t
remove	bf_hashtable.cpp	/^bool bf_hashbucket<T>::remove (uint64_t key) {$/;"	f	class:bf_hashbucket
remove	bf_hashtable.cpp	/^bool bf_hashtable<T>::remove(uint64_t key) {$/;"	f	class:bf_hashtable
remove	btree.cpp	/^rc_t btree_m::remove(stid_t store, const w_keystr_t &key)$/;"	f	class:btree_m
remove	lock_raw.cpp	/^void RawXctLockHashMap::remove(RawLock* link) {$/;"	f	class:RawXctLockHashMap
remove	lock_x.cpp	/^void XctLockHashMap::remove(xct_lock_entry_t* link) {$/;"	f	class:XctLockHashMap
remove	logbuf_hashtable.cpp	/^bool logbuf_hashbucket::remove (uint64_t key) {$/;"	f	class:logbuf_hashbucket
remove	logbuf_hashtable.cpp	/^bool logbuf_hashtable::remove(uint64_t key) {$/;"	f	class:logbuf_hashtable
remove_as_undo	btree.cpp	/^btree_m::remove_as_undo(stid_t store, const w_keystr_t &key)$/;"	f	class:btree_m
remove_dependent	xct.cpp	/^xct_t::remove_dependent(xct_dependent_t* dependent)$/;"	f	class:xct_t
remove_from_list	mem_mgmt.cpp	/^char* fixed_lists_mem_t::remove_from_list(size_t block_size)$/;"	f	class:fixed_lists_mem_t
remove_from_list	mem_mgmt.cpp	/^void fixed_lists_mem_t::remove_from_list(list_header_t* p)$/;"	f	class:fixed_lists_mem_t
remove_items	btree_page.cpp	/^void btree_page_data::remove_items($/;"	f	class:btree_page_data
remove_request	lock_x.cpp	/^void xct_lock_info_t::remove_request (xct_lock_entry_t *entry) {$/;"	f	class:xct_lock_info_t
remove_shift_nolog	btree_page_h.cpp	/^rc_t btree_page_h::remove_shift_nolog(slotid_t slot) {$/;"	f	class:btree_page_h
repair_rec_lsn	bf_tree.cpp	/^void bf_tree_m::repair_rec_lsn (generic_page *page, bool was_dirty, const lsn_t &new_rlsn) {$/;"	f	class:bf_tree_m
replace_active_slot	log_carray.cpp	/^void ConsolidationArray::replace_active_slot(uint32_t active_index) {$/;"	f	class:ConsolidationArray
replace_el_nolog	btree_page_h.cpp	/^rc_t btree_page_h::replace_el_nolog(slotid_t slot, const cvec_t &elem) {$/;"	f	class:btree_page_h
replace_fence_rec_nolog_may_defrag	btree_page_h.cpp	/^rc_t btree_page_h::replace_fence_rec_nolog_may_defrag(const w_keystr_t& low,$/;"	f	class:btree_page_h
replace_fence_rec_nolog_no_defrag	btree_page_h.cpp	/^rc_t btree_page_h::replace_fence_rec_nolog_no_defrag(const w_keystr_t& low,$/;"	f	class:btree_page_h
replace_ghost	btree_page_h.cpp	/^rc_t btree_page_h::replace_ghost(const w_keystr_t &key,$/;"	f	class:btree_page_h
replace_item_data	btree_page.cpp	/^bool btree_page_data::replace_item_data(int item, size_t offset, const cvec_t& new_data) {$/;"	f	class:btree_page_data
replacement	logarchiver.cpp	/^void LogArchiver::replacement()$/;"	f	class:LogArchiver
replayedBitmap	restore.h	/^    RestoreBitmap* replayedBitmap;$/;"	m	class:RestoreMgr
requestCond	restore.cpp	/^    pthread_cond_t requestCond;$/;"	m	class:SegmentWriter	file:
requestFlushAsync	logarchiver.cpp	/^bool LogArchiver::requestFlushAsync(lsn_t reqLSN)$/;"	f	class:LogArchiver
requestFlushSync	logarchiver.cpp	/^void LogArchiver::requestFlushSync(lsn_t reqLSN)$/;"	f	class:LogArchiver
requestMutex	restore.cpp	/^    pthread_mutex_t requestMutex;$/;"	m	class:SegmentWriter	file:
requestMutex	restore.h	/^    srwlock_t requestMutex;$/;"	m	class:RestoreMgr
requestRestore	restore.cpp	/^bool RestoreMgr::requestRestore(const shpid_t& pid, generic_page* addr)$/;"	f	class:RestoreMgr
requestWrite	restore.cpp	/^void SegmentWriter::requestWrite(char* workspace,$/;"	f	class:SegmentWriter
request_lock	lock_lil.cpp	/^w_rc_t lil_global_table_base::request_lock(lil_lock_modes_t mode)$/;"	f	class:lil_global_table_base
request_stop_cleaners	bf_tree_cleaner.cpp	/^w_rc_t bf_tree_cleaner::request_stop_cleaners()$/;"	f	class:bf_tree_cleaner
requests	backup_reader.h	/^    std::deque<unsigned> requests;$/;"	m	class:BackupPrefetcher
requests	restore.cpp	/^    std::queue<Request> requests;$/;"	m	class:SegmentWriter	file:
reservations_active	log_resv.h	/^    bool            reservations_active() const { return _reservations_active; }$/;"	f	class:log_resv
reserve_ghost	btree_page_h.cpp	/^void btree_page_h::reserve_ghost(const char *key_raw, size_t key_raw_len, size_t element_length) {$/;"	f	class:btree_page_h
reserve_ghost	btree_page_h.h	/^    void             reserve_ghost(const w_keystr_t &key, size_t element_length) {$/;"	f	class:btree_page_h
reserve_space	log_core.h	/^    virtual fileoff_t           reserve_space(fileoff_t howmuch)$/;"	f	class:log_common
reserve_space	log_resv.cpp	/^fileoff_t log_resv::reserve_space(fileoff_t amt)$/;"	f	class:log_resv
reserved	generic_page.h	/^    uint32_t         reserved;     \/\/  +4 -> 40$/;"	m	class:generic_page_header
reset	lock_raw.cpp	/^void RawXctLockHashMap::reset() {$/;"	f	class:RawXctLockHashMap
reset	lock_x.cpp	/^void XctLockHashMap::reset() {$/;"	f	class:XctLockHashMap
reset	logarchiver.cpp	/^void LogScanner::reset()$/;"	f	class:LogScanner
reset	plog.cpp	/^void plog_t::iter_t::reset()$/;"	f	class:plog_t::iter_t
resetCurrentRun	logarchiver.h	/^        void resetCurrentRun()$/;"	f	class:LogArchiver::WriterThread
resetWriter	logarchiver.h	/^        void resetWriter()$/;"	f	class:LogArchiver::BlockAssembly
reset_for_reuse	lock_x.cpp	/^xct_lock_info_t* xct_lock_info_t::reset_for_reuse() {$/;"	f	class:xct_lock_info_t
reset_master_lsn	log_storage.h	/^    void reset_master_lsn(lsn_t master) { _master_lsn = master; }$/;"	f	class:log_storage
resize_item	btree_page.cpp	/^bool btree_page_data::resize_item(int item, size_t new_length, size_t keep_old) {$/;"	f	class:btree_page_data
restart	restart.cpp	/^restart_m::restart($/;"	f	class:restart_m
restart_in_progress	restart.h	/^    bool                        restart_in_progress()$/;"	f	class:restart_m
restart_internal_mode	sm.cpp	/^           smlevel_0::restart_internal_mode =$/;"	m	class:smlevel_0	file:
restart_internal_mode	sm_base.h	/^    static restart_internal_mode_t restart_internal_mode;$/;"	m	class:smlevel_0
restart_internal_mode_t	sm_base.h	/^    enum restart_internal_mode_t {$/;"	g	class:smlevel_0
restart_m	restart.h	/^    NORET                        restart_m():_restart_thread(0){};$/;"	f	class:restart_m
restart_m	restart.h	/^class restart_m : public smlevel_0 {$/;"	c
restart_phase_t	sm_external.h	/^enum restart_phase_t {$/;"	g
restart_thread_t	restart.h	/^    NORET restart_thread_t()$/;"	f	class:restart_thread_t
restart_thread_t	restart.h	/^class restart_thread_t : public smthread_t$/;"	c
restore	restore.cpp	/^    RestoreMgr* restore;$/;"	m	class:SegmentWriter	file:
restore	restore.h	/^    RestoreMgr* restore;$/;"	m	class:RestoreScheduler
restoreCond	restore.h	/^    pthread_cond_t restoreCond;$/;"	m	class:RestoreMgr
restoreCondMutex	restore.h	/^    pthread_mutex_t restoreCondMutex;$/;"	m	class:RestoreMgr
restoreLoop	restore.cpp	/^void RestoreMgr::restoreLoop()$/;"	f	class:RestoreMgr
restoreMetadata	restore.cpp	/^void RestoreMgr::restoreMetadata()$/;"	f	class:RestoreMgr
restoreSegment	restore.cpp	/^void RestoreMgr::restoreSegment(char* workspace,$/;"	f	class:RestoreMgr
restore_begin_log	logrec.cpp	/^restore_begin_log::restore_begin_log(vid_t vid)$/;"	f	class:restore_begin_log
restore_end_log	logrec.cpp	/^restore_end_log::restore_end_log(vid_t vid)$/;"	f	class:restore_end_log
restore_log_state	xct.cpp	/^xct_t::restore_log_state(switch_t s)$/;"	f	class:xct_t
restore_log_state	xct.cpp	/^xct_t::restore_log_state(switch_t s, bool n )$/;"	f	class:xct_t
restore_segment_log	logrec.cpp	/^restore_segment_log::restore_segment_log(vid_t vid, uint32_t segment)$/;"	f	class:restore_segment_log
restore_table	chkpt.h	/^  chkpt_restore_tab_t restore_table[];  \/\/one per volume$/;"	m	struct:chkpt_t
retire	chkpt.cpp	/^chkpt_thread_t::retire()$/;"	f	class:chkpt_thread_t
retire_chkpt_thread	chkpt.cpp	/^chkpt_m::retire_chkpt_thread()$/;"	f	class:chkpt_m
retrieve_page	backup.cpp	/^w_rc_t BackupManager::retrieve_page(generic_page &page, vid_t vid, shpid_t shpid) {$/;"	f	class:BackupManager
retry_acquire	lock_core.cpp	/^w_error_codes lock_core_m::retry_acquire(RawLock** lock, bool check_only, int32_t timeout) {$/;"	f	class:lock_core_m
retry_acquire	lock_raw.cpp	/^w_error_codes RawLockQueue::retry_acquire(RawLock** lock, bool check_only, int32_t timeout_in_ms) {$/;"	f	class:RawLockQueue
retry_lock	lock.cpp	/^rc_t lock_m::retry_lock(RawLock** lock, bool check_only, timeout_in_ms timeout) {$/;"	f	class:lock_m
reuseRestoredBuffer	restore.h	/^    bool reuseRestoredBuffer;$/;"	m	class:RestoreMgr
rid_t	sm_s.h	/^    rid_t(const lpid_t& p, slotid_t s) : pid(p), slot(s) {};$/;"	f	class:rid_t
rid_t	sm_s.h	/^class rid_t {$/;"	c
rid_t	sm_s.h	/^inline rid_t::rid_t() : slot(0)$/;"	f	class:rid_t
rid_t	sm_s.h	/^inline rid_t::rid_t(vid_t vid, const shrid_t& shrid) :$/;"	f	class:rid_t
robust_is_leaf	btree_page.h	/^inline bool btree_page_data::robust_is_leaf() const {$/;"	f	class:btree_page_data
robust_item_child	btree_page.h	/^inline shpid_t btree_page_data::robust_item_child(int item) const {$/;"	f	class:btree_page_data
robust_item_data	btree_page.h	/^inline const char* btree_page_data::robust_item_data(int item, size_t& length) const {$/;"	f	class:btree_page_data
robust_item_poor	btree_page.h	/^inline btree_page_data::poor_man_key btree_page_data::robust_item_poor(int item) const {$/;"	f	class:btree_page_data
robust_number_of_items	btree_page.h	/^inline int btree_page_data::robust_number_of_items() const {$/;"	f	class:btree_page_data
robust_search	btree_page_h.cpp	/^btree_page_h::robust_search(const char *key_raw, size_t key_raw_len,$/;"	f	class:btree_page_h
rollback	xct.cpp	/^xct_t::rollback(const lsn_t &save_pt)$/;"	f	class:xct_t
rollback_work	sm.cpp	/^ss_m::rollback_work(const sm_save_point_t& sp)$/;"	f	class:ss_m
rolling_back	xct.h	/^    bool                        rolling_back() const { return _rolling_back; }$/;"	f	class:xct_t
root	btree_page_h.h	/^inline lpid_t btree_page_h::root() const {$/;"	f	class:btree_page_h
root	sm.h	/^    shpid_t    root;$/;"	m	class:sm_store_info_t
root	stnode_page.h	/^        shpid_t root()  const {$/;"	f	class:store_operation_param
root	stnode_page.h	/^    shpid_t         root;      \/\/ +4 -> 4$/;"	m	struct:stnode_t
root_index	sm_du_stats.h	/^    btree_stats_t  root_index;        \/* index mapping strings to IDs *\/$/;"	m	struct:volume_map_stats_t
root_shpid	btree_logrec.h	/^    shpid_t       root_shpid;$/;"	m	struct:btree_ghost_t
root_shpid	btree_logrec.h	/^    shpid_t     root_shpid;$/;"	m	struct:btree_insert_t
run	backup_reader.cpp	/^void BackupPrefetcher::run()$/;"	f	class:BackupPrefetcher
run	bf_tree.cpp	/^void WarmupThread::run()$/;"	f	class:WarmupThread
run	bf_tree_cleaner.cpp	/^void bf_tree_cleaner_slave_thread_t::run()$/;"	f	class:bf_tree_cleaner_slave_thread_t
run	chkpt.cpp	/^chkpt_thread_t::run()$/;"	f	class:chkpt_thread_t
run	log_core.cpp	/^    virtual void run() { _log->flush_daemon(); }$/;"	f	class:flush_daemon_thread_t
run	logarchiver.cpp	/^void LogArchiver::ReaderThread::run()$/;"	f	class:LogArchiver::ReaderThread
run	logarchiver.cpp	/^void LogArchiver::WriterThread::run()$/;"	f	class:LogArchiver::WriterThread
run	logarchiver.cpp	/^void LogArchiver::run()$/;"	f	class:LogArchiver
run	logarchiver.h	/^            uint8_t run;$/;"	m	struct:LogArchiver::ArchiverHeap::HeapEntry
run	logarchiver.h	/^            uint8_t run;$/;"	m	struct:LogArchiver::BlockAssembly::BlockHeader
run	restart.cpp	/^void restart_thread_t::run()$/;"	f	class:restart_thread_t
run	restore.cpp	/^void RestoreMgr::run()$/;"	f	class:RestoreMgr
run	restore.cpp	/^void SegmentWriter::run()$/;"	f	class:SegmentWriter
run	sm.cpp	/^    void run()$/;"	f	class:ticker_thread_t
runBegin	logarchiver.h	/^            const lsn_t runBegin;$/;"	m	struct:LogArchiver::ArchiveScanner::RunScanner
runBegin	logarchiver.h	/^            lsn_t runBegin;$/;"	m	struct:LogArchiver::ArchiveIndex::ProbeResult
runComp	logarchiver.cpp	/^bool runComp(const RunFileStats& a, const RunFileStats& b)$/;"	f
runEnd	logarchiver.h	/^            const lsn_t runEnd;$/;"	m	struct:LogArchiver::ArchiveScanner::RunScanner
runEnd	logarchiver.h	/^            lsn_t runEnd;$/;"	m	struct:LogArchiver::ArchiveIndex::ProbeResult
runIndex	logarchiver.h	/^            size_t runIndex;$/;"	m	struct:LogArchiver::ArchiveIndex::ProbeResult
runScan	logarchiver.h	/^            RunScanner* runScan;$/;"	m	struct:LogArchiver::ArchiveScanner::MergeHeapEntry
runSync	logarchiver.cpp	/^rc_t LogArchiver::MergerDaemon::runSync(size_t fanin, size_t minRunSize,$/;"	f	class:LogArchiver::MergerDaemon
run_main	lock_raw.cpp	/^void RawLockBackgroundThread::run_main() {$/;"	f	class:RawLockBackgroundThread
runs	logarchiver.h	/^        std::vector<RunInfo> runs;$/;"	m	class:LogArchiver::ArchiveIndex
s_ex_need_counts	btree_impl.cpp	/^uint8_t btree_impl::s_ex_need_counts[1 << btree_impl::GAC_HASH_BITS];$/;"	m	class:btree_impl	file:
s_ex_need_counts	btree_impl.h	/^    static uint8_t s_ex_need_counts[1 << GAC_HASH_BITS];$/;"	m	class:btree_impl
s_ex_need_mutex	btree_impl.cpp	/^queue_based_lock_t btree_impl::s_ex_need_mutex[1 << GAC_HASH_BITS];$/;"	m	class:btree_impl	file:
s_ex_need_mutex	btree_impl.h	/^    static queue_based_lock_t s_ex_need_mutex[1 << GAC_HASH_BITS];$/;"	m	class:btree_impl
s_foster_children_counts	btree_impl.cpp	/^uint8_t btree_impl::s_foster_children_counts[1 << btree_impl::GAC_HASH_BITS];$/;"	m	class:btree_impl	file:
s_foster_children_counts	btree_impl.h	/^    static uint8_t s_foster_children_counts[1 << GAC_HASH_BITS];$/;"	m	class:btree_impl
s_num_assigned_threads	smthread.cpp	/^int s_num_assigned_threads = 0;$/;"	v
s_num_assigned_threads_lock	smthread.cpp	/^queue_based_lock_t s_num_assigned_threads_lock; \/\/ to protect s_num_assigned_threads$/;"	v
sampling	smthread.h	/^    int sampling;$/;"	m	class:smthread_t
sanity_check	log_storage.cpp	/^log_storage::sanity_check() const$/;"	f	class:log_storage
sanity_check	partition.cpp	/^partition_t::sanity_check() const$/;"	f	class:partition_t
save_point	xct.cpp	/^xct_t::save_point(lsn_t& lsn)$/;"	f	class:xct_t
save_work	sm.cpp	/^ss_m::save_work(sm_save_point_t& sp)$/;"	f	class:ss_m
scanDir	logarchiver.cpp	/^os_dirent_t* LogArchiver::ArchiveDirectory::scanDir(os_dir_t& dir)$/;"	f	class:LogArchiver::ArchiveDirectory
scanner	logarchiver.h	/^            LogScanner* scanner;$/;"	m	struct:LogArchiver::ArchiveScanner::RunScanner
scavenge	log_core.h	/^    virtual rc_t  scavenge(const lsn_t &min_rec_lsn, const lsn_t &min_xct_lsn)$/;"	f	class:log_common
scavenge	log_resv.cpp	/^log_resv::scavenge(const lsn_t &min_rec_lsn, const lsn_t& min_xct_lsn)$/;"	f	class:log_resv
scheduler	restore.h	/^    RestoreScheduler* scheduler;$/;"	m	class:RestoreMgr
search	btree_page_h.cpp	/^btree_page_h::search(const char *key_raw, size_t key_raw_len,$/;"	f	class:btree_page_h
search	btree_page_h.h	/^    void            search(const w_keystr_t& key,$/;"	f	class:btree_page_h
search_node	btree_page_h.cpp	/^void btree_page_h::search_node(const w_keystr_t& key,$/;"	f	class:btree_page_h
segment	restore.cpp	/^        unsigned segment;$/;"	m	struct:SegmentWriter::Request	file:
segmentSize	backup_reader.h	/^    size_t segmentSize;$/;"	m	class:BackupOnDemandReader
segmentSize	backup_reader.h	/^    size_t segmentSize;$/;"	m	class:BackupPrefetcher
segmentSize	backup_reader.h	/^    size_t segmentSize;$/;"	m	class:DummyBackupReader
segmentSize	restore.h	/^    size_t segmentSize;$/;"	m	class:RestoreMgr
segmentSizeBytes	backup_reader.h	/^    size_t segmentSizeBytes;$/;"	m	class:BackupPrefetcher
segsize	log_core.h	/^    long                 segsize() const { return _segsize; }$/;"	f	class:log_common
selection	logarchiver.cpp	/^bool LogArchiver::selection()$/;"	f	class:LogArchiver
selfManaged	logarchiver.h	/^    bool selfManaged;$/;"	m	class:LogArchiver
serialize	restore.cpp	/^void RestoreBitmap::serialize(char* buf, size_t from, size_t to)$/;"	f	class:RestoreBitmap
serializeRunInfo	logarchiver.cpp	/^rc_t LogArchiver::ArchiveIndex::serializeRunInfo(RunInfo& run, int fd,$/;"	f	class:LogArchiver::ArchiveIndex
set	bf_tree.h	/^    void set(bf_idx idx) {$/;"	f	class:pin_for_refix_holder
set	btree_page_h.cpp	/^btrec_t::set(const btree_page_h& page, slotid_t slot) {$/;"	f	class:btrec_t
set	pmap.h	/^    inline    void    set(int bit) { bm_set(bits, bit); }$/;"	f	struct:Pmap
set	restore.cpp	/^void RestoreBitmap::set(unsigned i)$/;"	f	class:RestoreBitmap
setEager	logarchiver.h	/^    void setEager(bool e)$/;"	f	class:LogArchiver
setFailureLSN	restore.h	/^    void setFailureLSN(lsn_t l) { failureLSN = l; }$/;"	f	class:RestoreMgr
setIgnore	logarchiver.h	/^    void setIgnore(logrec_t::kind_t type) {$/;"	f	class:LogScanner
setInstant	restore.cpp	/^void RestoreMgr::setInstant(bool instant)$/;"	f	class:RestoreMgr
setLastFinished	logarchiver.h	/^        void setLastFinished(int f) { lastFinished = f; }$/;"	f	class:LogArchiver::ArchiveIndex
setLastMountLSN	log_core.h	/^    virtual void setLastMountLSN(lsn_t m)$/;"	f	class:log_common
setSinglePass	restore.cpp	/^void RestoreMgr::setSinglePass(bool singlePass)$/;"	f	class:RestoreMgr
setSinglePass	restore.cpp	/^void RestoreScheduler::setSinglePass(bool singlePass)$/;"	f	class:RestoreScheduler
set_all	pmap.h	/^    inline    void    set_all() { bm_fill(bits, _count); }$/;"	f	struct:Pmap
set_alloced	xct.h	/^    void                        set_alloced() { }$/;"	f	class:xct_t
set_bit	alloc_page.h	/^    void   set_bit(uint32_t index) { bitmap[byte_place(index)] |=  bit_mask(index); }$/;"	f	class:alloc_page
set_bit	alloc_page.h	/^inline void alloc_page_h::set_bit(shpid_t pid)$/;"	f	class:alloc_page_h
set_bits	alloc_page.cpp	/^void alloc_page::set_bits(uint32_t from, uint32_t to) {$/;"	f	class:alloc_page
set_bool_option	sm_options.h	/^inline void sm_options::set_bool_option(const std::string& option_name, bool value) {$/;"	f	class:sm_options
set_clr	logrec.h	/^logrec_t::set_clr(const lsn_t& c)$/;"	f	class:logrec_t
set_consecutive_bits	alloc_page.h	/^inline void alloc_page_h::set_consecutive_bits(shpid_t pid_begin, shpid_t pid_end) {$/;"	f	class:alloc_page_h
set_current	log_storage.cpp	/^log_storage::set_current($/;"	f	class:log_storage
set_dirty	bf_tree.cpp	/^void bf_tree_m::set_dirty(const generic_page* p) {$/;"	f	class:bf_tree_m
set_dirty	fixable_page_h.cpp	/^void fixable_page_h::set_dirty() const {$/;"	f	class:fixable_page_h
set_elr_enabled	sm.cpp	/^void ss_m::set_elr_enabled(bool \/* enable *\/)$/;"	f	class:ss_m
set_elr_mode	xct.h	/^    void                        set_elr_mode(elr_mode_t mode) { _elr_mode = mode; }$/;"	f	class:xct_t
set_emlsn_general	btree_page_h.h	/^inline void btree_page_h::set_emlsn_general(general_recordid_t pos, const lsn_t& lsn) {$/;"	f	class:btree_page_h
set_error_encountered	xct.h	/^    void                        set_error_encountered() { _had_error = true; }$/;"	f	class:xct_t
set_error_encountered	xct.h	/^    void                        set_error_encountered() {}$/;"	f	class:xct_t
set_failed	vol.h	/^    void set_failed(bool failed)$/;"	f	class:vol_t
set_fake_disk_latency	sm.cpp	/^ss_m::set_fake_disk_latency(vid_t vid, const int adelay)$/;"	f	class:ss_m
set_fake_disk_latency	vol.cpp	/^bool vol_t::set_fake_disk_latency(const int adelay)$/;"	f	class:vol_t
set_finished	ringbuffer.h	/^    void set_finished(bool f = true) { finished = f; }$/;"	f	class:AsyncRingBuffer
set_first_lsn	xct.h	/^xct_t::set_first_lsn(const lsn_t &l)$/;"	f	class:xct_t
set_foster_child	btree_page_h.cpp	/^bool btree_page_h::set_foster_child(shpid_t foster_child_pid,$/;"	f	class:btree_page_h
set_free	mem_mgmt.h	/^        void set_free() {$/;"	f	class:fixed_lists_mem_t::list_header_t
set_generate_log_warnings	smthread.h	/^    void            set_generate_log_warnings(bool b){_gen_log_warnings=b;}$/;"	f	class:smthread_t
set_ghost	btree_page.cpp	/^void btree_page_data::set_ghost(int item) {$/;"	f	class:btree_page_data
set_in_doubt	bf_tree.cpp	/^void bf_tree_m::set_in_doubt(const bf_idx idx, lsn_t first_lsn,$/;"	f	class:bf_tree_m
set_initial_rec_lsn	bf_tree.cpp	/^void bf_tree_m::set_initial_rec_lsn(const lpid_t& pid,$/;"	f	class:bf_tree_m
set_inquery_verify	xct.h	/^    void                        set_inquery_verify(bool enabled) { _inquery_verify = enabled; }$/;"	f	class:xct_t
set_inquery_verify_keyorder	xct.h	/^    void                        set_inquery_verify_keyorder(bool enabled) { _inquery_verify_keyorder = enabled; }$/;"	f	class:xct_t
set_inquery_verify_space	xct.h	/^    void                        set_inquery_verify_space(bool enabled) { _inquery_verify_space = enabled; }$/;"	f	class:xct_t
set_int_option	sm_options.h	/^inline void sm_options::set_int_option(const std::string& option_name, int64_t value) {$/;"	f	class:sm_options
set_is_update_thread	smthread.h	/^    void             set_is_update_thread(bool in) { tcb()._is_update_thread = in; }$/;"	f	class:smthread_t
set_last_lsn	xct.h	/^xct_t::set_last_lsn( const lsn_t&l)$/;"	f	class:xct_t
set_log_features	sm.cpp	/^rc_t ss_m::set_log_features(char const* \/* features *\/)$/;"	f	class:ss_m
set_log_state	xct.cpp	/^xct_t::set_log_state(switch_t s)$/;"	f	class:xct_t
set_log_state	xct.cpp	/^xct_t::set_log_state(switch_t s, bool &)$/;"	f	class:xct_t
set_loser_xct_in_undo	xct.h	/^    void                        set_loser_xct_in_undo()$/;"	f	class:xct_t
set_lsn_ck	logrec.h	/^    void                 set_lsn_ck(const lsn_t &lsn_ck) {$/;"	f	class:logrec_t
set_lsns	generic_page.h	/^    void          set_lsns(const lsn_t& lsn) { _pp->lsn = lsn; }$/;"	f	class:generic_page_h
set_master	log_core.h	/^    virtual void set_master(const lsn_t& master_lsn, const lsn_t& min_lsn,$/;"	f	class:log_common
set_master	log_storage.cpp	/^void log_storage::set_master(const lsn_t& mlsn, const lsn_t  & min_rec_lsn,$/;"	f	class:log_storage
set_next	lock_bucket.h	/^    inline void set_next (lock_queue_t *new_next) { _next = new_next; }$/;"	f	class:lock_queue_t
set_next_vid	vol.h	/^    void set_next_vid(vid_t vid) {$/;"	f	class:vol_m
set_occupied	mem_mgmt.h	/^        void set_occupied() {$/;"	f	class:fixed_lists_mem_t::list_header_t
set_old_deleting_value	stnode_page.h	/^        void set_old_deleting_value(store_deleting_t old_value) {$/;"	f	class:store_operation_param
set_old_store_flags	stnode_page.h	/^        void set_old_store_flags(store_flag_t flag) {$/;"	f	class:store_operation_param
set_option_logsize	log_core.cpp	/^void log_common::set_option_logsize(const sm_options& options, size_t dftLogsize)$/;"	f	class:log_common
set_page_prev_lsn	logrec.h	/^logrec_t::set_page_prev_lsn(const lsn_t &lsn)$/;"	f	class:logrec_t
set_pid	logrec.h	/^logrec_t::set_pid(const lpid_t& p)$/;"	f	class:logrec_t
set_piggy_backed_single_log_sys_xct	xct.h	/^    void                        set_piggy_backed_single_log_sys_xct(bool enabled) { _piggy_backed_single_log_sys_xct = enabled;}$/;"	f	class:xct_t
set_query_concurrency	xct.h	/^    void                         set_query_concurrency(concurrency_t mode) { _query_concurrency = mode; }$/;"	f	class:xct_t
set_query_exlock_for_select	xct.h	/^    void                         set_query_exlock_for_select(bool mode) {_query_exlock_for_select = mode;}$/;"	f	class:xct_t
set_readonly	vol.h	/^    void set_readonly(bool r)$/;"	f	class:vol_t
set_recovery_access	bf_tree.cpp	/^void bf_tree_m::set_recovery_access(const generic_page* p) {$/;"	f	class:bf_tree_m
set_recovery_access	fixable_page_h.cpp	/^void fixable_page_h::set_recovery_access() const$/;"	f	class:fixable_page_h
set_shutdown_flag	sm.cpp	/^void ss_m::set_shutdown_flag(bool clean)$/;"	f	class:ss_m
set_size	partition.h	/^    void               set_size(fileoff_t v) { _size =  v; }$/;"	f	class:partition_t
set_sli_enabled	sm.cpp	/^void ss_m::set_sli_enabled(bool \/* enable *\/)$/;"	f	class:ss_m
set_snum	lock_s.h	/^inline void lockid_t::set_snum(snum_t _s) $/;"	f	class:lockid_t
set_state	plog.h	/^    void set_state(state_t s) { state = s; }$/;"	f	class:plog_t
set_store	lock_s.h	/^inline void lockid_t::set_store(const stid_t & _s) $/;"	f	class:lockid_t
set_store_flags	vol.cpp	/^rc_t vol_t::set_store_flags(snum_t snum, smlevel_0::store_flag_t flags)$/;"	f	class:vol_t
set_store_property	smfile.cpp	/^ss_m::set_store_property(stid_t stid, store_property_t property)$/;"	f	class:ss_m
set_store_root	vol.cpp	/^rc_t vol_t::set_store_root(snum_t snum, shpid_t root)$/;"	f	class:vol_t
set_string_option	sm_options.h	/^inline void sm_options::set_string_option(const std::string& option_name, const std::string& value) {$/;"	f	class:sm_options
set_swizzling_enabled	bf_tree.cpp	/^w_rc_t bf_tree_m::set_swizzling_enabled(bool enabled) {$/;"	f	class:bf_tree_m
set_tid	lock_x.h	/^    void             set_tid(const tid_t &t) { _tid=t; }$/;"	f	class:xct_lock_info_t
set_timeout	xct.cpp	/^xct_t::set_timeout(timeout_in_ms t)$/;"	f	class:xct_t
set_to_be_deleted	fixable_page_h.cpp	/^rc_t fixable_page_h::set_to_be_deleted (bool log_it) {$/;"	f	class:fixable_page_h
set_undo_nxt	xct.h	/^xct_t::set_undo_nxt(const lsn_t &l)$/;"	f	class:xct_t
set_undoable_clr	logrec.h	/^logrec_t::set_undoable_clr(const lsn_t& c)$/;"	f	class:logrec_t
set_vid	lock_s.h	/^inline void lockid_t::set_vid(const vid_t & v) $/;"	f	class:lockid_t
set_workload_priority	smthread.h	/^    void set_workload_priority(char priority) { _replacement_priority = priority; }$/;"	f	class:smthread_t
set_xct_log_off	xct.h	/^    void         set_xct_log_off() { _xct_log_off = true; }$/;"	f	class:xct_log_t
set_xct_log_on	xct.h	/^    void         set_xct_log_on() { _xct_log_off = false; }$/;"	f	class:xct_log_t
set_xid_prev	logrec.h	/^logrec_t::set_xid_prev(const lsn_t &lsn)$/;"	f	class:logrec_t
setdebuginfo	crash.cpp	/^setdebuginfo($/;"	f
setup_for_restore	fixable_page_h.cpp	/^void fixable_page_h::setup_for_restore(generic_page* pp)$/;"	f	class:fixable_page_h
shouldActivate	logarchiver.cpp	/^bool LogArchiver::shouldActivate(bool logTooSlow)$/;"	f	class:LogArchiver
should_consume_rollback_resv	xct.cpp	/^inline bool   xct_t::should_consume_rollback_resv(int t) const$/;"	f	class:xct_t
should_reserve_for_rollback	xct.h	/^    bool                         should_reserve_for_rollback(int t)$/;"	f	class:xct_t
shpid	logrec.h	/^logrec_t::shpid() const$/;"	f	class:logrec_t
shpid2hash	btree_impl.h	/^    inline static uint32_t shpid2hash (shpid_t pid) {$/;"	f	class:btree_impl
shrid_t	sm_s.h	/^    shrid_t(shpid_t p, snum_t st, slotid_t sl) : page(p), store(st), slot(sl) {}$/;"	f	class:shrid_t
shrid_t	sm_s.h	/^class shrid_t {$/;"	c
shutdown	log_core.cpp	/^void log_core::shutdown()$/;"	f	class:log_core
shutdown	logarchiver.cpp	/^void LogArchiver::BlockAssembly::shutdown()$/;"	f	class:LogArchiver::BlockAssembly
shutdown	logarchiver.cpp	/^void LogArchiver::LogConsumer::shutdown()$/;"	f	class:LogArchiver::LogConsumer
shutdown	logarchiver.cpp	/^void LogArchiver::ReaderThread::shutdown()$/;"	f	class:LogArchiver::ReaderThread
shutdown	logarchiver.cpp	/^void LogArchiver::shutdown()$/;"	f	class:LogArchiver
shutdown	logbuf_core.cpp	/^void logbuf_core::shutdown() {$/;"	f	class:logbuf_core
shutdown	restore.cpp	/^void RestoreMgr::shutdown()$/;"	f	class:RestoreMgr
shutdown	restore.cpp	/^void SegmentWriter::shutdown()$/;"	f	class:SegmentWriter
shutdown	sm.cpp	/^    void shutdown()$/;"	f	class:ticker_thread_t
shutdown	sm.cpp	/^bool ss_m::shutdown()$/;"	f	class:ss_m
shutdown	vol.cpp	/^void vol_m::shutdown(bool abrupt)$/;"	f	class:vol_m
shutdown	vol.cpp	/^void vol_t::shutdown(bool abrupt)$/;"	f	class:vol_t
shutdownFlag	backup_reader.h	/^    bool shutdownFlag;$/;"	m	class:BackupPrefetcher
shutdownFlag	logarchiver.h	/^        bool shutdownFlag;$/;"	m	class:LogArchiver::ReaderThread
shutdownFlag	logarchiver.h	/^    bool shutdownFlag;$/;"	m	class:LogArchiver
shutdownFlag	logarchiver.h	/^    bool* shutdownFlag;$/;"	m	struct:ArchiverControl
shutdownFlag	restore.cpp	/^    bool shutdownFlag;$/;"	m	class:SegmentWriter	file:
shutdown_clean	sm.cpp	/^bool         smlevel_0::shutdown_clean = false;$/;"	m	class:smlevel_0	file:
shutdown_clean	sm_base.h	/^    static bool         shutdown_clean;$/;"	m	class:smlevel_0
shutting_down	sm.cpp	/^bool         smlevel_0::shutting_down = false;$/;"	m	class:smlevel_0	file:
shutting_down	sm_base.h	/^    static bool         shutting_down;$/;"	m	class:smlevel_0
signal_scavenge_cond	log_storage.cpp	/^log_storage::signal_scavenge_cond()$/;"	f	class:log_storage
size	bf_hashtable.cpp	/^    uint32_t  size;$/;"	m	struct:bf_hashbucket_chunk_linked	file:
size	btree_logrec.h	/^    int      size() const {$/;"	f	struct:btree_norec_alloc_t
size	btree_logrec.h	/^    int size()        { return sizeof(shpid_t) + 2*sizeof(int16_t) + klen + elen + sizeof(bool); }$/;"	f	struct:btree_insert_t
size	btree_logrec.h	/^    int size()        { return sizeof(shpid_t) + 3*sizeof(int16_t) + _klen + _elen * 2; }$/;"	f	struct:btree_overwrite_t
size	btree_logrec.h	/^    int size()        { return sizeof(shpid_t) + 3*sizeof(int16_t) + _klen + _old_elen + _new_elen; }$/;"	f	struct:btree_update_t
size	btree_logrec.h	/^    int size() const { return sizeof(multi_page_log_t) + 12 + _low_len + _high_len ; }$/;"	f	struct:btree_foster_deadopt_t
size	btree_logrec.h	/^    int size() const { return sizeof(multi_page_log_t) + 14 + _new_child_key_len; }$/;"	f	struct:btree_foster_adopt_t
size	btree_logrec.h	/^    int size() const { return sizeof(multi_page_log_t) + 2 + _fence_len; }$/;"	f	struct:btree_foster_rebalance_norec_t
size	btree_logrec.h	/^    int size() const { return sizeof(multi_page_log_t) + 24 + _high_len + _chain_high_len + _record_data_len; }$/;"	f	struct:btree_foster_merge_t
size	btree_logrec.h	/^    int size() const { return sizeof(multi_page_log_t) + 26 + _fence_len + _high_len + _chain_high_len + _record_data_len; }$/;"	f	struct:btree_foster_rebalance_t
size	btree_logrec.h	/^    int size() { return sizeof(shpid_t) + sizeof(uint16_t) * 2 + sizeof(size_t) + total_data_size; }$/;"	f	struct:btree_ghost_t
size	btree_logrec.h	/^    int size() { return sizeof(uint16_t) * 2 + klen; }$/;"	f	struct:btree_ghost_reserve_t
size	btree_logrec.h	/^    size_t size()$/;"	f	struct:btree_bulk_delete_t
size	logarchiver.h	/^        size_t size() { return w_heap.NumElements(); }$/;"	f	class:LogArchiver::ArchiverHeap
size	logbuf_hashtable.cpp	/^    uint32_t  size;$/;"	m	struct:logbuf_hashbucket_chunk_linked	file:
size	logrec.cpp	/^    int size()  { return 0;}$/;"	f	class:page_set_to_be_deleted_t
size	logrec.h	/^    int size()        { return 2 * sizeof(size_t) + beginning_bytes + ending_bytes; }$/;"	f	struct:page_img_format_t
size	logrec.h	/^    int size() const  { return sizeof(uint32_t) + num * sizeof(stid_t); };$/;"	f	struct:prepare_stores_to_free_t
size	logrec.h	/^    int size() const {$/;"	f	struct:chkpt_backup_tab_t
size	logrec.h	/^    int size() const {$/;"	f	struct:chkpt_dev_tab_t
size	logrec.h	/^chkpt_bf_tab_t::size() const$/;"	f	class:chkpt_bf_tab_t
size	logrec.h	/^chkpt_xct_lock_t::size() const$/;"	f	class:chkpt_xct_lock_t
size	logrec.h	/^chkpt_xct_tab_t::size() const$/;"	f	class:chkpt_xct_tab_t
size	logrec.h	/^xct_list_t::size() const$/;"	f	class:xct_list_t
size	partition.h	/^    fileoff_t          size() const   { return _size; }$/;"	f	class:partition_t
size	pmap.h	/^    inline    int    size() const { return _size; }$/;"	f	struct:Pmap
size	stnode_page.h	/^        int size()  const { return sizeof (*this); };$/;"	f	class:store_operation_param
sizeof	btree_page.h	/^BOOST_STATIC_ASSERT(sizeof(btree_page) == sizeof(generic_page));$/;"	v
skip_log	logrec.cpp	/^skip_log::skip_log()$/;"	f	class:skip_log
slave_ptr	bf_tree_cleaner.cpp	/^typedef bf_tree_cleaner_slave_thread_t* slave_ptr;$/;"	t	file:
slot	logarchiver.h	/^            mem_mgmt_t::slot_t slot;$/;"	m	struct:LogArchiver::ArchiverHeap::HeapEntry
slot	sm_s.h	/^    slotid_t        slot;$/;"	m	class:rid_t
slot	sm_s.h	/^    slotid_t        slot;$/;"	m	class:shrid_t
slot_data	btree_logrec.h	/^    char          slot_data[logrec_t::max_data_sz - sizeof(shpid_t)$/;"	m	struct:btree_ghost_t
slot_follow_t	btree_impl.h	/^    enum slot_follow_t {$/;"	g	class:btree_impl
slot_length	mem_mgmt.h	/^        size_t slot_length() {$/;"	f	class:fixed_lists_mem_t::list_header_t
slot_t	logarchiver.cpp	/^typedef mem_mgmt_t::slot_t slot_t;$/;"	t	file:
slot_t	mem_mgmt.cpp	/^typedef mem_mgmt_t::slot_t slot_t;$/;"	t	file:
slot_t	mem_mgmt.h	/^        slot_t(char* a, size_t l)$/;"	f	struct:mem_mgmt_t::slot_t
slot_t	mem_mgmt.h	/^    struct slot_t {$/;"	s	class:mem_mgmt_t
slots	backup_reader.h	/^    int* slots;$/;"	m	class:BackupPrefetcher
slowLogGracePeriod	logarchiver.h	/^    int slowLogGracePeriod;$/;"	m	class:LogArchiver
sm	smstats.h	/^    sm_stats_t       sm;$/;"	m	class:sm_stats_info_t
smLastThreadType	smthread.h	/^    enum SmThreadTypes     {smThreadType = 1, smLastThreadType};$/;"	e	enum:smthread_t::SmThreadTypes
smThreadType	smthread.h	/^    enum SmThreadTypes     {smThreadType = 1, smLastThreadType};$/;"	e	enum:smthread_t::SmThreadTypes
sm_config_info_t	smstats.h	/^struct sm_config_info_t {$/;"	s
sm_constant_t	sm_base.h	/^    enum sm_constant_t {$/;"	g	class:smlevel_0
sm_du_stats_t	sm_du_stats.h	/^    NORET             sm_du_stats_t() {clear();}$/;"	f	struct:sm_du_stats_t
sm_du_stats_t	sm_du_stats.h	/^struct sm_du_stats_t {$/;"	s
sm_dumpbuffers	sm.cpp	/^    void        sm_dumpbuffers()$/;"	f
sm_dumplocks	sm.cpp	/^    void        sm_dumplocks()$/;"	f
sm_dumpxcts	sm.cpp	/^    void   sm_dumpxcts()$/;"	f
sm_last	sm_vtable_enum.h	/^    sm_last $/;"	e	enum:__anon42
sm_naive_allocator	allocator.h	/^class sm_naive_allocator$/;"	c
sm_options	sm_options.h	/^class sm_options {$/;"	c
sm_options	sm_options.h	/^inline sm_options::sm_options() {}$/;"	f	class:sm_options
sm_options	sm_options.h	/^inline sm_options::sm_options(const sm_options& other)$/;"	f	class:sm_options
sm_save_point_t	sm.h	/^    NORET            sm_save_point_t(): _tid(0,0) {};$/;"	f	class:sm_save_point_t
sm_save_point_t	sm.h	/^class sm_save_point_t : public lsn_t {$/;"	c
sm_stats_info_t	smstats.h	/^    sm_stats_info_t() {$/;"	f	class:sm_stats_info_t
sm_stats_info_t	smstats.h	/^class sm_stats_info_t {$/;"	c
sm_stats_t	smstats.h	/^class sm_stats_t {$/;"	c
sm_store_info_t	sm.h	/^    NORET sm_store_info_t() : store(0), root(0) {}$/;"	f	class:sm_store_info_t
sm_store_info_t	sm.h	/^class sm_store_info_t {$/;"	c
sm_store_property_t	sm_base.h	/^    enum sm_store_property_t {$/;"	g	class:smlevel_0
sm_thread_map_t	smthread.h	/^typedef w_bitvector_t<SM_DREADLOCK_BITCOUNT>    sm_thread_map_t;$/;"	t
sm_tls_allocator	allocator.h	/^class sm_tls_allocator$/;"	c
small	sm_du_stats.h	/^    SmStoreMetaStats    small;$/;"	m	class:SmFileMetaStats
smallSnum	sm_du_stats.h	/^    snum_t            smallSnum;$/;"	m	class:SmFileMetaStats
smksize_t	sm_base.h	/^    typedef sthread_t::fileoff_t smksize_t;$/;"	t	class:smlevel_0
smlevel_0	sm_base.h	/^class smlevel_0 : public w_base_t {$/;"	c
smlevel_top	sm_base.h	/^typedef smlevel_0 smlevel_top;$/;"	t
smthread_block	smthread.cpp	/^w_error_codes   smthread_t::smthread_block(timeout_in_ms timeout,$/;"	f	class:smthread_t
smthread_init	smthread.cpp	/^static smthread_init_t smthread_init;$/;"	v	file:
smthread_init_t	smthread.cpp	/^smthread_init_t::smthread_init_t()$/;"	f	class:smthread_init_t
smthread_init_t	smthread.h	/^class smthread_init_t {$/;"	c
smthread_is_in_sm_attr	sm_vtable_enum.h	/^    smthread_is_in_sm_attr,$/;"	e	enum:__anon43
smthread_last	sm_vtable_enum.h	/^    smthread_last$/;"	e	enum:__anon43
smthread_name_attr	sm_vtable_enum.h	/^    smthread_name_attr = sthread_last,$/;"	e	enum:__anon43
smthread_pin_count_attr	sm_vtable_enum.h	/^    smthread_pin_count_attr,$/;"	e	enum:__anon43
smthread_t	smthread.cpp	/^smthread_t::smthread_t($/;"	f	class:smthread_t
smthread_t	smthread.h	/^class smthread_t : public sthread_t {$/;"	c
smthread_thread_type_attr	sm_vtable_enum.h	/^    smthread_thread_type_attr,$/;"	e	enum:__anon43
smthread_tid_attr	sm_vtable_enum.h	/^    smthread_tid_attr,$/;"	e	enum:__anon43
smthread_unblock	smthread.cpp	/^w_rc_t   smthread_t::smthread_unblock(w_error_codes e)$/;"	f	class:smthread_t
smthread_vtable_attr_names	vtable_smthread.cpp	/^const char *smthread_vtable_attr_names[] = {$/;"	v
snum	logrec.h	/^logrec_t::snum() const$/;"	f	class:logrec_t
snum	stnode_page.h	/^        snum_t snum()  const { return _snum; };$/;"	f	class:store_operation_param
space_available	plog.h	/^    uint32_t space_available() { return alloc_size() - used_size(); }$/;"	f	class:plog_t
space_for_chkpt	log_core.h	/^    virtual fileoff_t space_for_chkpt() const$/;"	f	class:log_common
space_for_chkpt	log_resv.h	/^    fileoff_t           space_for_chkpt() const { return *&_space_rsvd_for_chkpt ; }$/;"	f	class:log_resv
space_left	log_core.h	/^    virtual fileoff_t space_left() const$/;"	f	class:log_common
space_left	log_resv.h	/^    fileoff_t           space_left() const { return *&_space_available; }$/;"	f	class:log_resv
spawn_chkpt_thread	chkpt.cpp	/^chkpt_m::spawn_chkpt_thread()$/;"	f	class:chkpt_m
spawn_recovery_thread	restart.h	/^    void                        spawn_recovery_thread()$/;"	f	class:restart_m
special_timeout_in_ms_t	smthread.h	/^enum special_timeout_in_ms_t {$/;"	g
srvid_map_sz	sm_base.h	/^        srvid_map_sz = (max_servers - 1) \/ 8 + 1,$/;"	e	enum:smlevel_0::sm_constant_t
ss_m	sm.cpp	/^ss_m::ss_m($/;"	f	class:ss_m
ss_m	sm.h	/^class ss_m : public smlevel_top$/;"	c
ssm_once_mutex	sm.cpp	/^static queue_based_block_lock_t ssm_once_mutex;$/;"	v	file:
ssmtest	crash.cpp	/^ssmtest($/;"	f
ssx_chain_len	xct.h	/^    uint32_t&                   ssx_chain_len() { return _ssx_chain_len;}$/;"	f	class:xct_t
st_empty	sm_base.h	/^        st_empty       = 0x100 \/\/ store might be empty - used ONLY$/;"	e	enum:smlevel_0::store_flag_t
st_insert_file	sm_base.h	/^        st_insert_file = 0x08, \/\/ stored in stnode, but not on page.$/;"	e	enum:smlevel_0::store_flag_t
st_load_file	sm_base.h	/^        st_load_file   = 0x04, \/\/ not stored in the stnode_t,$/;"	e	enum:smlevel_0::store_flag_t
st_proc_t	smthread.h	/^typedef void st_proc_t(void*);$/;"	t
st_regular	sm_base.h	/^        st_regular     = 0x01, \/\/ fully logged$/;"	e	enum:smlevel_0::store_flag_t
st_tmp	sm_base.h	/^        st_tmp         = 0x02, \/\/ space logging only,$/;"	e	enum:smlevel_0::store_flag_t
st_unallocated	sm_base.h	/^        st_unallocated = 0,$/;"	e	enum:smlevel_0::store_flag_t
start	lock_raw.cpp	/^void RawLockBackgroundThread::start() {$/;"	f	class:RawLockBackgroundThread
start	log_core.h	/^        long start; \/\/ offset from _buf[0] of this epoch$/;"	m	struct:log_common::epoch
start	logarchiver.cpp	/^bool LogArchiver::BlockAssembly::start(int run)$/;"	f	class:LogArchiver::BlockAssembly
startLSN	logarchiver.h	/^        lsn_t startLSN;$/;"	m	class:LogArchiver::ArchiveDirectory
start_byte	log_core.h	/^    long                 start_byte() const { return _start; }$/;"	f	class:log_common
start_cleaners	bf_tree_cleaner.cpp	/^w_rc_t bf_tree_cleaner::start_cleaners()$/;"	f	class:bf_tree_cleaner
start_flush_daemon	log_core.h	/^    void start_flush_daemon()$/;"	f	class:log_common
start_log_corruption	log_core.h	/^    void            start_log_corruption() { _log_corruption = true; }$/;"	f	class:log_common
start_log_corruption	sm.cpp	/^ss_m::start_log_corruption()$/;"	f	class:ss_m
start_pos	log_carray.h	/^    int64_t start_pos;                  \/\/ +8 -> 40$/;"	m	struct:CArraySlot
start_seg	log_carray.h	/^    logbuf_seg *start_seg;$/;"	m	struct:CArraySlot
started	logarchiver.h	/^            bool started;$/;"	m	struct:LogArchiver::ArchiveScanner::RunMerger
startup	sm.cpp	/^bool ss_m::startup()$/;"	f	class:ss_m
stash	xct.cpp	/^xct_t::stash(xct_log_t*&x)$/;"	f	class:xct_t
stat_names	smstats.cpp	/^const char *sm_stats_t ::stat_names[] = {$/;"	m	class:sm_stats_t	file:
state	lock_raw.h	/^    LockState                   state;$/;"	m	struct:RawLock
state	lock_raw.h	/^    XctState                    state;$/;"	m	struct:RawXct
state	logrec.h	/^    smlevel_0::xct_state_t        state;$/;"	m	struct:chkpt_xct_tab_t::xrec_t
state	plog.h	/^    state_t     state;$/;"	m	class:plog_t
state	xct.h	/^xct_t::state() const$/;"	f	class:xct_t
state_t	plog.h	/^    enum state_t {$/;"	g	class:plog_t
state_t	xct.h	/^    typedef xct_state_t           state_t;$/;"	t	class:xct_t
state_xct	sm.cpp	/^ss_m::xct_state_t ss_m::state_xct(const xct_t* x)$/;"	f	class:ss_m
statistics_enabled	sm.cpp	/^bool        smlevel_0::statistics_enabled = true;$/;"	m	class:smlevel_0	file:
statistics_enabled	sm_base.h	/^    static bool         statistics_enabled;$/;"	m	class:smlevel_0
stats_audit_failed	sm_du_stats.cpp	/^stats_audit_failed(int$/;"	f	file:
stats_ref	xct.h	/^    sm_stats_info_t&            stats_ref() { return *__stats; }$/;"	f	class:xct_t
status	backup_reader.h	/^    int* status;$/;"	m	class:BackupPrefetcher
steal	xct.cpp	/^xct_t::steal(xct_log_t*&x)$/;"	f	class:xct_t
steal_ownership	bf_tree.h	/^    void steal_ownership (pin_for_refix_holder& h) {$/;"	f	class:pin_for_refix_holder
steal_stats	xct.h	/^    sm_stats_info_t*            steal_stats() {$/;"	f	class:xct_t
stid	generic_page.h	/^    stid_t      stid()  const { return stid_t(vol(), store()); }$/;"	f	class:generic_page_h
stid	logrec.h	/^logrec_t::stid() const$/;"	f	class:logrec_t
stid	xct.h	/^    stid_t        stid;$/;"	m	class:stid_list_elem_t
stid_list_elem_t	xct.h	/^    stid_list_elem_t(const stid_t& theStid)$/;"	f	class:stid_list_elem_t
stid_list_elem_t	xct.h	/^class stid_list_elem_t  {$/;"	c
stids	logrec.h	/^    stid_t            stids[max];$/;"	m	struct:prepare_stores_to_free_t
stnode	stnode_page.h	/^    stnode_t stnode[max];$/;"	m	class:stnode_page
stnode_cache_t	stnode_page.cpp	/^stnode_cache_t::stnode_cache_t(vid_t vid, bf_fixed_m* special_pages):$/;"	f	class:stnode_cache_t
stnode_cache_t	stnode_page.h	/^class stnode_cache_t {$/;"	c
stnode_page	stnode_page.h	/^class stnode_page : public generic_page_header {$/;"	c
stnode_page_h	stnode_page.cpp	/^stnode_page_h::stnode_page_h(generic_page* s, const lpid_t& pid):$/;"	f	class:stnode_page_h
stnode_page_h	stnode_page.h	/^    stnode_page_h(generic_page* s) : generic_page_h(s) {$/;"	f	class:stnode_page_h
stnode_page_h	stnode_page.h	/^class stnode_page_h : public generic_page_h {$/;"	c
stnode_t	stnode_page.h	/^    stnode_t() {$/;"	f	struct:stnode_t
stnode_t	stnode_page.h	/^struct stnode_t {$/;"	s
stop	sm.cpp	/^    bool stop;$/;"	m	class:ticker_thread_t	file:
stop_synchronous	lock_raw.cpp	/^void RawLockBackgroundThread::stop_synchronous() {$/;"	f	class:RawLockBackgroundThread
store	generic_page.h	/^    snum_t           store;        \/\/ +4 -> 16$/;"	m	class:generic_page_header
store	generic_page.h	/^    snum_t      store() const { return _pp->store; }$/;"	f	class:generic_page_h
store	lock_s.h	/^inline snum_t lockid_t::store() const $/;"	f	class:lockid_t
store	logrec.h	/^    snum_t    store;    \/\/ +4 -> 12$/;"	m	struct:chkpt_bf_tab_t::brec_t
store	sm.h	/^    snum_t    store;$/;"	m	class:sm_store_info_t
store	sm_s.h	/^    snum_t        store;$/;"	m	class:shrid_t
store_deleting_t	sm_base.h	/^    enum store_deleting_t  {$/;"	g	class:smlevel_0
store_deleting_t	stnode_page.h	/^        typedef smlevel_0::store_deleting_t         store_deleting_t;$/;"	t	class:store_operation_param
store_directory	sm_du_stats.h	/^    btree_stats_t  store_directory;     \/* info about every store *\/$/;"	m	struct:volume_map_stats_t
store_flag_t	sm_base.h	/^    enum store_flag_t {$/;"	g	class:smlevel_0
store_flag_t	stnode_page.h	/^        typedef smlevel_0::store_flag_t             store_flag_t;$/;"	t	class:store_operation_param
store_operation	stnode_page.cpp	/^stnode_cache_t::store_operation(store_operation_param param, bool redo)$/;"	f	class:stnode_cache_t
store_operation	vol.cpp	/^rc_t vol_t::store_operation(const store_operation_param& param, bool redo)$/;"	f	class:vol_t
store_operation_log	logrec.cpp	/^store_operation_log::store_operation_log(vid_t vid,$/;"	f	class:store_operation_log
store_operation_param	stnode_page.h	/^        store_operation_param(snum_t snum, store_operation_t theOp) :$/;"	f	class:store_operation_param
store_operation_param	stnode_page.h	/^        store_operation_param(snum_t snum, store_operation_t theOp,$/;"	f	class:store_operation_param
store_operation_param	stnode_page.h	/^class store_operation_param  {$/;"	c
store_operation_t	sm_base.h	/^    enum store_operation_t {$/;"	g	class:smlevel_0
store_operation_t	stnode_page.h	/^        typedef smlevel_0::store_operation_t        store_operation_t;$/;"	t	class:store_operation_param
store_property_t	sm.h	/^    typedef sm_store_property_t store_property_t;$/;"	t	class:ss_m
subclass_specific	generic_page.h	/^    char subclass_specific[page_sz - sizeof(generic_page_header)];$/;"	m	class:generic_page
suggest_fence_for_split	btree_page_h.cpp	/^void btree_page_h::suggest_fence_for_split(w_keystr_t &mid,$/;"	f	class:btree_page_h
switch_parent	bf_tree.cpp	/^void bf_tree_m::switch_parent(lpid_t pid, generic_page* parent)$/;"	f	class:bf_tree_m
switch_t	sm_base.h	/^    enum switch_t {$/;"	g	class:smlevel_0
swizzle_child	bf_tree.cpp	/^void bf_tree_m::swizzle_child(generic_page* parent, general_recordid_t slot)$/;"	f	class:bf_tree_m
swizzle_children	bf_tree.cpp	/^void bf_tree_m::swizzle_children(generic_page* parent, const general_recordid_t* slots,$/;"	f	class:bf_tree_m
sx_add_backup	vol.cpp	/^rc_t vol_m::sx_add_backup(vid_t vid, string path, bool logit)$/;"	f	class:vol_m
sx_dismount	vol.cpp	/^rc_t vol_m::sx_dismount(const char* device, bool logit)$/;"	f	class:vol_m
sx_format	vol.cpp	/^rc_t vol_m::sx_format($/;"	f	class:vol_m
sx_mount	vol.cpp	/^rc_t vol_m::sx_mount(const char* device, const bool logit)$/;"	f	class:vol_m
sync	vol.cpp	/^rc_t vol_t::sync()$/;"	f	class:vol_t
sync_log	sm.cpp	/^ss_m::sync_log(bool block)$/;"	f	class:ss_m
synch_take	chkpt.cpp	/^void chkpt_m::synch_take()$/;"	f	class:chkpt_m
synch_take	chkpt.cpp	/^void chkpt_m::synch_take(XctLockHeap& lock_heap)$/;"	f	class:chkpt_m
sys_txn	btree_logrec.h	/^    bool        sys_txn;   \/\/ True if the insertion was from a page rebalance full logging operation$/;"	m	struct:btree_insert_t
sys_txn	btree_logrec.h	/^    uint16_t      sys_txn:1,      \/\/ 1 if the insertion was from a page rebalance full logging operation$/;"	m	struct:btree_ghost_t
sys_xct_section_t	xct.cpp	/^sys_xct_section_t::sys_xct_section_t(bool single_log_sys_xct)$/;"	f	class:sys_xct_section_t
sys_xct_section_t	xct.h	/^class sys_xct_section_t {$/;"	c
sysevent	eventlog.h	/^class sysevent {$/;"	c
sysevent_timer	eventlog.h	/^class sysevent_timer {$/;"	c
t_alloc_p	generic_page.h	/^    t_alloc_p  = 1,        \/\/\/< free-page allocation page$/;"	e	enum:page_tag_t
t_append	sm_base.h	/^        t_append        = 0x01, \/\/ retain sort order (cache 0 pages)$/;"	e	enum:smlevel_0::pg_policy_t
t_bad_cat	logrec.h	/^    t_bad_cat   = 0x00,$/;"	e	enum:logrec_t::category_t
t_bad_p	generic_page.h	/^    t_bad_p    = 0,        \/\/\/< not used$/;"	e	enum:page_tag_t
t_bad_storeproperty	sm_base.h	/^    t_bad_storeproperty = 0x80\/\/ no bits in common with good properties$/;"	e	enum:smlevel_0::sm_store_property_t
t_btree_p	generic_page.h	/^    t_btree_p  = 5,        \/\/\/< btree page$/;"	e	enum:page_tag_t
t_cache	sm_base.h	/^        t_cache        = 0x02, \/\/ look in n cached pgs$/;"	e	enum:smlevel_0::pg_policy_t
t_cc_append	sm_base.h	/^        t_cc_append$/;"	e	enum:smlevel_0::concurrency_t
t_cc_bad	sm_base.h	/^        t_cc_bad,                \/\/ this is an illegal value$/;"	e	enum:smlevel_0::concurrency_t
t_cc_keyrange	sm_base.h	/^        t_cc_keyrange,$/;"	e	enum:smlevel_0::concurrency_t
t_cc_none	sm_base.h	/^        t_cc_none,                \/\/ no locking$/;"	e	enum:smlevel_0::concurrency_t
t_cc_store	sm_base.h	/^        t_cc_store,$/;"	e	enum:smlevel_0::concurrency_t
t_cc_vol	sm_base.h	/^        t_cc_vol,$/;"	e	enum:smlevel_0::concurrency_t
t_chain	xct.h	/^    enum commit_t { t_normal = 0, t_lazy = 1, t_chain = 2, t_group = 4 };$/;"	e	enum:xct_t::commit_t
t_chkpt_async	chkpt.h	/^        t_chkpt_async    \/\/ in the middle of asynchronous checkpoint$/;"	e	enum:chkpt_m::chkpt_mode_t
t_chkpt_none	chkpt.h	/^        t_chkpt_none,    \/\/ no on-going checkpoint$/;"	e	enum:chkpt_m::chkpt_mode_t
t_chkpt_sync	chkpt.h	/^        t_chkpt_sync,    \/\/ in the middle of synchronous checkpoint$/;"	e	enum:chkpt_m::chkpt_mode_t
t_compact	sm_base.h	/^        t_compact        = 0x04 \/\/ scan file for space in pages$/;"	e	enum:smlevel_0::pg_policy_t
t_concurrent_before	sm_base.h	/^        t_concurrent_before,  \/\/ before REDO and UNDO$/;"	e	enum:smlevel_0::concurrent_restart_mode_t
t_concurrent_done	sm_base.h	/^        t_concurrent_done     \/\/ after REDO and UNDO$/;"	e	enum:smlevel_0::concurrent_restart_mode_t
t_concurrent_redo	sm_base.h	/^        t_concurrent_redo,    \/\/ working on REDO$/;"	e	enum:smlevel_0::concurrent_restart_mode_t
t_concurrent_undo	sm_base.h	/^        t_concurrent_undo,    \/\/ working on UNDO$/;"	e	enum:smlevel_0::concurrent_restart_mode_t
t_cpsn	logrec.h	/^    t_cpsn      = 0x20,$/;"	e	enum:logrec_t::category_t
t_create_store	sm_base.h	/^            t_create_store,$/;"	e	enum:smlevel_0::store_operation_t
t_delete_store	sm_base.h	/^            t_delete_store,$/;"	e	enum:smlevel_0::store_operation_t
t_deleting_store	sm_base.h	/^            t_deleting_store,$/;"	e	enum:smlevel_0::store_deleting_t
t_fence_contain	btree_impl.h	/^        t_fence_contain,$/;"	e	enum:btree_impl::traverse_mode_t
t_fence_high_match	btree_impl.h	/^        t_fence_high_match$/;"	e	enum:btree_impl::traverse_mode_t
t_fence_low_match	btree_impl.h	/^        t_fence_low_match,$/;"	e	enum:btree_impl::traverse_mode_t
t_follow_foster	btree_impl.h	/^        t_follow_foster = -2,$/;"	e	enum:btree_impl::slot_follow_t
t_follow_invalid	btree_impl.h	/^        t_follow_invalid = -3,$/;"	e	enum:btree_impl::slot_follow_t
t_follow_pid0	btree_impl.h	/^        t_follow_pid0 = -1$/;"	e	enum:btree_impl::slot_follow_t
t_forward_processing	sm_base.h	/^        t_forward_processing = 0x8   \/\/ System is opened for transaction$/;"	e	enum:smlevel_0::operating_mode_t
t_group	xct.h	/^    enum commit_t { t_normal = 0, t_lazy = 1, t_chain = 2, t_group = 4 };$/;"	e	enum:xct_t::commit_t
t_in_analysis	sm_base.h	/^        t_in_analysis = 0x1,$/;"	e	enum:smlevel_0::operating_mode_t
t_in_redo	sm_base.h	/^        t_in_redo = 0x2,$/;"	e	enum:smlevel_0::operating_mode_t
t_in_undo	sm_base.h	/^        t_in_undo = 0x4,$/;"	e	enum:smlevel_0::operating_mode_t
t_insert_file	sm_base.h	/^    t_insert_file = 0x08,$/;"	e	enum:smlevel_0::sm_store_property_t
t_lazy	xct.h	/^    enum commit_t { t_normal = 0, t_lazy = 1, t_chain = 2, t_group = 4 };$/;"	e	enum:xct_t::commit_t
t_load_file	sm_base.h	/^    t_load_file    = 0x4,$/;"	e	enum:smlevel_0::sm_store_property_t
t_logical	logrec.h	/^    t_logical   = 0x10,$/;"	e	enum:logrec_t::category_t
t_multi	logrec.h	/^    t_multi     = 0x08,$/;"	e	enum:logrec_t::category_t
t_normal	xct.h	/^    enum commit_t { t_normal = 0, t_lazy = 1, t_chain = 2, t_group = 4 };$/;"	e	enum:xct_t::commit_t
t_not_deleting_store	sm_base.h	/^            t_not_deleting_store = 0,  \/\/ must be 0: code assumes it$/;"	e	enum:smlevel_0::store_deleting_t
t_not_started	sm_base.h	/^        t_not_started = 0,$/;"	e	enum:smlevel_0::operating_mode_t
t_redo	logrec.h	/^    t_redo      = 0x04,$/;"	e	enum:logrec_t::category_t
t_regular	sm_base.h	/^    t_regular     = 0x1,$/;"	e	enum:smlevel_0::sm_store_property_t
t_restart_alt_rebalance	sm_base.h	/^        t_restart_alt_rebalance = 0x8000,  \/\/ Alternative implementation for page driven REDO with$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_aries_open	sm_base.h	/^        t_restart_aries_open = 0x4000,     \/\/ M5 implementation:$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_concurrent_lock	sm_base.h	/^        t_restart_concurrent_lock = 0x200, \/\/ M3, M4 and M5 implementation:$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_concurrent_log	sm_base.h	/^        t_restart_concurrent_log = 0x8,    \/\/ M2 implementation:$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_disable	sm_base.h	/^        t_restart_disable = 0,$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_phase_active	sm_external.h	/^    t_restart_phase_active,       \/\/ The phase is currently active$/;"	e	enum:restart_phase_t
t_restart_phase_done	sm_external.h	/^    t_restart_phase_done          \/\/ The phase is done$/;"	e	enum:restart_phase_t
t_restart_phase_not_active	sm_external.h	/^    t_restart_phase_not_active,   \/\/ The phase is currently not active, not started yet$/;"	e	enum:restart_phase_t
t_restart_phase_unknown	sm_external.h	/^    t_restart_phase_unknown,      \/\/ unknown status, mainly for M3 pure on-demand REDO and UNDO$/;"	e	enum:restart_phase_t
t_restart_redo_delay	sm_base.h	/^        t_restart_redo_delay = 0x80,       \/\/ M2 Testing hook:$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_redo_demand	sm_base.h	/^        t_restart_redo_demand = 0x400,     \/\/ M3 implementation:$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_redo_full_logging	sm_base.h	/^        t_restart_redo_full_logging = 0x20,\/\/ M2 implementation:$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_redo_log	sm_base.h	/^        t_restart_redo_log = 0x2,          \/\/ M1 traditional implementation:$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_redo_mix	sm_base.h	/^        t_restart_redo_mix = 0x1000,       \/\/ M4 and M5 implementation:$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_redo_page	sm_base.h	/^        t_restart_redo_page = 0x10,        \/\/ M2 implementation:$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_serial	sm_base.h	/^        t_restart_serial = 0x1,            \/\/ M1 implementation:$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_undo_delay	sm_base.h	/^        t_restart_undo_delay = 0x100,      \/\/ M2 Testing hook:$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_undo_demand	sm_base.h	/^        t_restart_undo_demand = 0x800,     \/\/ M3 implementation:$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_undo_mix	sm_base.h	/^        t_restart_undo_mix = 0x2000,       \/\/ M4 and M5 implementation:$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_undo_reverse	sm_base.h	/^        t_restart_undo_reverse = 0x4,      \/\/ M1 traditional implementation:$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_restart_undo_txn	sm_base.h	/^        t_restart_undo_txn = 0x40,         \/\/ M2 implementation:$/;"	e	enum:smlevel_0::restart_internal_mode_t
t_rollback	logrec.h	/^    t_rollback  = 0x40,$/;"	e	enum:logrec_t::category_t
t_set_deleting	sm_base.h	/^            t_set_deleting,$/;"	e	enum:smlevel_0::store_operation_t
t_set_root	sm_base.h	/^            t_set_root};$/;"	e	enum:smlevel_0::store_operation_t
t_set_store_flags	sm_base.h	/^            t_set_store_flags,$/;"	e	enum:smlevel_0::store_operation_t
t_single_sys_xct	logrec.h	/^    t_single_sys_xct    = 0x80$/;"	e	enum:logrec_t::category_t
t_status	logrec.h	/^    t_status    = 0x01,$/;"	e	enum:logrec_t::category_t
t_stnode_p	generic_page.h	/^    t_stnode_p = 2,        \/\/\/< store node page$/;"	e	enum:page_tag_t
t_temporary	sm_base.h	/^    t_temporary    = 0x2,$/;"	e	enum:smlevel_0::sm_store_property_t
t_to_be_deleted	generic_page.h	/^    t_to_be_deleted  = 0x01,     \/\/\/< this page will be deleted as soon as the page is evicted from bufferpool$/;"	e	enum:page_flag_t
t_undo	logrec.h	/^    t_undo      = 0x02,$/;"	e	enum:logrec_t::category_t
t_unknown_deleting	sm_base.h	/^            t_unknown_deleting};$/;"	e	enum:smlevel_0::store_deleting_t
tag	generic_page.h	/^    page_tag_t    tag()   const { return (page_tag_t) _pp->tag; }$/;"	f	class:generic_page_h
tag	generic_page.h	/^    uint16_t         tag;          \/\/ +2 -> 34$/;"	m	class:generic_page_header
tag	logrec.h	/^logrec_t::tag() const$/;"	f	class:logrec_t
tag	mem_mgmt.h	/^        uint16_t tag;$/;"	m	class:fixed_lists_mem_t::list_header_t
tail	lock_raw.cpp	/^RawLock* RawLockQueue::tail() const {$/;"	f	class:RawLockQueue
take	chkpt.cpp	/^void chkpt_m::take(chkpt_mode_t chkpt_mode,$/;"	f	class:chkpt_m
take	xct.cpp	/^    lil_private_table* take() {$/;"	f	struct:lil_lock_info_ptr
take	xct.cpp	/^    xct_lock_info_t* take() {$/;"	f	struct:lock_info_ptr
takeBackup	restore.h	/^    bool takeBackup;$/;"	m	class:RestoreMgr
take_backup	vol.cpp	/^rc_t vol_t::take_backup(string path, bool flushArchive)$/;"	f	class:vol_t
take_space	log_resv.cpp	/^fileoff_t log_resv::take_space(fileoff_t *ptr, int amt)$/;"	f	class:log_resv
tcb	smthread.h	/^    inline const tcb_t     &tcb() const {$/;"	f	class:smthread_t
tcb	smthread.h	/^    inline tcb_t           &tcb() {$/;"	f	class:smthread_t
tcb_t	smthread.h	/^        tcb_t(tcb_t* outer) : $/;"	f	struct:smthread_t::tcb_t
tcb_t	smthread.h	/^    struct tcb_t {$/;"	s	class:smthread_t
test	xct.h	/^    w_rc_t test(int x) { _test=x;$/;"	f	class:auto_rollback_t
thread_collect	vtable_sm.cpp	/^ss_m::thread_collect( vtable_t & res, bool names_too) $/;"	f	class:ss_m
thread_id	lock_raw.h	/^    gc_thread_id                thread_id;$/;"	m	struct:RawXct
thread_type	smthread.h	/^    virtual int            thread_type() { return smThreadType; }$/;"	f	class:smthread_t
ticker_thread_t	sm.cpp	/^    ticker_thread_t(bool msec = false)$/;"	f	class:ticker_thread_t
ticker_thread_t	sm.cpp	/^class ticker_thread_t : public smthread_t$/;"	c	file:
tid	lock_x.h	/^    tid_t            tid() const { return _tid; }$/;"	f	class:xct_lock_info_t
tid	logrec.h	/^        tid_t                 tid;$/;"	m	struct:xct_list_t::xrec_t
tid	logrec.h	/^    tid_t                 tid;$/;"	m	struct:chkpt_xct_tab_t::xrec_t
tid	logrec.h	/^    tid_t            tid;    \/\/ owning transaction tid$/;"	m	struct:chkpt_xct_lock_t
tid	logrec.h	/^logrec_t::tid() const$/;"	f	class:logrec_t
tid	restart.h	/^    tid_t      tid;          \/\/ Owning transaction id of the lock$/;"	m	struct:comp_lock_info_t
tid	sm.h	/^    tid_t            tid() const { return _tid; }$/;"	f	class:sm_save_point_t
tid	xct.h	/^    tid_t                       tid() const {$/;"	f	class:xct_t
tid_CLR_map	restart.h	/^typedef std::map<uint64_t, signed int> tid_CLR_map;$/;"	t
tid_to_xct	sm.cpp	/^xct_t* ss_m::tid_to_xct(const tid_t& tid)$/;"	f	class:ss_m
timeout_c	xct.cpp	/^xct_t::timeout_c() const {$/;"	f	class:xct_t
timeout_in_ms	smthread.h	/^typedef sthread_t::timeout_in_ms timeout_in_ms;$/;"	t
timestamp	eventlog.h	/^    static unsigned long timestamp()$/;"	f	class:sysevent_timer
timestamp_to_str	eventlog.h	/^    static std::string timestamp_to_str()$/;"	f	class:sysevent_timer
tls_lock_pool_next	lock_core.cpp	/^__thread gc_pointer_raw tls_lock_pool_next; \/\/ Thread local variable for lock_pool.$/;"	v
tls_xct_pool_next	lock_core.cpp	/^__thread gc_pointer_raw tls_xct_pool_next; \/\/ Thread local variable for xct_pool.$/;"	v
toSkip	logarchiver.h	/^    size_t toSkip;$/;"	m	class:LogScanner
to_lil_mode	lock.cpp	/^lil_lock_modes_t to_lil_mode (okvl_mode::element_lock_mode m) {$/;"	f
top	logarchiver.cpp	/^logrec_t* LogArchiver::ArchiverHeap::top()$/;"	f	class:LogArchiver::ArchiverHeap
topRun	logarchiver.h	/^        int topRun() { return w_heap.First().run; }$/;"	f	class:LogArchiver::ArchiverHeap
total_bytes	sm_du_stats.cpp	/^btree_int_stats_t::total_bytes() const$/;"	f	class:btree_int_stats_t
total_bytes	sm_du_stats.cpp	/^btree_lf_stats_t::total_bytes() const$/;"	f	class:btree_lf_stats_t
total_bytes	sm_du_stats.cpp	/^btree_stats_t::total_bytes() const$/;"	f	class:btree_stats_t
total_bytes	sm_du_stats.cpp	/^sm_du_stats_t::total_bytes() const$/;"	f	class:sm_du_stats_t
total_bytes	sm_du_stats.cpp	/^volume_hdr_stats_t::total_bytes() const$/;"	f	class:volume_hdr_stats_t
total_bytes	sm_du_stats.cpp	/^volume_map_stats_t::total_bytes() const$/;"	f	class:volume_map_stats_t
total_data_size	btree_logrec.h	/^    size_t        total_data_size;$/;"	m	struct:btree_ghost_t
touch	btree.cpp	/^rc_t btree_m::touch(const btree_page_h& page, uint64_t &page_count) {$/;"	f	class:btree_m
touch_all	btree.cpp	/^rc_t btree_m::touch_all(stid_t stid, uint64_t &page_count) {$/;"	f	class:btree_m
touch_index	smindex.cpp	/^rc_t ss_m::touch_index(stid_t stid, uint64_t &page_count)$/;"	f	class:ss_m
transit_bucket_t	bf_transit_bucket.h	/^    NORET transit_bucket_t()$/;"	f	class:transit_bucket_t
transit_bucket_t	bf_transit_bucket.h	/^class transit_bucket_t$/;"	c
traverse_mode_t	btree_impl.h	/^    enum traverse_mode_t {$/;"	g	class:btree_impl
trigger_UNDO	lock_raw.cpp	/^bool RawLockQueue::trigger_UNDO(Compatibility& compatibility)$/;"	f	class:RawLockQueue
truncBuf	logarchiver.h	/^    char* truncBuf;$/;"	m	class:LogScanner
truncCopied	logarchiver.h	/^    size_t truncCopied;$/;"	m	class:LogScanner
truncMissing	logarchiver.h	/^    size_t truncMissing;$/;"	m	class:LogScanner
truncate_all	btree_page.cpp	/^void btree_page_data::truncate_all(size_t amount, size_t pos)$/;"	f	class:btree_page_data
trySinglePass	restore.h	/^    bool trySinglePass;$/;"	m	class:RestoreScheduler
type	logrec.h	/^logrec_t::type() const$/;"	f	class:logrec_t
type_str	logrec.cpp	/^const char *logrec_accounting_impl_t::type_str(int _type) {$/;"	f	class:logrec_accounting_impl_t
type_str	logrec.h	/^    const char*          type_str() const$/;"	f	class:logrec_t
unalloc_ext_cnt	sm_du_stats.h	/^    base_stat_t        unalloc_ext_cnt;    \/* # of unallocated extents *\/$/;"	m	struct:volume_hdr_stats_t
unalloc_pg_cnt	sm_du_stats.cpp	/^volume_map_stats_t::unalloc_pg_cnt() const$/;"	f	class:volume_map_stats_t
unalloc_pg_cnt	sm_du_stats.h	/^    base_stat_t     unalloc_pg_cnt; \/\/ pages not-allocated by extent-traversal$/;"	m	struct:btree_stats_t
undo	btree_logrec.cpp	/^btree_ghost_mark_log::undo(fixable_page_h*)$/;"	f	class:btree_ghost_mark_log
undo	btree_logrec.cpp	/^btree_insert_log::undo(fixable_page_h* page) {$/;"	f	class:btree_insert_log
undo	btree_logrec.cpp	/^btree_update_log::undo(fixable_page_h*)$/;"	f	class:btree_update_log
undo	btree_logrec.cpp	/^void btree_insert_nonghost_log::undo(fixable_page_h* page) {$/;"	f	class:btree_insert_nonghost_log
undo	btree_logrec.cpp	/^void btree_overwrite_log::undo(fixable_page_h*)$/;"	f	class:btree_overwrite_log
undo	logrec.cpp	/^comment_log::undo(fixable_page_h *page)$/;"	f	class:comment_log
undo	logrec.cpp	/^logrec_t::undo(fixable_page_h* page)$/;"	f	class:logrec_t
undo	logrec.cpp	/^void page_img_format_log::undo(fixable_page_h*) {$/;"	f	class:page_img_format_log
undo	logrec.cpp	/^void page_set_to_be_deleted_log::undo(fixable_page_h* page)$/;"	f	class:page_set_to_be_deleted_log
undo	logrec.cpp	/^void store_operation_log::undo(fixable_page_h* \/*page*\/)$/;"	f	class:store_operation_log
undo_concurrent_pass	restart.cpp	/^void restart_m::undo_concurrent_pass()$/;"	f	class:restart_m
undo_ghost_mark	btree.cpp	/^btree_m::undo_ghost_mark(stid_t store, const w_keystr_t &key)$/;"	f	class:btree_m
undo_in_progress	restart.h	/^    bool                        undo_in_progress()$/;"	f	class:restart_m
undo_nxt	logrec.h	/^    lsn_t                undo_nxt;$/;"	m	struct:chkpt_xct_tab_t::xrec_t
undo_nxt	logrec.h	/^logrec_t::undo_nxt() const$/;"	f	class:logrec_t
undo_nxt	xct.h	/^xct_t::undo_nxt() const$/;"	f	class:xct_t
undo_reverse_pass	restart.cpp	/^restart_m::undo_reverse_pass($/;"	f	class:restart_m
undoing_context	logrec.cpp	/^static __thread logrec_t::kind_t undoing_context = logrec_t::t_max_logrec; \/\/ for accounting TODO REMOVE$/;"	v	file:
unfix	backup_reader.cpp	/^void BackupOnDemandReader::unfix(unsigned segment)$/;"	f	class:BackupOnDemandReader
unfix	backup_reader.cpp	/^void BackupPrefetcher::unfix(unsigned segment)$/;"	f	class:BackupPrefetcher
unfix	backup_reader.h	/^    virtual void unfix(unsigned)$/;"	f	class:DummyBackupReader
unfix	bf_tree.cpp	/^void bf_tree_m::unfix(const generic_page* p) {$/;"	f	class:bf_tree_m
unfix	fixable_page_h.cpp	/^void fixable_page_h::unfix() {$/;"	f	class:fixable_page_h
uninit	lock_raw.cpp	/^void RawXct::uninit() {$/;"	f	class:RawXct
uninstall_volume	bf_tree.cpp	/^w_rc_t bf_tree_m::uninstall_volume(vid_t vid,$/;"	f	class:bf_tree_m
unique_cnt	sm_du_stats.h	/^    base_stat_t        unique_cnt;        \/* number of unique entries *\/$/;"	m	struct:btree_lf_stats_t
unique_vols	xct.cpp	/^        int unique_vols;$/;"	m	class:VolidCnt	file:
unlink_pg_cnt	sm_du_stats.cpp	/^volume_map_stats_t::unlink_pg_cnt() const$/;"	f	class:volume_map_stats_t
unlink_pg_cnt	sm_du_stats.h	/^    base_stat_t     unlink_pg_cnt; \/\/ pages allocated but not accounted-for$/;"	m	struct:btree_stats_t
unlock	lock.cpp	/^void lock_m::unlock(RawLock* lock, lsn_t commit_lsn) {$/;"	f	class:lock_m
unlock	plog.h	/^    void unlock()$/;"	f	class:plog_t
unlock_duration	lock.cpp	/^rc_t lock_m::unlock_duration($/;"	f	class:lock_m
unmark_ghost	btree_page_h.cpp	/^void btree_page_h::unmark_ghost(slotid_t slot) {$/;"	f	class:btree_page_h
unpin	bf_tree_cb.h	/^    void unpin()$/;"	f	struct:bf_tree_cb_t
unpin	restore.h	/^    void unpin() {$/;"	f	class:RestoreMgr
unpin_for_refix	bf_tree.cpp	/^void bf_tree_m::unpin_for_refix(bf_idx idx) {$/;"	f	class:bf_tree_m
unsafe_iterator	xct.h	/^    w_list_i<xct_t,queue_based_lock_t> unsafe_iterator;$/;"	m	class:xct_i
unsetIgnore	logarchiver.h	/^    void unsetIgnore(logrec_t::kind_t type) {$/;"	f	class:LogScanner
unset_bit	alloc_page.h	/^    void unset_bit(uint32_t index) { bitmap[byte_place(index)] &= ~bit_mask(index); }$/;"	f	class:alloc_page
unset_bit	alloc_page.h	/^inline void alloc_page_h::unset_bit(shpid_t pid)$/;"	f	class:alloc_page_h
unset_current	log_storage.cpp	/^log_storage::unset_current()$/;"	f	class:log_storage
unset_ghost	btree_page.cpp	/^void btree_page_data::unset_ghost(int item) {$/;"	f	class:btree_page_data
unset_to_be_deleted	fixable_page_h.cpp	/^void fixable_page_h::unset_to_be_deleted() {$/;"	f	class:fixable_page_h
unused_bs	sm_du_stats.h	/^    base_stat_t        unused_bs;$/;"	m	struct:btree_int_stats_t
unused_bs	sm_du_stats.h	/^    base_stat_t        unused_bs;$/;"	m	struct:btree_lf_stats_t
unused_part	btree_page.cpp	/^char* btree_page_data::unused_part(size_t& length) {$/;"	f	class:btree_page_data
update	bf_hashtable.cpp	/^bool bf_hashbucket<T>::update (uint64_t key, T value) {$/;"	f	class:bf_hashbucket
update	bf_hashtable.cpp	/^bool bf_hashtable<T>::update(uint64_t key, T value) {$/;"	f	class:bf_hashtable
update	btree.cpp	/^rc_t btree_m::update($/;"	f	class:btree_m
update_as_undo	btree.cpp	/^rc_t btree_m::update_as_undo(stid_t store, const w_keystr_t &key, const cvec_t &elem)$/;"	f	class:btree_m
update_assoc	smindex.cpp	/^rc_t ss_m::update_assoc(stid_t stid, const w_keystr_t& key, const vec_t& el)$/;"	f	class:ss_m
update_clsn	fixable_page_h.cpp	/^void fixable_page_h::update_clsn(const lsn_t& lsn)$/;"	f	class:fixable_page_h
update_footer	mem_mgmt.h	/^        void update_footer() {$/;"	f	class:fixed_lists_mem_t::list_header_t
update_initial_and_last_lsn	fixable_page_h.cpp	/^void fixable_page_h::update_initial_and_last_lsn(const lsn_t & lsn) const$/;"	f	class:fixable_page_h
update_initial_dirty_lsn	bf_tree.cpp	/^void bf_tree_m::update_initial_dirty_lsn(const generic_page* p,$/;"	f	class:bf_tree_m
update_initial_dirty_lsn	fixable_page_h.cpp	/^void fixable_page_h::update_initial_dirty_lsn(const lsn_t & lsn) const$/;"	f	class:fixable_page_h
update_pid_highwatermark	alloc_page.h	/^inline void alloc_page_h::update_pid_highwatermark(shpid_t pid_touched) {$/;"	f	class:alloc_page_h
update_read_watermark	lock_raw.h	/^    void                        update_read_watermark(const lsn_t &tag) {$/;"	f	struct:RawXct
update_read_watermark	xct.h	/^    void                        update_read_watermark(const lsn_t &tag) {$/;"	f	class:xct_t
update_threads	xct.cpp	/^xct_t::update_threads() const$/;"	f	class:xct_t
update_x_lock_tag	lock_bucket.h	/^    inline void update_x_lock_tag (const lsn_t &new_tag) {$/;"	f	class:lock_queue_t
update_xlock_tag	lock_raw.cpp	/^void RawLockQueue::update_xlock_tag(const lsn_t& commit_lsn) {$/;"	f	class:RawLockQueue
update_youngest_tid	xct.cpp	/^xct_t::update_youngest_tid(const tid_t &t)$/;"	f	class:xct_t
upgrade_latch_conditional	bf_tree.cpp	/^bool bf_tree_m::upgrade_latch_conditional(const generic_page* p) {$/;"	f	class:bf_tree_m
upgrade_latch_conditional	fixable_page_h.cpp	/^bool fixable_page_h::upgrade_latch_conditional(latch_mode_t mode) {$/;"	f	class:fixable_page_h
usable_space	btree_page.h	/^inline size_t btree_page_data::usable_space() const {$/;"	f	class:btree_page_data
usable_space	btree_page_h.h	/^btree_page_h::usable_space() const {$/;"	f	class:btree_page_h
useBackup	restore.h	/^    bool useBackup;$/;"	m	class:RestoreMgr
use_alt_rebalance	sm_base.h	/^    static bool use_alt_rebalance()$/;"	f	class:smlevel_0
use_aries_restart	sm_base.h	/^    static bool use_aries_restart()$/;"	f	class:smlevel_0
use_concurrent_commit_restart	sm_base.h	/^    static bool use_concurrent_commit_restart()$/;"	f	class:smlevel_0
use_concurrent_lock_restart	sm_base.h	/^    static bool use_concurrent_lock_restart()$/;"	f	class:smlevel_0
use_redo_delay_restart	sm_base.h	/^    static bool use_redo_delay_restart()$/;"	f	class:smlevel_0
use_redo_demand_restart	sm_base.h	/^    static bool use_redo_demand_restart()$/;"	f	class:smlevel_0
use_redo_full_logging_restart	sm_base.h	/^    static bool use_redo_full_logging_restart()$/;"	f	class:smlevel_0
use_redo_log_restart	sm_base.h	/^    static bool use_redo_log_restart()$/;"	f	class:smlevel_0
use_redo_mix_restart	sm_base.h	/^    static bool use_redo_mix_restart()$/;"	f	class:smlevel_0
use_redo_page_restart	sm_base.h	/^    static bool use_redo_page_restart()$/;"	f	class:smlevel_0
use_serial_restart	sm_base.h	/^    static bool use_serial_restart()$/;"	f	class:smlevel_0
use_undo_delay_restart	sm_base.h	/^    static bool use_undo_delay_restart()$/;"	f	class:smlevel_0
use_undo_demand_restart	sm_base.h	/^    static bool use_undo_demand_restart()$/;"	f	class:smlevel_0
use_undo_mix_restart	sm_base.h	/^    static bool use_undo_mix_restart()$/;"	f	class:smlevel_0
use_undo_reverse_restart	sm_base.h	/^    static bool use_undo_reverse_restart()$/;"	f	class:smlevel_0
use_undo_txn_restart	sm_base.h	/^    static bool use_undo_txn_restart()$/;"	f	class:smlevel_0
used_bs	sm_du_stats.h	/^    base_stat_t        used_bs;$/;"	m	struct:btree_int_stats_t
used_size	plog.h	/^    uint32_t used_size() { return _used_size; }$/;"	f	class:plog_t
used_space	btree_page_h.h	/^btree_page_h::used_space() const {$/;"	f	class:btree_page_h
valid	crash.cpp	/^        bool          valid;$/;"	m	struct:debuginfo	file:
valid	sm_s.cpp	/^bool lpid_t::valid() const$/;"	f	class:lpid_t
valid_header	logrec.cpp	/^logrec_t::valid_header(const lsn_t & lsn) const$/;"	f	class:logrec_t
value	crash.cpp	/^        int           value;$/;"	m	struct:debuginfo	file:
values	bf_hashtable.cpp	/^    T   values[HASHBUCKET_INITIAL_CHUNK_SIZE];$/;"	m	struct:bf_hashbucket_chunk	file:
values	bf_hashtable.cpp	/^    T*   values;$/;"	m	struct:bf_hashbucket_chunk_linked	file:
values	logbuf_hashtable.cpp	/^    logbuf_seg **values;$/;"	m	struct:logbuf_hashbucket_chunk_linked	file:
values	logbuf_hashtable.cpp	/^    logbuf_seg*   values[HASHBUCKET_INITIAL_CHUNK_SIZE];$/;"	m	struct:logbuf_hashbucket_chunk	file:
values	stnode_page.h	/^            } values;$/;"	m	union:store_operation_param::__anon44	typeref:struct:store_operation_param::__anon44::__anon45
verification_context	btree_impl_verify.cpp	/^verification_context::verification_context (int hash_bits)$/;"	f	class:verification_context
verification_context	btree_verify.h	/^class verification_context {$/;"	c
verify_block	mem_mgmt.cpp	/^void fixed_lists_mem_t::verify_block(void* addr)$/;"	f	class:fixed_lists_mem_t
verify_blocks	mem_mgmt.cpp	/^void fixed_lists_mem_t::verify_blocks()$/;"	f	class:fixed_lists_mem_t
verify_chkpt_reservation	log_resv.cpp	/^bool log_resv::verify_chkpt_reservation()$/;"	f	class:log_resv
verify_index	smindex.cpp	/^rc_t ss_m::verify_index(stid_t stid, int hash_bits, bool &consistent)$/;"	f	class:ss_m
verify_lists	mem_mgmt.cpp	/^void fixed_lists_mem_t::verify_lists()$/;"	f	class:fixed_lists_mem_t
verify_neighbor	mem_mgmt.cpp	/^void fixed_lists_mem_t::verify_neighbor$/;"	f	class:fixed_lists_mem_t
verify_tree	btree.cpp	/^rc_t btree_m::verify_tree($/;"	f	class:btree_m
verify_volume	btree.cpp	/^rc_t btree_m::verify_volume($/;"	f	class:btree_m
verify_volume	sm.cpp	/^rc_t ss_m::verify_volume($/;"	f	class:ss_m
verify_volume_result	btree_impl_verify.cpp	/^verify_volume_result::verify_volume_result ()$/;"	f	class:verify_volume_result
verify_volume_result	btree_verify.h	/^class verify_volume_result {$/;"	c
version	vol.h	/^    uint32_t   version;$/;"	m	class:volhdr_t
vid	lock_s.h	/^inline vid_t lockid_t::vid() const $/;"	f	class:lockid_t
vid	logrec.h	/^    vid_t vid;$/;"	m	struct:chkpt_restore_tab_t
vid	logrec.h	/^logrec_t::vid() const$/;"	f	class:logrec_t
vid	vol.h	/^    vid_t       vid() const { return _vid; }$/;"	f	class:vol_t
vid	vol.h	/^    vid_t      vid;$/;"	m	class:volhdr_t
vol	generic_page.h	/^    vid_t       vol()   const { return _pp->pid.vol(); }$/;"	f	class:generic_page_h
vol	sm.cpp	/^vol_m* smlevel_0::vol = 0;$/;"	m	class:smlevel_0	file:
vol	sm_base.h	/^    static vol_m* vol;$/;"	m	class:smlevel_0
vol	sm_s.h	/^    vid_t         vol()   const { return _vol;}$/;"	f	class:lpid_t
vol_cnt	vol.h	/^    int    vol_cnt;$/;"	m	class:vol_m
vol_cnts	xct.cpp	/^        snum_t vol_cnts[vol_m::MAX_VOLS];$/;"	m	class:VolidCnt	file:
vol_m	vol.cpp	/^vol_m::vol_m(const sm_options&)$/;"	f	class:vol_m
vol_m	vol.h	/^class vol_m {$/;"	c
vol_map	xct.cpp	/^        int vol_map[vol_m::MAX_VOLS];$/;"	m	class:VolidCnt	file:
vol_t	vol.cpp	/^vol_t::vol_t()$/;"	f	class:vol_t
vol_t	vol.h	/^class vol_t$/;"	c
volhdr_t	vol.h	/^    volhdr_t() {};$/;"	f	class:volhdr_t
volhdr_t	vol.h	/^    volhdr_t(vid_t vid, size_t num_pages, lsn_t backupLSN = lsn_t::null)$/;"	f	class:volhdr_t
volhdr_t	vol.h	/^class volhdr_t {$/;"	c
volume	backup_reader.h	/^    vol_t* volume;$/;"	m	class:BackupOnDemandReader
volume	backup_reader.h	/^    vol_t* volume;$/;"	m	class:BackupPrefetcher
volume	restore.h	/^    vol_t* volume;$/;"	m	class:RestoreMgr
volume_exists	backup.cpp	/^bool BackupManager::volume_exists(vid_t vid) {$/;"	f	class:BackupManager
volume_hdr	sm_du_stats.h	/^    volume_hdr_stats_t     volume_hdr;    \/* header extent info *\/$/;"	m	struct:sm_du_stats_t
volume_hdr_stats_t	sm_du_stats.h	/^    NORET        volume_hdr_stats_t() {clear();}$/;"	f	struct:volume_hdr_stats_t
volume_hdr_stats_t	sm_du_stats.h	/^struct volume_hdr_stats_t {$/;"	s
volume_map	sm_du_stats.h	/^    volume_map_stats_t     volume_map;    \/* special volume indexes *\/$/;"	m	struct:sm_du_stats_t
volume_map_stats_t	sm_du_stats.h	/^    NORET          volume_map_stats_t() {clear();}$/;"	f	struct:volume_map_stats_t
volume_map_stats_t	sm_du_stats.h	/^struct volume_map_stats_t {$/;"	s
volumes	vol.h	/^    vol_t* volumes[MAX_VOLS];$/;"	m	class:vol_m
vtable_collect	vtable_smthread.cpp	/^smthread_t::vtable_collect(vtable_row_t& t) $/;"	f	class:smthread_t
vtable_collect	vtable_xct.cpp	/^xct_t::vtable_collect(vtable_row_t &t)$/;"	f	class:xct_t
vtable_collect_names	vtable_smthread.cpp	/^smthread_t::vtable_collect_names(vtable_row_t& t) $/;"	f	class:smthread_t
vtable_collect_names	vtable_xct.cpp	/^xct_t::vtable_collect_names(vtable_row_t &t)$/;"	f	class:xct_t
vthis	log_carray.h	/^    CArraySlot volatile* vthis() { return this; }$/;"	f	struct:CArraySlot
vthis	log_carray.h	/^    const CArraySlot volatile* vthis() const { return this; }$/;"	f	struct:CArraySlot
vthis	log_core.h	/^        epoch volatile* vthis() { return this; }$/;"	f	struct:log_common::epoch
w	lock_s.h	/^        uint32_t w[4]; $/;"	m	union:lockid_t::__anon13
w_heap	logarchiver.h	/^        Heap<HeapEntry, Cmp> w_heap;$/;"	m	class:LogArchiver::ArchiverHeap
wait	ringbuffer.h	/^inline bool AsyncRingBuffer::wait(pthread_cond_t* cond)$/;"	f	class:AsyncRingBuffer
waitForActivation	logarchiver.cpp	/^bool ArchiverControl::waitForActivation()$/;"	f	class:ArchiverControl
waitForActivation	logarchiver.cpp	/^bool LogArchiver::waitForActivation()$/;"	f	class:LogArchiver
waitUntilRestored	restore.cpp	/^bool RestoreMgr::waitUntilRestored(const shpid_t& pid, size_t timeout_in_ms)$/;"	f	class:RestoreMgr
wait_for	lock_raw.cpp	/^w_error_codes RawLockQueue::wait_for(RawLock* new_lock, int32_t timeout_in_ms) {$/;"	f	class:RawLockQueue
wait_for_expose	log_carray.cpp	/^bool ConsolidationArray::wait_for_expose(CArraySlot* info) {$/;"	f	class:ConsolidationArray
wait_for_leader	log_carray.cpp	/^void ConsolidationArray::wait_for_leader(CArraySlot* info) {$/;"	f	class:ConsolidationArray
wait_for_log_space	xct.cpp	/^xct_t::wait_for_log_space(fileoff_t amt) {$/;"	f	class:xct_t
wait_for_space	log_core.h	/^    virtual rc_t                wait_for_space(fileoff_t &amt, int32_t timeout)$/;"	f	class:log_common
wait_for_space	log_resv.cpp	/^rc_t log_resv::wait_for_space(fileoff_t &amt, timeout_in_ms timeout)$/;"	f	class:log_resv
wait_interval	restart.h	/^const uint32_t wait_interval = 1000;   \/\/ 1 seconds$/;"	v
waiting_xct	log_resv.h	/^        NORET waiting_xct(fileoff_t *amt, pthread_cond_t* c)$/;"	f	struct:log_resv::waiting_xct
waiting_xct	log_resv.h	/^    struct waiting_xct {$/;"	s	class:log_resv
wakeup	bf_tree_cleaner.cpp	/^void bf_tree_cleaner_slave_thread_t::wakeup()$/;"	f	class:bf_tree_cleaner_slave_thread_t
wakeup	lock_core.cpp	/^    void wakeup() {$/;"	f	struct:RawLockCleanerFunctor
wakeup	lock_raw.cpp	/^void RawLockBackgroundThread::wakeup() {$/;"	f	class:RawLockBackgroundThread
wakeup_and_take	chkpt.cpp	/^chkpt_m::wakeup_and_take()$/;"	f	class:chkpt_m
wakeup_cleaner_for_volume	bf_tree.cpp	/^w_rc_t bf_tree_m::wakeup_cleaner_for_volume(vid_t vol) {$/;"	f	class:bf_tree_m
wakeup_cleaner_for_volume	bf_tree_cleaner.cpp	/^w_rc_t bf_tree_cleaner::wakeup_cleaner_for_volume(vid_t vol)$/;"	f	class:bf_tree_cleaner
wakeup_cleaners	bf_tree.cpp	/^w_rc_t bf_tree_m::wakeup_cleaners() {$/;"	f	class:bf_tree_m
wakeup_cleaners	bf_tree_cleaner.cpp	/^w_rc_t bf_tree_cleaner::wakeup_cleaners()$/;"	f	class:bf_tree_cleaner
working	restart.h	/^    smlevel_0::concurrent_restart_mode_t working;  \/\/ what is the child working on?$/;"	m	class:restart_thread_t
workspace	logarchiver.h	/^        mem_mgmt_t* workspace;$/;"	m	class:LogArchiver::ArchiverHeap
workspace	restore.cpp	/^        char* workspace;$/;"	m	struct:SegmentWriter::Request	file:
write	vol.cpp	/^rc_t volhdr_t::write(int fd)$/;"	f	class:volhdr_t
writeBuffer	logarchiver.h	/^        char* writeBuffer;$/;"	m	class:LogArchiver::ArchiveIndex
writeSegment	restore.cpp	/^void RestoreMgr::writeSegment(char* workspace, unsigned segment, size_t count)$/;"	f	class:RestoreMgr
write_acquire	chkpt_serial.cpp	/^chkpt_serial_m::write_acquire()$/;"	f	class:chkpt_serial_m
write_backup	vol.cpp	/^rc_t vol_t::write_backup(shpid_t first, size_t count, void* buf)$/;"	f	class:vol_t
write_many_pages	vol.cpp	/^rc_t vol_t::write_many_pages(shpid_t pnum, const generic_page* const pages, int cnt,$/;"	f	class:vol_t
write_metadata	vol.cpp	/^rc_t vol_t::write_metadata(int fd, vid_t vid, size_t num_pages)$/;"	f	class:vol_t
write_page	vol.cpp	/^inline rc_t vol_t::write_page(shpid_t pnum, generic_page& page)$/;"	f	class:vol_t
write_release	chkpt_serial.cpp	/^chkpt_serial_m::write_release()$/;"	f	class:chkpt_serial_m
writebuf	log_core.h	/^    char *          writebuf() { return _writebuf; }$/;"	f	class:log_common
writebuf	logarchiver.h	/^        AsyncRingBuffer* writebuf;$/;"	m	class:LogArchiver::BlockAssembly
writer	logarchiver.h	/^        WriterThread* writer;$/;"	m	class:LogArchiver::BlockAssembly
x_lock_tag	lock_bucket.h	/^    inline const lsn_t& x_lock_tag () const {return _x_lock_tag;}$/;"	f	class:lock_queue_t
x_lock_tag	lock_raw.h	/^    lsn_t                       x_lock_tag;$/;"	m	struct:RawLockQueue
xct	smthread.h	/^        xct_t*   xct;$/;"	m	struct:smthread_t::tcb_t
xct	smthread.h	/^    xct_t*             xct() const { return tcb().xct; }$/;"	f	class:smthread_t
xct	smthread.h	/^    xct_t*             xct() { return tcb().xct; }$/;"	f	class:smthread_t
xct	smthread.h	/^xct() $/;"	f
xct_abort_log	logrec.cpp	/^xct_abort_log::xct_abort_log()$/;"	f	class:xct_abort_log
xct_aborting	sm_base.h	/^                        xct_aborting = 0x5,  \/\/ normal transaction abort$/;"	e	enum:smlevel_0::xct_state_t
xct_active	sm_base.h	/^                        xct_active = 0x1,  \/\/ active or rolling back in$/;"	e	enum:smlevel_0::xct_state_t
xct_auto_abort_t	xct.h	/^    xct_auto_abort_t() : _xct(new xct_t()) {$/;"	f	class:xct_auto_abort_t
xct_auto_abort_t	xct.h	/^class xct_auto_abort_t : public smlevel_0 {$/;"	c
xct_chaining	sm_base.h	/^                        xct_chaining = 0x3,$/;"	e	enum:smlevel_0::xct_state_t
xct_collect	vtable_sm.cpp	/^ss_m::xct_collect( vtable_t & res, bool names_too) $/;"	f	class:ss_m
xct_committing	sm_base.h	/^                        xct_committing = 0x4,$/;"	e	enum:smlevel_0::xct_state_t
xct_constraint_t	prologue.h	/^    enum xct_constraint_t {$/;"	g	class:prologue_rc_t
xct_coordinator_attr	sm_vtable_enum.h	/^    xct_coordinator_attr,$/;"	e	enum:__anon41
xct_core	xct.cpp	/^DEFINE_SM_ALLOC(xct_t::xct_core);$/;"	v
xct_core	xct.cpp	/^xct_t::xct_core::xct_core(tid_t const &t, state_t s, timeout_in_ms timeout)$/;"	f	class:xct_t::xct_core
xct_core	xct.h	/^    struct xct_core$/;"	s	class:xct_t
xct_dependent_t	xct.cpp	/^xct_dependent_t::xct_dependent_t(xct_t* xd) : _xd(xd), _registered(false)$/;"	f	class:xct_dependent_t
xct_dependent_t	xct_dependent.h	/^class xct_dependent_t {$/;"	c
xct_end_group_log	logrec.cpp	/^xct_end_group_log::xct_end_group_log(const xct_t *list[], int listlen)$/;"	f	class:xct_end_group_log
xct_end_log	logrec.cpp	/^xct_end_log::xct_end_log()$/;"	f	class:xct_end_log
xct_ended	sm_base.h	/^                        xct_ended = 0x7$/;"	e	enum:smlevel_0::xct_state_t
xct_forced_readonly_attr	sm_vtable_enum.h	/^    xct_forced_readonly_attr,$/;"	e	enum:__anon41
xct_freeing_space	sm_base.h	/^                        xct_freeing_space = 0x6,$/;"	e	enum:smlevel_0::xct_state_t
xct_freeing_space_log	logrec.cpp	/^xct_freeing_space_log::xct_freeing_space_log()$/;"	f	class:xct_freeing_space_log
xct_gtid_attr	sm_vtable_enum.h	/^    xct_gtid_attr,$/;"	e	enum:__anon41
xct_hashmap_next	lock_raw.h	/^    RawLock*                    xct_hashmap_next;$/;"	m	struct:RawLock
xct_hashmap_previous	lock_raw.h	/^    RawLock*                    xct_hashmap_previous;$/;"	m	struct:RawLock
xct_i	xct.h	/^    NORET xct_i(bool locked_accesses)$/;"	f	class:xct_i
xct_i	xct.h	/^class xct_i  {$/;"	c
xct_impl	sm.cpp	/^smlevel_0::xct_impl_t smlevel_0::xct_impl$/;"	m	class:smlevel_0	file:
xct_impl	sm_base.h	/^    static xct_impl_t xct_impl;$/;"	m	class:smlevel_0
xct_impl_t	sm_base.h	/^    enum xct_impl_t {$/;"	g	class:smlevel_0
xct_last	sm_vtable_enum.h	/^    xct_last$/;"	e	enum:__anon41
xct_list_t	logrec.cpp	/^xct_list_t::xct_list_t($/;"	f	class:xct_list_t
xct_list_t	logrec.h	/^struct xct_list_t {$/;"	s
xct_lock_entry_t	lock_x.h	/^    xct_lock_entry_t () : prev (NULL), next(NULL), private_hashmap_prev(NULL),$/;"	f	class:xct_lock_entry_t
xct_lock_entry_t	lock_x.h	/^class xct_lock_entry_t {$/;"	c
xct_lock_info_t	lock_x.cpp	/^xct_lock_info_t::xct_lock_info_t()$/;"	f	class:xct_lock_info_t
xct_lock_info_t	lock_x.h	/^class xct_lock_info_t : private smlevel_0 {$/;"	c
xct_log	smthread.h	/^    xct_log_t*       xct_log() { return tcb()._xct_log; }$/;"	f	class:smthread_t
xct_log_is_off	xct.h	/^    bool         xct_log_is_off() { return _xct_log_off; }$/;"	f	class:xct_log_t
xct_log_space_needed	sm.cpp	/^smlevel_0::fileoff_t ss_m::xct_log_space_needed()$/;"	f	class:ss_m
xct_log_switch_t	xct.h	/^    NORET xct_log_switch_t(switch_t s)  : old_state(OFF)$/;"	f	class:xct_log_switch_t
xct_log_switch_t	xct.h	/^class xct_log_switch_t : public smlevel_0 {$/;"	c
xct_log_t	xct.h	/^    NORET        xct_log_t(): _xct_log_off(false) {};$/;"	f	class:xct_log_t
xct_log_t	xct.h	/^class xct_log_t : public smlevel_0 {$/;"	c
xct_log_warn_check_t	sm_base.h	/^class xct_log_warn_check_t : public smlevel_0 {$/;"	c
xct_next	lock_raw.h	/^    RawLock*                    xct_next;$/;"	m	struct:RawLock
xct_next	log.cpp	/^bool log_i::xct_next(lsn_t& lsn, logrec_t*& r)  $/;"	f	class:log_i
xct_nthreads_attr	sm_vtable_enum.h	/^    xct_nthreads_attr,$/;"	e	enum:__anon41
xct_previous	lock_raw.h	/^    RawLock*                    xct_previous;$/;"	m	struct:RawLock
xct_reserve_log_space	sm.cpp	/^rc_t ss_m::xct_reserve_log_space(fileoff_t amt) {$/;"	f	class:ss_m
xct_stale	sm_base.h	/^    enum xct_state_t {  xct_stale = 0x0,$/;"	e	enum:smlevel_0::xct_state_t
xct_state_attr	sm_vtable_enum.h	/^    xct_state_attr,$/;"	e	enum:__anon41
xct_state_changed	xct_dependent.h	/^inline void xct_dependent_t::xct_state_changed(smlevel_0::xct_state_t, smlevel_0::xct_state_t)$/;"	f	class:xct_dependent_t
xct_state_t	prologue.h	/^    enum xct_state_t {$/;"	g	class:prologue_rc_t
xct_state_t	sm.h	/^    typedef smlevel_0::xct_state_t xct_state_t;$/;"	t	class:ss_m
xct_state_t	sm_base.h	/^    enum xct_state_t {  xct_stale = 0x0,$/;"	g	class:smlevel_0
xct_t	xct.cpp	/^DEFINE_SM_ALLOC(xct_t);$/;"	v
xct_t	xct.cpp	/^xct_t::xct_t(sm_stats_info_t* stats, timeout_in_ms timeout, bool sys_xct,$/;"	f	class:xct_t
xct_t	xct.h	/^class xct_t : public smlevel_0 {$/;"	c
xct_table	chkpt.h	/^  chkpt_xct_tab_t xct_table;$/;"	m	struct:chkpt_t
xct_tid_attr	sm_vtable_enum.h	/^    xct_tid_attr,$/;"	e	enum:__anon41
xct_to_tid	sm.cpp	/^tid_t ss_m::xct_to_tid(const xct_t* x)$/;"	f	class:ss_m
xct_vtable_attr_names	vtable_xct.cpp	/^const char *xct_vtable_attr_names[] = {$/;"	v
xd	xct_dependent.h	/^    xct_t*                xd() const { return _xd; }$/;"	f	class:xct_dependent_t
xidChainLogHeader	logrec.h	/^struct xidChainLogHeader$/;"	s
xidInfo	logrec.h	/^    xidChainLogHeader xidInfo;$/;"	m	class:logrec_t
xid_prev	logrec.h	/^logrec_t::xid_prev() const$/;"	f	class:logrec_t
xlist_mutex_is_mine	xct.cpp	/^bool xct_t::xlist_mutex_is_mine()$/;"	f	class:xct_t
xrec	logrec.h	/^    lockrec_t        xrec[max];$/;"	m	struct:chkpt_xct_lock_t
xrec	logrec.h	/^    xrec_t             xrec[max];$/;"	m	struct:chkpt_xct_tab_t
xrec	logrec.h	/^    xrec_t             xrec[max];$/;"	m	struct:xct_list_t
xrec_t	logrec.h	/^    struct xrec_t {$/;"	s	struct:chkpt_xct_tab_t
xrec_t	logrec.h	/^    struct xrec_t {$/;"	s	struct:xct_list_t
yieldtest	crash.cpp	/^yieldtest() $/;"	f	file:
youngest	logrec.h	/^    tid_t            youngest;    \/\/ maximum tid in session$/;"	m	struct:chkpt_xct_tab_t
youngest_tid	xct.cpp	/^xct_t::youngest_tid()$/;"	f	class:xct_t
zero	lock_s.h	/^inline void lockid_t::zero()$/;"	f	class:lockid_t
zero_page	sm.cpp	/^char smlevel_0::zero_page[page_sz];$/;"	m	class:smlevel_0	file:
zero_page	sm_base.h	/^    static char zero_page[page_sz];$/;"	m	class:smlevel_0
~AlignedMemory	backup.h	/^inline AlignedMemory::~AlignedMemory() { release(); }$/;"	f	class:AlignedMemory
~ArchiveDirectory	logarchiver.cpp	/^LogArchiver::ArchiveDirectory::~ArchiveDirectory()$/;"	f	class:LogArchiver::ArchiveDirectory
~ArchiveIndex	logarchiver.cpp	/^LogArchiver::ArchiveIndex::~ArchiveIndex()$/;"	f	class:LogArchiver::ArchiveIndex
~ArchiveScanner	logarchiver.h	/^        virtual ~ArchiveScanner() {};$/;"	f	class:LogArchiver::ArchiveScanner
~ArchiverControl	logarchiver.cpp	/^ArchiverControl::~ArchiverControl()$/;"	f	class:ArchiverControl
~ArchiverHeap	logarchiver.cpp	/^LogArchiver::ArchiverHeap::~ArchiverHeap()$/;"	f	class:LogArchiver::ArchiverHeap
~AsyncRingBuffer	ringbuffer.h	/^    ~AsyncRingBuffer()$/;"	f	class:AsyncRingBuffer
~AutoTurnOffLogging	restart.h	/^        ~AutoTurnOffLogging()$/;"	f	class:AutoTurnOffLogging
~BackupFile	backup.h	/^inline BackupFile::~BackupFile() { close(); }$/;"	f	class:BackupFile
~BackupManager	backup.h	/^inline BackupManager::~BackupManager() {}$/;"	f	class:BackupManager
~BackupOnDemandReader	backup_reader.h	/^    virtual ~BackupOnDemandReader()$/;"	f	class:BackupOnDemandReader
~BackupPrefetcher	backup_reader.cpp	/^BackupPrefetcher::~BackupPrefetcher()$/;"	f	class:BackupPrefetcher
~BackupReader	backup_reader.cpp	/^BackupReader::~BackupReader()$/;"	f	class:BackupReader
~BlockAssembly	logarchiver.cpp	/^LogArchiver::BlockAssembly::~BlockAssembly()$/;"	f	class:LogArchiver::BlockAssembly
~ConsolidationArray	log_carray.cpp	/^ConsolidationArray::~ConsolidationArray() {$/;"	f	class:ConsolidationArray
~DummyBackupReader	backup_reader.h	/^    virtual ~DummyBackupReader()$/;"	f	class:DummyBackupReader
~LogArchiver	logarchiver.cpp	/^LogArchiver::~LogArchiver()$/;"	f	class:LogArchiver
~LogConsumer	logarchiver.cpp	/^LogArchiver::LogConsumer::~LogConsumer()$/;"	f	class:LogArchiver::LogConsumer
~LogScanner	logarchiver.h	/^    ~LogScanner() {$/;"	f	class:LogScanner
~MergeHeapEntry	logarchiver.h	/^            virtual ~MergeHeapEntry() {}$/;"	f	struct:LogArchiver::ArchiveScanner::MergeHeapEntry
~MergerDaemon	logarchiver.h	/^        virtual ~MergerDaemon()$/;"	f	class:LogArchiver::MergerDaemon
~PoorMansOldestLsnTracker	log_lsn_tracker.cpp	/^PoorMansOldestLsnTracker::~PoorMansOldestLsnTracker() {$/;"	f	class:PoorMansOldestLsnTracker
~PrintBlockedThread	smthread.cpp	/^                        ~PrintBlockedThread() {};$/;"	f	class:PrintBlockedThread
~RawLockBackgroundThread	lock_raw.cpp	/^RawLockBackgroundThread::~RawLockBackgroundThread() {$/;"	f	class:RawLockBackgroundThread
~RawXctLockHashMap	lock_raw.cpp	/^RawXctLockHashMap::~RawXctLockHashMap() {$/;"	f	class:RawXctLockHashMap
~ReaderThread	logarchiver.h	/^        virtual ~ReaderThread() {}$/;"	f	class:LogArchiver::ReaderThread
~RestoreBitmap	restore.cpp	/^RestoreBitmap::~RestoreBitmap()$/;"	f	class:RestoreBitmap
~RestoreMgr	restore.cpp	/^RestoreMgr::~RestoreMgr()$/;"	f	class:RestoreMgr
~RestoreScheduler	restore.cpp	/^RestoreScheduler::~RestoreScheduler()$/;"	f	class:RestoreScheduler
~RunMerger	logarchiver.h	/^            virtual ~RunMerger() {}$/;"	f	struct:LogArchiver::ArchiveScanner::RunMerger
~RunScanner	logarchiver.cpp	/^LogArchiver::ArchiveScanner::RunScanner::~RunScanner()$/;"	f	class:LogArchiver::ArchiveScanner::RunScanner
~SegmentWriter	restore.cpp	/^SegmentWriter::~SegmentWriter()$/;"	f	class:SegmentWriter
~SmthreadFunc	smthread.cpp	/^SmthreadFunc::~SmthreadFunc()$/;"	f	class:SmthreadFunc
~SprScratchSpace	btree_logrec.h	/^    ~SprScratchSpace() { scratch_space_pool->destroy_object(p); }$/;"	f	struct:SprScratchSpace
~VolidCnt	xct.cpp	/^        ~VolidCnt()$/;"	f	class:VolidCnt
~WarmupThread	bf_tree.h	/^    virtual ~WarmupThread() {}$/;"	f	class:WarmupThread
~WriterThread	logarchiver.h	/^        virtual ~WriterThread() {}$/;"	f	class:LogArchiver::WriterThread
~XctLockHashMap	lock_x.cpp	/^XctLockHashMap::~XctLockHashMap() {$/;"	f	class:XctLockHashMap
~alloc_page_h	alloc_page.h	/^    ~alloc_page_h() {}$/;"	f	class:alloc_page_h
~auto_release_anchor_t	xct.h	/^    ~auto_release_anchor_t ()$/;"	f	class:auto_release_anchor_t
~auto_rollback_t	xct.h	/^    ~auto_rollback_t() {$/;"	f	class:auto_rollback_t
~bf_fixed_m	bf_fixed.cpp	/^bf_fixed_m::~bf_fixed_m() {$/;"	f	class:bf_fixed_m
~bf_hashtable	bf_hashtable.cpp	/^bf_hashtable<T>::~bf_hashtable() {$/;"	f	class:bf_hashtable
~bf_tree_cleaner	bf_tree_cleaner.cpp	/^bf_tree_cleaner::~bf_tree_cleaner()$/;"	f	class:bf_tree_cleaner
~bf_tree_cleaner_slave_thread_t	bf_tree_cleaner.cpp	/^bf_tree_cleaner_slave_thread_t::~bf_tree_cleaner_slave_thread_t()$/;"	f	class:bf_tree_cleaner_slave_thread_t
~bf_tree_m	bf_tree.cpp	/^bf_tree_m::~bf_tree_m() {$/;"	f	class:bf_tree_m
~borrowed_btree_page_h	btree_page_h.h	/^    ~borrowed_btree_page_h() {$/;"	f	class:borrowed_btree_page_h
~bt_cursor_t	btcursor.h	/^    ~bt_cursor_t() {close();}$/;"	f	class:bt_cursor_t
~btrec_t	btree_page_h.h	/^    NORET            ~btrec_t()        {};$/;"	f	class:btrec_t
~btree_m	btree.h	/^    NORET                        ~btree_m()  {};$/;"	f	class:btree_m
~btree_page_h	btree_page_h.h	/^    ~btree_page_h() {}$/;"	f	class:btree_page_h
~bucket_t	lock_bucket.h	/^    ~bucket_t() {$/;"	f	class:bucket_t
~check_compensated_op_nesting	sm_base.h	/^    ~check_compensated_op_nesting() {$/;"	f	struct:check_compensated_op_nesting
~chkpt_m	chkpt.cpp	/^chkpt_m::~chkpt_m()$/;"	f	class:chkpt_m
~chkpt_read_critical_section	chkpt_serial.h	/^    ~chkpt_read_critical_section()$/;"	f	struct:chkpt_read_critical_section
~chkpt_thread_t	chkpt.cpp	/^chkpt_thread_t::~chkpt_thread_t()$/;"	f	class:chkpt_thread_t
~fixable_page_h	fixable_page_h.h	/^    ~fixable_page_h() { unfix(); }$/;"	f	class:fixable_page_h
~fixed_lists_mem_t	mem_mgmt.cpp	/^fixed_lists_mem_t::~fixed_lists_mem_t()$/;"	f	class:fixed_lists_mem_t
~func_helper	smthread.h	/^    ~func_helper() {$/;"	f	class:func_helper
~generic_page_h	generic_page.h	/^    virtual ~generic_page_h() {}$/;"	f	class:generic_page_h
~iter_t	plog.h	/^        ~iter_t()$/;"	f	class:plog_t::iter_t
~latch_auto_release	bf_tree.cpp	/^    ~latch_auto_release () {$/;"	f	struct:latch_auto_release
~lil_global_store_table	lock_lil.h	/^    ~lil_global_store_table() {}$/;"	f	class:lil_global_store_table
~lil_global_table	lock_lil.h	/^    ~lil_global_table(){}$/;"	f	class:lil_global_table
~lil_global_vol_table	lock_lil.h	/^    ~lil_global_vol_table(){$/;"	f	class:lil_global_vol_table
~lil_lock_info_ptr	xct.cpp	/^    ~lil_lock_info_ptr() { put(0); }$/;"	f	struct:lil_lock_info_ptr
~lil_private_store_table	lock_lil.h	/^    ~lil_private_store_table(){}$/;"	f	class:lil_private_store_table
~lil_private_table	lock_lil.h	/^    ~lil_private_table(){}$/;"	f	class:lil_private_table
~lil_private_vol_table	lock_lil.h	/^    ~lil_private_vol_table(){}$/;"	f	class:lil_private_vol_table
~lock_core_m	lock_core.cpp	/^lock_core_m::~lock_core_m()$/;"	f	class:lock_core_m
~lock_info_ptr	xct.cpp	/^    ~lock_info_ptr() { put(0); }$/;"	f	struct:lock_info_ptr
~lock_m	lock.cpp	/^lock_m::~lock_m()$/;"	f	class:lock_m
~lock_queue_t	lock_bucket.h	/^    ~lock_queue_t() {}$/;"	f	class:lock_queue_t
~log_common	log_core.cpp	/^log_common::~log_common()$/;"	f	class:log_common
~log_core	log_core.cpp	/^log_core::~log_core()$/;"	f	class:log_core
~log_i	log.h	/^log_i::~log_i()$/;"	f	class:log_i
~log_m	log.h	/^    virtual ~log_m() {};$/;"	f	class:log_m
~log_resv	log_resv.cpp	/^log_resv::~log_resv()$/;"	f	class:log_resv
~log_storage	log_storage.cpp	/^log_storage::~log_storage()$/;"	f	class:log_storage
~logbuf_core	logbuf_core.cpp	/^logbuf_core::~logbuf_core()$/;"	f	class:logbuf_core
~logbuf_hashtable	logbuf_hashtable.cpp	/^logbuf_hashtable::~logbuf_hashtable() {$/;"	f	class:logbuf_hashtable
~logbuf_seg	logbuf_seg.cpp	/^logbuf_seg::~logbuf_seg() {$/;"	f	class:logbuf_seg
~logrec_accounting_impl_t	logrec.cpp	/^    ~logrec_accounting_impl_t() {}$/;"	f	class:logrec_accounting_impl_t
~mem_mgmt_t	mem_mgmt.h	/^    virtual ~mem_mgmt_t() {};$/;"	f	class:mem_mgmt_t
~no_lock_section_t	xct.h	/^    ~no_lock_section_t () {$/;"	f	class:no_lock_section_t
~partition_t	partition.h	/^    ~partition_t()$/;"	f	class:partition_t
~pin_for_refix_holder	bf_tree.h	/^    ~pin_for_refix_holder () {$/;"	f	class:pin_for_refix_holder
~plog_t	plog.cpp	/^plog_t::~plog_t()$/;"	f	class:plog_t
~plog_xct_t	plog_xct.cpp	/^plog_xct_t::~plog_xct_t()$/;"	f	class:plog_xct_t
~prologue_rc_t	prologue.h	/^prologue_rc_t::~prologue_rc_t()$/;"	f	class:prologue_rc_t
~restart_m	restart.h	/^    NORET                        ~restart_m()$/;"	f	class:restart_m
~restart_thread_t	restart.h	/^    NORET ~restart_thread_t()$/;"	f	class:restart_thread_t
~sm_store_info_t	sm.h	/^    NORET ~sm_store_info_t() {  }$/;"	f	class:sm_store_info_t
~smthread_init_t	smthread.cpp	/^smthread_init_t::~smthread_init_t()$/;"	f	class:smthread_init_t
~smthread_t	smthread.cpp	/^smthread_t::~smthread_t()$/;"	f	class:smthread_t
~ss_m	sm.cpp	/^ss_m::~ss_m()$/;"	f	class:ss_m
~stid_list_elem_t	xct.h	/^    ~stid_list_elem_t()$/;"	f	class:stid_list_elem_t
~stnode_page_h	stnode_page.h	/^    ~stnode_page_h() {}$/;"	f	class:stnode_page_h
~sys_xct_section_t	xct.cpp	/^sys_xct_section_t::~sys_xct_section_t()$/;"	f	class:sys_xct_section_t
~tcb_t	smthread.h	/^        ~tcb_t() { destroy_TL_stats(); }$/;"	f	struct:smthread_t::tcb_t
~ticker_thread_t	sm.cpp	/^    virtual ~ticker_thread_t() {}$/;"	f	class:ticker_thread_t
~transit_bucket_t	bf_transit_bucket.h	/^    NORET ~transit_bucket_t() $/;"	f	class:transit_bucket_t
~verification_context	btree_impl_verify.cpp	/^verification_context::~verification_context ()$/;"	f	class:verification_context
~verify_volume_result	btree_impl_verify.cpp	/^verify_volume_result::~verify_volume_result()$/;"	f	class:verify_volume_result
~vol_m	vol.cpp	/^vol_m::~vol_m()$/;"	f	class:vol_m
~vol_t	vol.cpp	/^vol_t::~vol_t() {$/;"	f	class:vol_t
~volhdr_t	vol.h	/^    virtual ~volhdr_t() {}$/;"	f	class:volhdr_t
~xct_auto_abort_t	xct.h	/^    ~xct_auto_abort_t() {$/;"	f	class:xct_auto_abort_t
~xct_core	xct.cpp	/^xct_t::xct_core::~xct_core()$/;"	f	class:xct_t::xct_core
~xct_dependent_t	xct.cpp	/^xct_dependent_t::~xct_dependent_t()$/;"	f	class:xct_dependent_t
~xct_i	xct.h	/^    NORET ~xct_i() {$/;"	f	class:xct_i
~xct_lock_info_t	lock_x.cpp	/^xct_lock_info_t::~xct_lock_info_t() {$/;"	f	class:xct_lock_info_t
~xct_log_switch_t	xct.h	/^    ~xct_log_switch_t()  {$/;"	f	class:xct_log_switch_t
~xct_t	xct.cpp	/^xct_t::~xct_t()$/;"	f	class:xct_t
